{"data":{"markdownRemark":{"html":"<div class=\"content\">\n<p>Kurssin aikana on websovelluskehityksen rinnalla tavoite ja tarve oppia riittävässä määrin Javascriptiä.</p>\n<p>Javascript on kehittynyt viime vuosina nopeaan tahtiin, ja käytämme kurssilla kielen uusimpien versioiden piirteitä. Javascript-standardin virallinen nimi on <a href=\"https://en.wikipedia.org/wiki/ECMAScript\">ECMAScript</a>. Tämän hetken tuorein versio on kesäkuussa 2017 julkaistu <a href=\"https://www.ecma-international.org/ecma-262/9.0/index.html\">ES9</a>, toiselta nimeltään ECMAScript 2018.</p>\n<p>Selaimet eivät vielä osaa kaikkia Javascriptin uusimpien versioiden ominaisuuksia. Tämän takia selaimessa suoritetaan useimmiten koodia joka on käännetty (englanniksi <em>transpiled</em>) uudemmasta Javascriptin versiosta johonkin vanhempaan, laajemmin tuettuun versioon.</p>\n<p>Tällä hetkellä johtava tapa tehdä transpilointi on <a href=\"https://babeljs.io/\">Babel</a>. Create-react-app:in avulla luoduissa React-sovelluksissa on valmiiksi konfiguroitu automaattinen transpilaus. Katsomme kurssin <a href=\"/osa7\">osassa 7</a> tarkemmin miten transpiloinnin konfigurointi tapahtuu.</p>\n<p><a href=\"https://nodejs.org/en/\">Node.js</a> on melkein missä vaan, mm. palvelimilla toimiva, Googlen <a href=\"https://developers.google.com/v8/\">chrome V8</a>-javascriptmoottoriin perustuva Javascript-suoritusympäristö. Harjoitellaan hieman Javascriptiä Nodella. Tässä oletetaan, että koneellasi on Node.js:stä vähintään versio <em>v8.10.0</em>. Noden tuoreet versiot osaavat suoraan Javascriptin uusia versioita, joten koodin transpilaus ei ole tarpeen.</p>\n<p>Koodi kirjoitetaan <em>.js-</em>päätteiseen tiedostoon, ja suoritetaan komennolla <code>node tiedosto.js</code></p>\n<p>Koodia on mahdollisuus kirjoittaa myös Node.js-konsoliin, joka aukeaa kun kirjoitat komentorivillä <em>node</em> tai myös selaimen developer toolin konsoliin. Chromen uusimmat versiot osaavat suoraan transpiloimatta <a href=\"http://kangax.github.io/compat-table/es2016plus/\">melko hyvin</a> Javascriptin uusiakin piirteitä.</p>\n<p>Javascript muistuttaa nimensä ja syntaksinsa puolesta läheisesti Javaa. Perusmekanismeiltaan kielet kuitenkin poikkeavat radikaalisti. Java-taustalta tultaessa Javascriptin käyttäytyminen saattaa aiheuttaa hämmennystä, varsinkin jos kielen piirteistä ei viitsitä ottaa selvää.</p>\n<p>Tietyissä piireissä on myös ollut suosittua yrittää \"simuloida\" Javascriptilla eräitä Javan piirteitä ja ohjelmointitapoja. En suosittele.</p>\n<h3>Muuttujat</h3>\n<p>Javascriptissä on muutama tapa määritellä muuttujia:</p>\n<pre><code class=\"language-js\">const x = 1;\nlet y = 5;\n\nconsole.log(x, y); // tulostuu 1, 5\ny += 10;\nconsole.log(x, y); // tulostuu 1, 15\ny = 'teksti';\nconsole.log(x, y); // tulostuu 1, teksti\nx = 4; // aiheuttaa virheen\n</code></pre>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const\">const</a> ei oikeastaan määrittele muuttujaa vaan <em>vakion</em>, jonka arvoa ei voi enää muuttaa. <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let\">let</a> taas määrittelee normaalin muuttujan.</p>\n<p>Esimerkistä näemme myös, että muuttujan tallettaman tiedon tyyppi voi vaihtaa tyyppiä suorituksen aikana, <em>y</em> tallettaa aluksi luvun ja lopulta merkkijonon.</p>\n<p>Javascriptissa on myös mahdollista määritellä muuttujia avainsanan <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var\">var</a> avulla. Var oli pitkään ainoa tapa muuttujien määrittelyyn, const ja let tulivat kieleen mukaan vasta versiossa ES6. Var toimii tietyissä tilanteissa <a href=\"https://medium.com/craft-academy/javascript-variables-should-you-use-let-var-or-const-394f7645c88f\">eri</a> <a href=\"http://www.jstips.co/en/javascript/keyword-var-vs-let/\">tavalla</a> kuin useimpien muiden kielien muuttujien määrittely. Tällä kurssilla varin käyttö ei ole suositeltavaa eli käytä aina const:ia tai let:iä!</p>\n<p>Lisää aiheesta esim. youtubessa <a href=\"https://youtu.be/sjyJBL5fkp8\">var, let and const - ES6 JavaScript Features</a></p>\n<h3>Taulukot</h3>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\">Taulukko</a> ja muutama esimerkki sen käytöstä</p>\n<pre><code class=\"language-js\">const t = [1, -1, 3]\n\nt.push(5)\n\nconsole.log(t.length)   // tulostuu 4\nconsole.log(t[1])       // tulostuu -1\n\nt.forEach(luku => {\n  console.log(luku)     // tulostuu 1, -1, 3 ja 5 omille riveilleen\n})\n</code></pre>\n<p>Huomattavaa esimerkissä on se, että taulukon sisältöä voi muuttaa vaikka sen on määritelty <em>const</em>:ksi. Koska taulukko on olio, viittaa muuttuja koko ajan samaan olioon. Olion sisältö muuttuu sitä mukaa kuin taulukkoon lisätään uusia alkioita.</p>\n<p>Eräs tapa käydä taulukon alkiot läpi on esimerkissä käytetty <em>forEach</em>, joka saa parametrikseen nuolisyntaksilla määritellyn <em>funktion</em></p>\n<pre><code class=\"language-js\">luku => {\n  console.log(luku)\n}\n</code></pre>\n<p>forEach kutsuu funktiota <em>jokaiselle taulukon alkiolle</em> antaen taulukon alkion aina parametrina. forEachin parametrina oleva funktio voi saada myös <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\">muita parametreja</a>.</p>\n<p>Edellisessä esimerkissä taulukkoon lisättiin uusi alkio metodilla <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push\">push</a>. Reactin yhteydessä sovelletaan usein funktionaalisen ohjelmoinnin tekniikoita, jonka eräs piirre on käyttää muuttumattomia (immutable) tietorakenteita. React-koodissa kannattaakin mielummin käyttää metodia <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat\">concat</a>, joka ei lisää alkiota taulukkoon vaan luo uuden taulukon, jossa on \"lisättävä\" alkio sekä vanhan taulukon sisältö:</p>\n<pre><code class=\"language-js\">const t = [1, -1, 3]\n\nconst t2 = t.concat(5)\n\nconsole.log(t)    // tulostuu [1, -1, 3]\nconsole.log(t2)   // tulostuu [1, -1, 3, 5]\n</code></pre>\n<p>Metodi <em>t.concat(5)</em> ei siis lisää uutta alkiota vanhaan taulukkoon, vaan palauttaa uuden taulukon joka sisältää vanhan taulukon alkioiden lisäksi uuden alkion.</p>\n<p>Taulukoille on määritelty runsaasti hyödyllisiä operaatioita. Katsotaan pieni esimerkki metodin <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\">map</a> käytöstä.</p>\n<pre><code class=\"language-js\">const t = [1, 2, 3, 4]\n\nconst m1 = t.map(luku => luku * 2)\nconsole.log(m1)   // tulostuu [2, 4, 6, 8]\n</code></pre>\n<p>Map siis muodostaa taulukon perusteella <em>uuden taulukon</em>, jonka jokainen alkio muodostetaan map:in parametrina olevan funktion avulla. </p>\n<p>Map voi muuttaa taulukon myös täysin erilaiseen muotoon:</p>\n<pre><code class=\"language-js\">const m2 = t.map(luku => '&#x3C;li>' + luku + '&#x3C;/li>')\nconsole.log(m2)   // tulostuu [ '&#x3C;li>1&#x3C;/li>', '&#x3C;li>2&#x3C;/li>', '&#x3C;li>3&#x3C;/li>', '&#x3C;li>4&#x3C;/li>' ]\n</code></pre>\n<p>Eli lukuja sisältävästä taulukosta tehdään map-metodin avulla HTML-koodia sisältävä taulukko. Tulemmekin kurssin <a href=\"/osa2\">osassa2</a> näkemään että mapia käytetään Reactissa todella usein.</p>\n<p>Taulukon yksittäisiä alkioita on helppo sijoittaa muuttujiin <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\">destrukturoivan</a> sijoituslauseen avulla:</p>\n<pre><code class=\"language-js\">const t = [1, 2, 3, 4, 5]\n\nconst [eka, toka, ...loput] = t\n\nconsole.log(eka, toka)    // tulostuu 1, 2\nconsole.log(loput)        // tulostuu [3, 4 ,5]\n</code></pre>\n<p>Eli muuttujiin <em>eka</em> ja <em>toka</em> tulee sijoituksen ansiosta taulukon kaksi ensimmäistä lukua. Muuttujaan <em>loput</em> \"kerätään\" sijoituksesta jäljellejääneet luvut omaksi taulukoksi.</p>\n<h3>Oliot</h3>\n<p>Javasriptissa on muutama tapa määritellä olioita. Erittäin yleisesti käytetään <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Object_literals\">olioliteraaleja</a>, eli määritellään olio luettelemalla sen kentät (englanniksi property) aaltosulkeiden sisällä:</p>\n<pre><code class=\"language-js\">const olio1 = {\n  nimi: 'Arto Hellas',\n  ika: 35,\n  koulutus: 'Filosofian tohtori',\n}\n\nconst olio2 = {\n  nimi: 'Full Stack -websovelluskehitys',\n  taso: 'aineopinto',\n  laajuus: 5,\n}\n\nconst olio3 = {\n  nimi: {\n    etunimi: 'Juha',\n    sukunimi: 'Tauriainen',\n  },\n  arvosanat: [2, 3, 5, 3],\n  laitos: 'TKTL',\n}\n</code></pre>\n<p>Kenttien arvot voivat olla tyypiltään mitä vaan, lukuja, merkkijonoja, taulukoita, olioita...</p>\n<p>Olioiden kenttiin viitataan pistenotaatiolla, tai hakasulkeilla:</p>\n<pre><code class=\"language-js\">console.log(olio1.nimi)         // tulostuu Arto Hellas\nconst kentanNimi = 'ika'\nconsole.log(olio1[kentanNimi])  // tulostuu 35\n</code></pre>\n<p>Olioille voidaan lisätä kenttiä myös lennossa joko pistenotaation tai hakasulkeiden avulla:</p>\n<pre><code class=\"language-js\">olio1.osoite = 'Tapiola'\nolio1['salainen numero'] = 12341\n</code></pre>\n<p>Jälkimmäinen lisäyksistä on pakko tehdä hakasulkeiden avulla, sillä pistenotaatiota käytettäessä 'salainen numero' ei kelpaa kentän nimeksi.</p>\n<p>Javascriptissä olioilla voi luonnollisesti olla myös metodeja. Emme kuitenkaan tarvitse tällä kurssilla ollenkaan itse määriteltyjä metodillisia olioita, joten asiaa ei tällä kurssilla käsitellä.</p>\n<p>Olioita on myös mahdollista määritellä ns. konstruktorifunktioiden avulla, jolloin saadaan aikaan hieman monien ohjelmointikielten, esim. Javan luokkia (class) muistuttava mekanismi. Javascriptissä ei kuitenkaan ole luokkia samassa mielessä kuin olio-ohjelmointikielissä. Kieleen on kuitenkin lisätty versiosta ES6 alkaen <em>luokkasyntaksi</em>, joka helpottaa tietyissä tilanteissa olio-ohjelmointikielimäisten luokkien esittämistä. </p>\n<h3>Funktiot</h3>\n<p>Olemme jo tutustuneet ns. nuolifunktioiden määrittelyyn. Täydellinen eli \"pitkän kaavan\" mukaan menevä tapa nuolifunktion määrittelyyn on seuraava</p>\n<pre><code class=\"language-js\">const summa = (p1, p2) => {\n  console.log(p1)\n  console.log(p2)\n  return p1 + p2\n}\n</code></pre>\n<p>ja funktiota kutsutaan kuten olettaa saattaa</p>\n<pre><code class=\"language-js\">const vastaus = summa(1, 5)\nconsole.log(vastaus)         \n</code></pre>\n<p>Jos parameteja on vain yksi, voidaan sulut jättää määrittelystä pois:</p>\n<pre><code class=\"language-js\">const nelio = p => {\n  console.log(p)\n  return p * p\n};\n</code></pre>\n<p>Jos funktio sisältää ainoastaan yhden lausekkeen, ei aaltosulkeita tarvita. Tällöin funktio palauttaa ainoan lausekkeensa arvon. Eli edellinen voitaisiin ilmaista lyhyemmin seuraavasti:</p>\n<pre><code class=\"language-js\">const nelio = p => p * p\n</code></pre>\n<p>Tämä muoto on erityisen kätevä käsiteltäessä taulukkoja esim. map-metodin avulla:</p>\n<pre><code class=\"language-js\">const t = [1, 2, 3]\nconst tnelio = t.map(p => p * p)\n// tnelio on nyt [1, 4, 9]\n</code></pre>\n<p>Nuolifunktio on tullut Javascriptiin vasta muutama vuosi sitten version <a href=\"http://es6-features.org/\">ES6</a> myötä. Tätä ennen ja paikoin nykyäänkin funktioiden määrittely tapahtui avainsanan <em>function</em> avulla.</p>\n<p>Määrittelytapoja on kaksi, funktiolle voidaan antaa <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function\">function declaration</a> -tyyppisessä määrittelyssä <em>nimi</em> jonka avulla funktioon voidaan viitata:</p>\n<pre><code class=\"language-js\">function tulo(a, b) {\n  return a * b\n}\n\nconst vastaus = tulo(2, 6)\n</code></pre>\n<p>Toinen tapa on tehdä määrittely <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\">funktiolausekkeena</a>. Tällöin funktiolle ei tarvitse antaa nimeä ja määrittely voi sijaita muun koodin seassa:</p>\n<pre><code class=\"language-js\">const keskiarvo = function(a, b) {\n  return (a + b) / 2\n};\n\nconst vastaus = keskiarvo(2, 5)\n</code></pre>\n<p>Määrittelemme tällä kurssilla kaikki funktiot nuolisyntaksin avulla.</p>\n</div>\n<div class=\"tasks\">\n  <h3>Tehtäviä</h3>\n<p>  <em>Jatkamme edellisissä tehtävissä aloitetun ohjelman rakentamista, voit siis tehdä koodin samaan projektiin, palautuksessa ollaan kiinnostuneita ainoastaan ohjelman lopullisesta versiosta.</em></p>\n<p><strong>Protip:</strong> voit kohdata ohjelmoidessasi ongelmiasen suhteen missä muodossa kompnentin saamat <em>propsit</em> ovat. Hyvä keino varmistua asiasta on tulostaa propsit konsoliin, esim. seuraavasti:</p>\n<pre><code class=\"language-react\">const Header = props => {\n  console.log(props)\n  return &#x3C;h1>{props.course}&#x3C;/h1>\n}\n</code></pre>\n  <h4>1.3: tieto olioissa</h4>\n<p>Siirrytään käyttämään sovelluksessamme oliota. Muuta <em>App</em>:in muuttujamäärittelyt seuraavaan muotoon ja muuta sovelluksen kaikkia osia niin, että se taas toimii:</p>\n<pre><code class=\"language-react\">const App = () => {\n  const course = 'Half Stack -sovelluskehitys'\n  const part1 = {\n    name: 'Reactin perusteet',\n    exercises: 10\n  }\n  const part2 = {\n    name: 'Tiedonvälitys propseilla',\n    exercises: 7\n  }\n  const part3 = {\n    name: 'Komponenttien tila',\n    exercises: 14\n  }\n\n  return (\n    &#x3C;div>\n      ...\n    &#x3C;/div>\n  )\n}\n</code></pre>\n  <h4>1.4: oliot taulukkoon</h4>\n<p>Ja laitetaan oliot taulukkoon, eli muuta <em>App</em>:in muuttujamäärittelyt seuraavaan muotoon ja muuta sovelluksen kaikki osat vastaavasti:</p>\n<pre><code class=\"language-react\">const App = () => {\n  const course = 'Half Stack -sovelluskehitys'\n  const parts = [\n    {\n      name: 'Reactin perusteet',\n      exercises: 10\n    },\n    {\n      name: 'Tiedonvälitys propseilla',\n      exercises: 7\n    },\n    {\n      name: 'Komponenttien tila',\n      exercises: 14\n    }\n  ]\n\n  return (\n    &#x3C;div>\n      ...\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p><strong>HUOM:</strong> tässä vaiheessa <em>voit olettaa, että taulukossa on aina kolme alkiota</em>, eli taulukkoa ei ole pakko käydä läpi looppaamalla. Palataan taulukossa olevien olioiden perusteella tapahtuvaan komponenttien renderöintiin asiaan tarkemmin kurssin <a href=\"../osa2\">seuraavassa osassa</a>.</p>\n<p>Älä kuitenkaan välitä eri olioita komponenttien välillä (esim. komponentista <em>App</em> komponenttiin <em>Content</em>) erillisinä propsina, vaan suoraan taulukkona:</p>\n<pre><code class=\"language-react\">const App = () => {\n  // const-määrittelyt\n\n  return (\n    &#x3C;div>\n      &#x3C;Header kurssi={course} />\n      &#x3C;Content osat={parts} />\n      &#x3C;Total osat={parts} />\n    &#x3C;/div>\n  )\n}\n</code></pre>\n  <h4>1.5: jako komponenteiksi</h4>\n<p>Viedään muutos vielä yhtä askelta pidemmälle, eli tehdään kurssista ja sen osista yksi Javascript-olio. Korjaa kaikki mikä menee rikki.</p>\n<pre><code class=\"language-react\">const App = () => {\n  const kurssi = {\n    nimi: 'Half Stack -sovelluskehitys',\n    osat: [\n      {\n        nimi: 'Reactin perusteet',\n        tehtavia: 10\n      },\n      {\n        nimi: 'Tiedonvälitys propseilla',\n        tehtavia: 7\n      },\n      {\n        nimi: 'Komponenttien tila',\n        tehtavia: 14\n      }\n    ]\n  }\n\n  return (\n    &#x3C;div>\n      ...\n    &#x3C;/div>\n  )\n}\n</code></pre>\n</div>\n<div class=\"content\">\n<h3>Olioiden metodit ja this</h3>\n<p>Kaikille kolmelle tavalle määritellä funktio on oma paikkansa.</p>\n<p>Nuolifunktiot ja avainsanan <em>function</em> avulla määritellyt funktiot kuitenkin poikkeavat radikaalisti siitä miten ne käyttäytyvät avainsanan <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\">this</a> suhteen.</p>\n<p>Voimme liittää oliolle metodeja määrittelemällä niille kenttiä, jotka ovat funktioita:</p>\n<pre><code class=\"language-js\">const arto = {\n  nimi: 'Arto Hellas',\n  ika: 35,\n  koulutus: 'Filosofian tohtori',\n  tervehdi: function() {\n    console.log('hello, my name is', this.nimi);\n  },\n};\n\narto.tervehdi(); // tulostuu hello, my name is Arto Hellas\n</code></pre>\n<p>metodeja voidaan liittää olioille myös niiden luomisen jälkeen:</p>\n<pre><code class=\"language-js\">const arto = {\n  nimi: 'Arto Hellas',\n  ika: 35,\n  koulutus: 'Filosofian tohtori',\n  tervehdi: function() {\n    console.log('hello, my name is', this.nimi);\n  },\n};\n\narto.vanhene = function() {\n  this.ika += 1;\n};\n\nconsole.log(arto.ika); // tulostuu 35\narto.vanhene();\nconsole.log(arto.ika); // tulostuu 36\n</code></pre>\n<p>Muutetaan oliota hiukan</p>\n<pre><code class=\"language-js\">const arto = {\n  nimi: 'Arto Hellas',\n  tervehdi: function() {\n    console.log('hello, my name is', this.nimi);\n  },\n  laskeSumma: function(a, b) {\n    console.log(a + b);\n  },\n};\n\narto.laskeSumma(1, 4); // tulostuu 5\n\nconst viiteSummaan = arto.laskeSumma;\nviiteSummaan(10, 15); // tulostuu 25\n</code></pre>\n<p>Oliolla on nyt metodi <em>laskeSumma</em>, joka osaa laskea parametrina annettujen lukujen summan. Metodia voidaan kutsua normaaliin tapaan olion kautta <code>arto.laskeSumma(1, 4)</code> tai tallettamalla <em>metodiviite</em> muuttujaan ja kutsumalla metodia muuttujan kautta <code>viiteSummaan(10, 15)</code>.</p>\n<p>Jos yritämme samaa metodille <em>tervehdi</em>, aiheutuu ongelmia:</p>\n<pre><code class=\"language-js\">const arto = {\n  nimi: 'Arto Hellas',\n  tervehdi: function() {\n    console.log('hello, my name is', this.nimi);\n  },\n  laskeSumma: function(a, b) {\n    console.log(a + b);\n  },\n};\n\narto.tervehdi(); // tulostuu hello, my name is Arto Hellas\n\nconst viiteTervehdykseen = arto.tervehdi;\nviiteTervehdykseen(); // tulostuu hello, my name is undefined\n</code></pre>\n<p>Kutsuttaessa metodia viitteen kautta, on metodi kadottanut tiedon siitä mikä oli alkuperäinen <em>this</em>. Toisin kuin melkein kaikissa muissa kielissä, Javascriptissa <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\">this</a>:n arvo määrittyy sen mukaan <em>miten metodia on kutsuttu</em>. Kutsuttaessa metodia viitteen kautta, <em>this</em>:in arvoksi tulee ns. <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Global_object\">globaali objekti</a> ja lopputulos ei ole yleensä ollenkaan se, mitä sovelluskehittäjä olettaa.</p>\n<p>This:in kadottaminen aiheuttaa Reactilla ja Node.js:lla ohjelmoidessa monia potentiaalisia ongelmia. Eteen tulee erittäin usein tilanteita, missä Reactin/Noden (oikeammin ilmaistuna selaimen Javascript-moottorin) tulee kutsua joitain käyttäjän määrittelemien olioiden metodeja. Tälläinen tilanne tulee esim. jos pyydetään Artoa tervehtimään sekunnin kuluttua metodia <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout\">setTimeout</a> hyväksikäyttäen.</p>\n<pre><code class=\"language-js\">const arto = {\n  nimi: 'Arto Hellas',\n  tervehdi: function() {\n    console.log('hello, my name is', this.nimi);\n  },\n};\n\nsetTimeout(arto.tervehdi, 1000);\n</code></pre>\n<p>Javascriptissa this:in arvo siis määräytyy siitä miten metodia on kutsuttu. setTimeoutia käytettäessä metodia kutsuu Javascript-moottori ja this viittaa Timeout-olioon.</p>\n<p>On useita mekanismeja, joiden avulla alkuperäinen <em>this</em> voidaan säilyttää, eräs näistä on metodin <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\">bind</a> käyttö:</p>\n<pre><code class=\"language-js\">setTimeout(arto.tervehdi.bind(arto), 1000);\n</code></pre>\n<p>Komento <code>arto.tervehdi.bind(arto)</code> luo uuden funktion, missä se on sitonut <em>this</em>:in tarkoittamaan Artoa riippumatta siitä missä ja miten metodia kutsutaan.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">Nuolifunktioiden</a> avulla on mahdollista ratkaista eräitä this:iin liittyviä ongelmia. Olioiden metodeina niitä ei kuitenkaan kannata käyttää, sillä silloin <em>this</em> ei toimi ollenkaan. Palaamme nuolifunktioiden this:in käyttäytymiseen myöhemmin.</p>\n<p>Jos haluat ymmärtää paremmin javascriptin <em>this</em>:in toimintaa, löytyy internetistä runsaasti materiaalia aiheesta. Esim. <a href=\"https://egghead.io\">egghead.io</a>:n 20 minuutin screencastsarja <a href=\"https://egghead.io/courses/understand-javascript-s-this-keyword-in-depth\">Understand JavaScript's this Keyword in Depth</a> on erittäin suositeltava!</p>\n<h3>Luokat</h3>\n<p>Kuten aiemmin mainittiin, Javascriptissä ei ole olemassa olio-ohjelmointikielten luokkamekanismia. Javascriptissa on kuitenkin ominaisuuksia, jotka mahdollistavat olio-ohjelmoinnin <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes\">luokkien</a> \"simuloinnin\". Emme mene nyt sen tarkemmin Javascriptin olioiden taustalla olevaan <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\">prototyyppiperintämekanismiin</a>.</p>\n<p>Tutustumme kuitenkin pikaisesti ES6:n myötä Javascriptiin tulleeseen <em>luokkasyntaksiin</em>, joka helpottaa oleellisesti luokkien (tai luokan kaltaisten asioiden) määrittelyä Javascriptissa.</p>\n<p>Seuraavassa on määritelty \"luokka\" Henkilö ja sille kaksi Henkilö-oliota:</p>\n<pre><code class=\"language-js\">class Henkilo {\n  constructor(nimi, ika) {\n    this.nimi = nimi;\n    this.ika = ika;\n  }\n  tervehdi() {\n    console.log('hello, my name is', this.nimi);\n  }\n}\n\nconst arto = new Henkilo('Arto Hellas', 35);\narto.tervehdi();\n\nconst jami = new Henkilo('Jami Kousa', 21);\njami.tervehdi();\n</code></pre>\n<p>Syntaksin osalta luokat ja niistä luodut oliot muistuttavat erittäin paljon esim. Javan olioita. Käyttäytymiseltäänkin ne ovat aika lähellä Javan olioita. Perimmiltään kyseessä on kuitenkin edelleen Javascriptin <a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance\">prototyyppiperintään</a> perustuvista olioista. Molempien olioiden todellinen tyyppi on <em>Object</em> sillä Javascriptissä ei perimmiltään ole muita tyyppejä kuin <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures\">Boolean, Null, Undefined, Number, String, Symbol ja Object</a></p>\n<p>Luokkasyntaksin tuominen Javascriptiin on osin kiistelty lisäys, ks. esim. <a href=\"https://github.com/joshburgess/not-awesome-es6-classes\">Not Awesome: ES6 Classes</a> tai <a href=\"https://medium.com/@rajaraodv/is-class-in-es6-the-new-bad-part-6c4e6fe1ee65\">Is “Class” In ES6 The New “Bad” Part?</a></p>\n<p>ES6:n luokkasyntaksia käytetään kuitenkin paljon Reactissa ja Node.js:ssä ja siksi mekin käytämme sitä sopivissa määrin. Olio-ohjelmointimainen luokkahierarkioiden luominen ei kuitenkaan ole Reactin eikä tämän kurssin suositeltavan hengen mukaista. Reactia ohjelmoitaessa pyritään enemmän funktionaaliseen ohjelmointityyliin.</p>\n<h3>Javascript-materiaalia</h3>\n<p>Javascriptistä löytyy verkosta suuret määrät sekä hyvää että huonoa materiaalia. Tällä sivulla lähes kaikki Javascriptin ominaisuuksia käsittelevät linkit ovat <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript\">Mozillan javascript -materiaaliin</a>.</p>\n<p>Mozillan sivuilta kannattaa lukea oikeastaan välittömästi <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript\">A re-introduction to JavaScript (JS tutorial)</a>.</p>\n<p>Jos haluat tutustua todella syvällisesti Javascriptiin, löytyy internetistä ilmaiseksi mainio kirjasarja <a href=\"https://github.com/getify/You-Dont-Know-JS\">You-Dont-Know-JS</a></p>\n<p><a href=\"https://egghead.io\">egghead.io</a>:lla on tarjolla runsaasti laadukkaita screencasteja Javascriptista, Reactista ym. kiinnostavasta. Valitettavasti materiaali on osittain maksullista.</p>\n</div>","frontmatter":{"title":"osa 1","subTitle":"Javascript","path":"/osa1/javascript","mainImage":{"publicURL":"/static/osa1-b7ac07cbe6df8ed745701fabe73af8ef.png"},"partColor":"green","part":1,"letter":"b"}}},"pageContext":{}}