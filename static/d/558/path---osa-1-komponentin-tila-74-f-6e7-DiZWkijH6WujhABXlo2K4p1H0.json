{"data":{"markdownRemark":{"html":"<div class=\"content\">\n<p>Palataan jälleen Reactin pariin.</p>\n<p>Sovelluksemme jäi seuraavaan tilaan</p>\n<pre><code class=\"language-react\">const Hello = (props) => {\n  return (\n    &#x3C;div>\n      &#x3C;p>Hello {props.name}, you are {props.age} years old&#x3C;/p>\n    &#x3C;/div>\n  )\n}\n\nconst App = () => {\n  const nimi = 'Pekka'\n  const ika = 10\n\n  return (\n    &#x3C;div>\n      &#x3C;h1>Greetings&#x3C;/h1>\n      &#x3C;Hello name=\"Arto\" age={26 + 10} />\n      &#x3C;Hello name={nimi} age={ika} />\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<h3>Komponenttien apufunktiot</h3>\n<p>Laajennetaan komponenttia <em>Hello</em> siten, että se antaa arvion tervehdittävän henkilön syntymävuodesta:</p>\n<pre><code class=\"language-js\">const Hello = (props) => {\n  const bornYear = () => {\n    const yearNow = new Date().getFullYear()\n    return yearNow - props.age\n  }\n\n  return (\n    &#x3C;div>\n      &#x3C;p>Hello {props.name}, you are {props.age} years old&#x3C;/p>\n      &#x3C;p>So you were probably born {bornYear()}&#x3C;/p>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Syntymävuoden arvauksen tekevä logiikka on erotettu omaksi funktiokseen, jota kutsutaan renderöinnin yhteydessä. </p>\n<p>Tervehdittävän henkilön ikää ei metodille tarvitse välittää parametrina, sillä funktio näkee sen sisältävälle komponentille välitettävät propsit.</p>\n<p>Teknisesti ajatellen syntymävuoden määrittelevä funktio on määritelty komponentin toiminnan määrittelevän funktion sisällä. Esim. Javalla ohjelmoitaessa metodien määrittely toisen metodin sisällä ei onnistu. Javascriptissa taas funktioiden sisällä määritellyt funktiot on hyvin yleisesti käytetty tekniikka.</p>\n<h3>Destrukturointi</h3>\n<p>Ennen kuin siirrymme eteenpäin, tarkastellaan erästä pientä, mutta käyttökelpoista ES6:n mukanaan tuomaa uutta piirrettä Javascriptissä, eli sijoittamisen yhteydessä tapahtuvaa <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\">destrukturointia</a>.</p>\n<p>Jouduimme äskeisessä koodissa viittaamaan propseina välitettyyn dataan hieman ikävästi muodossa <em>props.name</em> ja <em>props.age</em>. Näistä <em>props.age</em> pitää toistaa komponentissa kahteen kertaan.</p>\n<p>Koska <em>props</em> on nyt olio</p>\n<pre><code class=\"language-js\">props = {\n  name: 'Arto Hellas',\n  age: 35,\n}\n</code></pre>\n<p>voimme suoraviivaistaa komponenttia siten, että sijoitamme kenttien arvot muuttujiin <em>name</em> ja <em>age</em> jonka jälkeen niitä on mahdollista käyttää koodissa suoraan:</p>\n<pre><code class=\"language-react\">const Hello = (props) => {\n  const name = props.name\n  const age = props.age\n\n  const bornYear = () => new Date().getFullYear() - age\n\n  return (\n    &#x3C;div>\n      &#x3C;p>Hello {name}, you are {age} years old&#x3C;/p>\n      &#x3C;p>So you were probably born {bornYear()}&#x3C;/p>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Huomaa, että olemme myös hyödyntäneet nuolifunktion kompaktimpaa kirjoitustapaa metodin <em>bornYear</em> määrittelyssä. Kuten aiemmin totesimme, jos nuolifunktio koostuu ainoastaan yhdestä komennosta, ei funktion runkoa tarvitse kirjoittaa aaltosulkeiden sisään ja funktio palauttaa ainoan komentonsa arvon.</p>\n<p>Seuraavat ovat siis vaihtoehtoiset tavat määritellä sama funktio:</p>\n<pre><code class=\"language-js\">const bornYear = () => new Date().getFullYear() - age\n\nconst bornYear = () => {\n  return new Date().getFullYear() - age\n}\n</code></pre>\n<p>Destrukturointi tekee apumuuttujien määrittelyn vielä helpommaksi, sen avulla voimme \"kerätä\" olion oliomuuttujien arvot suoraan omiin yksittäisiin muuttujiin:</p>\n<pre><code class=\"language-react\">const Hello = (props) => {\n  const { name, age } = props\n  const bornYear = () => new Date().getFullYear() - age\n\n  return (\n    &#x3C;div>\n      &#x3C;p>Hello {name}, you are {props.age} years old&#x3C;/p>\n      &#x3C;p>So you were probably born {bornYear()}&#x3C;/p>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Eli koska</p>\n<pre><code class=\"language-js\">props = {\n  name: 'Arto Hellas',\n  age: 35,\n}\n</code></pre>\n<p>saa <code> const { name, age } = props</code> aikaan sen, että muuttuja <em>name</em> saa arvon 'Arto Hellas' ja muuttuja <em>age</em> arvon 35.</p>\n<p>Voimme viedä destrukturoinnin vielä askeleen verran pidemmälle</p>\n<pre><code class=\"language-js\">const Hello = ({ name, age }) => {\n  const bornYear = () => new Date().getFullYear() - age\n\n  return (\n    &#x3C;div>\n      &#x3C;p>Hello {name}, you are {age} years old&#x3C;/p>\n      &#x3C;p>So you were probably born {bornYear()}&#x3C;/p>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Destrukturointi tehdään nyt suodaan sijoittamalla komponentin saamat propsit muuttujiin <em>name</em> ja <em>age</em>. </p>\n<p>Eli sensijaan että props-olio otettaisiin vastaan muuttujaan <em>props</em> ja sen kentät sijoitettaisiin tämän jälkeen muuttujiin <em>name</em> ja <em>age</em></p>\n<pre><code class=\"language-react\">const Hello = (props) => {\n  const { name, age } = props\n</code></pre>\n<p>sijoitamme destrukturoinnin avulla propsin kentät suoraan muuttujiin kun määrittelemme komponettifunktion saaman parametrin:</p>\n<pre><code class=\"language-react\">const Hello = ({ name, age }) => {\n</code></pre>\n<h3>Sivun uudelleenrenderöinti</h3>\n<p>Toistaiseksi tekemämme sovellukset ovat olleet sellaisia, että kun niiden komponentit on kerran renderöity, niiden ulkoasua ei ole enää voinut muuttaa. Entä jos haluaisimme toteuttaa laskurin, jonka arvo kasvaa esim. ajan kuluessa tai nappien painallusten yhteydessä?</p>\n<p>Aloitetaan seuraavasta rungosta:</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  const {counter} = props\n  return (\n    &#x3C;div>{counter}&#x3C;/div>\n  )\n}\n\nlet counter = 1\n\nReactDOM.render(&#x3C;App counter={counter} />, document.getElementById('root'))\n</code></pre>\n<p>Sovelluksen juurikomponentille siis annetaan viite laskuriin. Juurikomponentti renderöi arvon ruudulle. Entä laskurin arvon muuttuessa? Jos lisäämme ohjelmaan esim. komennon</p>\n<pre><code class=\"language-react\">counter.value += 1\n</code></pre>\n<p>ei komponenttia kuitenkaan renderöidä uudelleen. Voimme saada komponentin uudelleenrenderöitymään kutsumalla uudelleen metodia <em>ReactDOM.render</em>, esim. seuraavasti</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  const { counter } = props\n  return (\n    &#x3C;div>{counter}&#x3C;/div>\n  )\n}\n\nlet counter = 1\n\nconst renderoi = () => {\n  ReactDOM.render(&#x3C;App counter={counter} />, document.getElementById('root'))\n}\n\nrenderoi()\ncounter += 1\nrenderoi()\ncounter += 1\nrenderoi()\n</code></pre>\n<p>Copypastea vähentämään on komponentin renderöinti kääritty funktioon <em>renderoi</em>.</p>\n<p>Nyt komponentti renderöityy kolme kertaa, saaden ensin arvon 1, sitten 2 ja lopulta 3. 1 ja 2 tosin ovat ruudulla niin vähän aikaa, että niitä ei ehdi havaita.</p>\n<p>Hieman mielenkiintoisempaan toiminnallisuuteen pääsemme tekemällä renderöinnin ja laskurin kasvatuksen toistuvasti sekunnin välein käyttäen <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval\">SetInterval</a>:</p>\n<pre><code class=\"language-js\">setInterval(() => {\n  renderoi()\n  counter += 1\n}, 1000)\n</code></pre>\n<p><em>ReactDOM.render</em>-metodin toistuva kutsuminen ei kuitenkaan ole suositeltu tapa päivittää komponentteja. Tutustutaan seuraavaksi järkevämpään tapaan.</p>\n<h3>Tilallinen komponentti</h3>\n<p>Tähänastiset komponenttimme ovat olleet siinä mielessä yksinkertaisia, että niillä ei ole ollut ollenkaan omaa tilaa, joka voisi muuttua komponentin elinaikana. </p>\n<p>Määritellään nyt sovelluksemme komonentille <em>App</em> tila Reactin <a href=\"https://reactjs.org/docs/hooks-state.html\">state hookin</a> avulla.</p>\n<p>Muutetaan ohjelmaa seuraavasti</p>\n<pre><code class=\"language-react\">import React, { useState } from 'react'\nimport ReactDOM from 'react-dom'\n\nconst App = (props) => {\n  const [ counter, setCounter ] = useState(0)\n\n  setTimeout(\n    () => setCounter(counter + 1),\n    1000\n  )\n\n  return (\n    &#x3C;div>{counter}&#x3C;/div>\n  )\n}\n\nReactDOM.render(&#x3C;App />, document.getElementById('root'))\n</code></pre>\n<p>Sovellus importaa nyt heti ensimmäisellä rivillä <em>useState</em>-funktion:</p>\n<pre><code class=\"language-react\">import React, { useState } from 'react'\n</code></pre>\n<p>Komponentin määrittelevä funktio alkaa metodikutsulla</p>\n<pre><code class=\"language-react\">const [ counter, setCounter ] = useState(0)\n</code></pre>\n<p>Kutsu saa aikaan sen, että komponentille luodaan tila, joka saa alkuarvokseen nollan. Metodi palauttaa taulukon, jolla on kaksi alkiota. Alkiot otetaan taulukon destrukturointisyntaksilla talteen muuttujiin <em>counter</em> ja <em>setCounter</em>.</p>\n<p>Muuttuja <em>counter</em> pitää sisällään tilan arvon joka on siis aluksi nolla. Muuttuja <em>setCounter</em> taas on viite funktioon, jonka avulla tilaa voidaan muuttaa.</p>\n<p>Sovellus määrittelee funktion <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout\">setTimeout</a> avulla, että tilan <em>counter</em> arvoa kasvatetaan yhdellä sekunnin päästä:</p>\n<pre><code class=\"language-react\">setTimeout(\n  () => setCounter(counter + 1),\n  1000\n)\n</code></pre>\n<p>Kun tilaa muuttavaa funktiota <em>setCounter</em> kutsutaan, renderöi React komponentin uudelleen, eli käytännössä suorittaa uudelleen komponentin määrittelevän koodin</p>\n<pre><code class=\"language-react\">(props) => {\n  const [ counter, setCounter ] = useState(0)\n\n  setTimeout(\n    () => setCounter(counter + 1),\n    1000\n  )\n\n  return (\n    &#x3C;div>{counter}&#x3C;/div>\n  )\n}\n</code></pre>\n<p>kun koodi suoritetaan toiseen kertaan, funktion <em>useState</em> kutsuminen palauttaa komponentin jo olemassaolevan tilan arvon, joka on nyt 1. Komponentin suoritus määrittelee jälleen laskuria kasvatettavaksi yhdellä sekunnin päästä ja renderöi ruudulle laskurin nykyisen arvon, joka on 1.</p>\n<p>Sekunnin päästä siis suoritetaan funktion <em>setTimeout</em> parametrina ollut koodi</p>\n<pre><code class=\"language-react\">() => setCounter(counter + 1)\n</code></pre>\n<p>ja koska muuttujan <em>counter</em> arvo on 1, on koodi oleellisesti sama kuin tilan <em>counter</em> arvoon 2 asettava</p>\n<pre><code class=\"language-react\">() => setCounter(2)\n</code></pre>\n<p>Ja tämä saa jälleen aikaan sen, että komponentti renderöidään uudelleen. Tilan arvo kasvaa sekunnin päästä yhdellä ja sama jatkuu niin kauan kun sovellus on toiminnassa.</p>\n<p>Jos komponentti ei renderöidy vaikka sen omasta mielestä pitäisi, tai se renderöityy \"väärään aikaan\", debuggaamista auttaa joskus komponentin määrittelevään kunktioon lisätty konsoliin tulostus. Esim. jos lisäämme koodiin seuraavan,</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  const [ counter, setCounter ] = useState(0)\n\n  setTimeout(\n    () => setCounter(counter + 1),\n    1000\n  )\n\n  console.log('renderöidään', counter)\n\n  return (\n    &#x3C;div>{counter}&#x3C;/div>\n  )\n}\n</code></pre>\n<p>on konsolista helppo seurata metodin <em>render</em> kutsuja:</p>\n<picture><img src=\"/static/720bca28a8631b8d57805a5beb00fe48/14be6/4a.png\" srcset=\"/static/720bca28a8631b8d57805a5beb00fe48/4cce7/4a.png 200w,\n/static/720bca28a8631b8d57805a5beb00fe48/bae5f/4a.png 400w,\n/static/720bca28a8631b8d57805a5beb00fe48/14be6/4a.png 800w,\n/static/720bca28a8631b8d57805a5beb00fe48/1b35a/4a.png 1200w,\n/static/720bca28a8631b8d57805a5beb00fe48/9ee03/4a.png 1600w,\n/static/720bca28a8631b8d57805a5beb00fe48/35b75/4a.png 1622w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<h3>Tapahtumankäsittely</h3>\n<p>Mainitsimme jo <a href=\"/osa0\">osassa 0</a> muutamaan kertaan <em>tapahtumankäsittelijät</em>, eli funktiot, jotka on rekisteröity kutsuttavaksi tiettyjen tapahtumien eli eventien yhteydessä. Esim. käyttäjän interaktio sivun elementtien kanssa aiheuttaa joukon erinäisiä tapahtumia.</p>\n<p>Muutetaan sovellusta siten, että laskurin kasvaminen tapahtuukin käyttäjän painaessa <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button\">button</a>-elementin avulla toteutettua nappia.</p>\n<p>Button-elementit tukevat mm. <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\">hiiritapahtumia</a> (mouse events), joista yleisin on <a href=\"https://developer.mozilla.org/en-US/docs/Web/Events/click\">click</a>.</p>\n<p>Reactissa funktion rekisteröiminen tapahtumankäsittelijäksi tapahtumalle <em>click</em> <a href=\"https://reactjs.org/docs/handling-events.html\">tapahtuu</a> seuraavasti:</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  const [ counter, setCounter ] = useState(0)\n\n  const handleClick = () => {  \n    console.log('klicked')\n  }\n\n  return (\n    &#x3C;div>\n      &#x3C;div>{counter}&#x3C;/div>\n      &#x3C;button onClick={handleClick}>\n        plus\n      &#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Eli laitetaan <em>button</em>:in onClick-attribuutin arvoksi aaltosulkeissa oleva viite koodissa määriteltyyn funktioon <em>handleClick</em>.</p>\n<p>Nyt jokainen napin <em>plus</em> painallus saa aikaan sen että funktiota <em>handleClick</em> kutsutaan, eli klikatessa konsoliin tulostuu <em>clicked</em>.</p>\n<p>Tapahtumankäsittelijäfunktio voidaan määritellä myös suoraan onClick-määrittelyn yhteydessä:</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  const [ counter, setCounter ] = useState(0)\n\n  return (\n    &#x3C;div>\n      &#x3C;div>{counter}&#x3C;/div>\n      &#x3C;button onClick={() => console.log('klicked')}>\n        plus\n      &#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Muuttamalla tapahtumankäsittelijä seuraavaan muotoon</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={() => setCounter(counter + 1)}>\n  plus\n&#x3C;/button>\n</code></pre>\n<p>saamme halutun toiminnallisuuden, eli tilan <em>counter</em> arvo kasvaa yhdellä <em>ja</em> komponentti renderöityy uudelleen.</p>\n<p>Lisätään sovellukseen myös nappi laskurin nollaamiseen:</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  const [ counter, setCounter ] = useState(0)\n\n  return (\n    &#x3C;div>\n      &#x3C;div>{counter}&#x3C;/div>\n      &#x3C;button onClick={() => setCounter(counter + 1)}>\n        plus\n      &#x3C;/button>\n      &#x3C;button onClick={() => setCounter(0)}>\n        zero\n      &#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Sovelluksemme on valmis!</p>\n<p>Tapahtumankäsittelijöiden määrittely suoraan JSX-templatejen sisällä ei useimmiten ole kovin viisasta. Eriytetään vielä nappien tapahtumankäsittelijät omiksi komponentin sisäisiksi apufunktioikseen:</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  const [ counter, setCounter ] = useState(0)\n\n  const increaseByOne = () => setCounter(counter + 1)\n  const setToZero = () => setCounter(0)\n\n  return (\n    &#x3C;div>\n      &#x3C;div>{counter}&#x3C;/div>\n      &#x3C;button onClick={increaseByOne}>\n        plus\n      &#x3C;/button>\n      &#x3C;button onClick={setToZero}>\n        zero\n      &#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<h3>Funktio joka palauttaa funktion</h3>\n<p>Metodit <em>increaseByOne</em> ja <em>setToZero</em> toimivat melkein samalla tavalla, ne asettavat uuden arvon laskurille. Tehdään koodiin yksittäinen funktio, joka sopii molempiin käyttötarkoituksiin:</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  const [ counter, setCounter ] = useState(0)\n\n  const setToValue = (value) => setCounter(value)\n\n  return (\n    &#x3C;div>\n      &#x3C;div>{counter}&#x3C;/div>\n      &#x3C;button onClick={setToValue(counter + 1)}>\n        plus\n      &#x3C;/button>\n      &#x3C;button onClick={setToValue(0)}>\n        zero\n      &#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Huomaamme kuitenkin että muutos hajottaa sovelluksemme täysin:</p>\n<picture><img src=\"/static/70105bcae7b1dfbe3fe71b0ee734ce44/14be6/5a.png\" srcset=\"/static/70105bcae7b1dfbe3fe71b0ee734ce44/4cce7/5a.png 200w,\n/static/70105bcae7b1dfbe3fe71b0ee734ce44/bae5f/5a.png 400w,\n/static/70105bcae7b1dfbe3fe71b0ee734ce44/14be6/5a.png 800w,\n/static/70105bcae7b1dfbe3fe71b0ee734ce44/1b35a/5a.png 1200w,\n/static/70105bcae7b1dfbe3fe71b0ee734ce44/9ee03/5a.png 1600w,\n/static/70105bcae7b1dfbe3fe71b0ee734ce44/9fb27/5a.png 1782w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Mistä on kyse? Tapahtumankäsittelijäksi on tarkoitus määritellä viite <em>funktioon</em>. Kun koodissa on</p>\n<pre><code class=\"language-react\">&#x3C;button onClick={setToValue(0)}>\n</code></pre>\n<p>tapahtumankäsittelijäksi tulee määriteltyä <em>funktiokutsu</em>. Sekin on monissa tilanteissa ok, mutta ei nyt, nimittäin kun React srenderöi metodin, se suorittaa kutsun <code>this.setToValue(0)</code>. Kutsu aiheuttaa komponentin tilan päivittävän funktion <em>setCounter</em> kutsumisen. Tämä taas aiheuttaa komponentin uudelleenrenderöitymisen. Ja sama toistuu uudelleen...</p>\n<p>Tilanteeseen on kaksi ratkaisua. Ratkaisuista yksinkertaisempi on muuttaa tapahtumankäsitteyä seuraavasti</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  const [ counter, setCounter ] = useState(0)\n\n  const setToValue = (value) => setCounter(value)\n\n  return (\n    &#x3C;div>\n      &#x3C;div>{counter}&#x3C;/div>\n      &#x3C;button onClick={() => setToValue(counter + 1)}>\n        plus\n      &#x3C;/button>\n      &#x3C;button onClick={() => setToValue(0)}>\n        zero\n      &#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>eli tapahtumankäsittelijäki on määritelty <em>funktio</em>, joka kutsuu funktiota <em>setToValue</em> sopivalla parametrilla:</p>\n<pre><code class=\"language-react\">&#x3C;button onClick={() => setToValue(counter + 1)}>\n</code></pre>\n<p>Toinen vaihtoehto on käyttää yleistä Javascriptin ja yleisemminkin funktionaalisen ohjelmoinnin kikkaa, eli määritellä <em>funktio joka palauttaa funktion</em>:</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  const [ counter, setCounter ] = useState(0)\n\n  const setToValue = (value) => {\n    return () => {\n      setCounter(value)\n    }\n  }\n\n  return (\n    &#x3C;div>\n      &#x3C;div>{counter}&#x3C;/div>\n      &#x3C;button onClick={setToValue(counter + 1)}>\n        plus\n      &#x3C;/button>\n      &#x3C;button onClick={setToValue(0)}>\n        zero\n      &#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Jos et ole aiemmin törmännyt tekniikkaan, siihen totutteluun voi mennä tovi.</p>\n<p>Olemme siis määritelleet tapahtumankäsittelijäfunktion <em>setToValue</em> seuraavasti:</p>\n<pre><code class=\"language-js\">const setToValue = (value) => {\n  return () => {\n    setCounter(value)\n  }\n}\n</code></pre>\n<p>Kun komponentissa määritellään tapahtumankäsittelijä kutsumalla <code>this.setToValue(0)</code> on lopputuloksena funktio</p>\n<pre><code class=\"language-js\">() => {\n  setCounter(0)\n}\n</code></pre>\n<p>eli juuri oikeanlainen tilan nollaamisen aiheuttava funktio!</p>\n<p>Plus-napin tapahtumankäsittelijä määritellään kutsumalla <code>setCounter(counter + 1)</code>. Kun komponentti renderöidään ensimmäisen kerran, <em>counter</em> on saanut alkuarvon 0, eli plus-napin tapahtumankäsittelijäksi tulee funktiokutsun <code>setCounter(1)</code> tulos, eli funktio</p>\n<pre><code class=\"language-js\">() => {\n  setCounter(1)\n}\n</code></pre>\n<p>Vastaavasti, kun laskurin tila on esim 41, tulee plus-napin tapahtumakuuntelijaksi</p>\n<pre><code class=\"language-js\">() => {\n  setCounter(42)\n}\n</code></pre>\n<p>Tarkastellaan vielä hieman metodia <em>asetaArvoon</em>:</p>\n<pre><code class=\"language-js\">const setToValue = (value) => {\n  return () => {\n    setCounter(value)\n  }\n}\n</code></pre>\n<p>Koska metodi itse sisältää ainoastaan yhden komennon, eli <em>returnin</em>, joka palauttaa funktion, voidaan hyödyntää nuolifunktion tiiviimpää muotoa:</p>\n<pre><code class=\"language-js\">const setToValue = (value) => \n  () => {\n    setCounter(value)\n  }\n</code></pre>\n<p>Usein tälläisissä tilanteissa kaikki kirjoitetaan samalle riville, jolloin tuloksena on \"kaksi nuolta sisältävä funktio\":</p>\n<pre><code class=\"language-js\">const setToValue = (value) => () => setCounter(value)\n</code></pre>\n<p>Kaksinuolisen funktion voi ajatella funktiona, jota lopullisen tuloksen saadakseen täytyy kutsua kaksi kertaa.</p>\n<p>Ensimmäisellä kutsulla \"konfiguroidaan\" varsinainen funktio, sijoittamalla osalle parametreista arvo. Eli kutsu <code>setToValue(5)</code> sitoo muuttujaan <em>value</em> arvon 5 ja funktiosta \"jää jäljelle\" seuraava funktio:</p>\n<pre><code class=\"language-js\">() => setCounter(5)\n</code></pre>\n<p>Tässä näytetty tapa soveltaa funktioita palauttavia funktioita on oleellisesti sama asia mistä funktionaalisessa ohjelmoinnissa käytetään termiä <a href=\"http://www.datchley.name/currying-vs-partial-application/\">currying</a>. Termi currying ei ole lähtöisin funktionaalisen ohjelmoinnin piiristä vaan sillä on juuret <a href=\"https://en.wikipedia.org/wiki/Currying\">syvällä matematiikassa</a>.</p>\n<p>Jo muutamaan kertaan mainittu termi <em>funktionaalinen ohjelmointi</em> ei ole välttämättä kaikille tässä vaiheessa tuttu. Asiaa avataan hiukan kurssin kuluessa, sillä React tukee ja osin edellyttää funktionaalisen tyylin käyttöä.</p>\n<p><strong>HUOM:</strong> muutos, missä korvasimme metodit <em>increaseByOne</em> ja <em>setToZero</em> metodilla <em>setToValue</em> ei välttämättä ole järkevä, sillä erikoistuneemmat metodit ovat paremmin nimettyjä. Teimme muutoksen oikeastaan ainoastaan demonstroidaksemme <em>currying</em>-tekniikan soveltamista.</p>\n<h3>Tilan vieminen alikomponenttiin</h3>\n<p>Reactissa suositaan pieniä komponentteja, joita on mahdollista uusiokäyttää monessa osissa sovellusta ja jopa useissa eri sovelluksissa. Refaktoroidaan koodiamme vielä siten, että yhden komponentin sijaan koostamme laskurin näytöstä ja kahdesta painikkeesta.</p>\n<p>Tehdään ensin näytöstä vastaava komponentti <em>Display</em>.</p>\n<p>Reactissa parhaana käytänteenä on sijoittaa tila <a href=\"https://reactjs.org/docs/lifting-state-up.html\">mahdollisimman ylös</a> komponenttihierarkiassa, mielellään sovelluksen juurikomponenttiin.</p>\n<p>Jätetään sovelluksen tila, eli laskimen arvo komponenttiin <em>App</em> ja välitetään tila <em>props</em>:ien avulla komponentille <em>Display</em>:</p>\n<pre><code class=\"language-react\">const Display = (props) => {\n  return (\n    &#x3C;div>{props.counter}&#x3C;/div>\n  )\n}\n</code></pre>\n<p>Voimme hyödyntää aiemmin mainittua <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\">destrukturointia</a> myös metodien parametreissa. Eli koska olemme kiinnostuneita <em>props</em>:in kentästä <em>counter</em>, on edellinen mahdollista yksinkertaistaa seuraavaan muotoon:</p>\n<pre><code class=\"language-react\">const Display = ({ counter }) => {\n  return (\n    &#x3C;div>{counter}&#x3C;/div>\n  )\n}\n</code></pre>\n<p>Koska komponentin määrittelevä metodi ei sisällä muuta kuin returnin, voimme ilmaista sen hyödyntäen nuolifunktioiden tiiviimpää ilmaisumuotoa</p>\n<pre><code class=\"language-react\">const Display = ({ counter }) => &#x3C;div>{counter}&#x3C;/div>\n</code></pre>\n<p>Komponentin käyttö on suoraviivaista, riittää että sille välitetään laskurin tila eli <em>counter</em>:</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  const [ counter, setCounter ] = useState(0)\n  // ...\n\n  return (\n    &#x3C;div>\n      &#x3C;Display counter={counter}/>\n      &#x3C;button onClick={setToValue(counter + 1)}>\n        plus\n      &#x3C;/button>\n      &#x3C;button onClick={setToValue(0)}>\n        zero\n      &#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Kaikki toimii edelleen. Kun nappeja painetaan ja <em>App</em> renderöityy uudelleen, renderöityvät myös kaikki sen alikomponentit, siis myös <em>Display</em> automaattisesti uudelleen.</p>\n<p>Tehdään seuraavaksi napeille tarkoitettu komponentti <em>Button</em>. Napille on välitettävä propsien avulla tapahtumankäsittelijä sekä napin teksti:</p>\n<pre><code class=\"language-react\">const Button = (props) => (\n  &#x3C;button onClick={props.handleClick}>\n    {props.text}\n  &#x3C;/button>\n)\n</code></pre>\n<p>ja hyödynnetään taas destrukturointia ottamaan <em>props</em>:in tarpeelliset kentät suoraan:</p>\n<pre><code class=\"language-react\">const Button = ({ handleClick, text }) => (\n  &#x3C;button onClick={handleClick}>\n    {text}\n  &#x3C;/button>\n)\n</code></pre>\n<p>Komponentti <em>App</em> muuttuu nyt muotoon:</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  const [ counter, setCounter ] = useState(0)\n\n  const setToValue = (value) => {\n    return () => {\n      setCounter(value)\n    }\n  }\n\n  return (\n    &#x3C;div>\n      &#x3C;Display counter={counter}/>\n      &#x3C;Button\n        handleClick={setToValue(counter + 1)}\n        text='plus'\n      /> \n      &#x3C;Button\n        handleClick={setToValue(0)}\n        text='zero'\n      />     \n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Koska meillä on nyt uudelleenkäytettävä nappi, sovellukselle on lisätty uutena toiminnallisuutena nappi, jolla laskurin arvoa voi vähentää.</p>\n<p>Tapahtumankäsittelijä välitetään napeille propsin <em>handleClick</em> välityksellä. Propsin nimellä ei ole sinänsä merkitystä, mutta valinta ei ollut täysin sattumanvarainen, esim. Reactin <a href=\"https://reactjs.org/tutorial/tutorial.html\">tutoriaali</a> suosittelee tätä konventiota.</p>\n</div>","frontmatter":{"title":"osa 1","subTitle":"Komonentin tila ja tapahtumankäsittely","path":"/osa1/komponentin_tila","mainImage":{"publicURL":"/static/osa1-b7ac07cbe6df8ed745701fabe73af8ef.png"},"partColor":"green","part":1,"letter":"c"}}},"pageContext":{}}