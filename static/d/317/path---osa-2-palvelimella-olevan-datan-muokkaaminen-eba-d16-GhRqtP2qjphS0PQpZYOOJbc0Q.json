{"data":{"markdownRemark":{"html":"<div class=\"content\">\n<p>Kun sovelluksella luodaan uusia muistiinpanoja, täytyy ne luonnollisesti tallentaa palvelimelle. <a href=\"https://github.com/typicode/json-server\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">json-server</a> mainitsee dokumentaatiossaan olevansa ns. REST- tai RESTful-API</p>\n<blockquote>\n<p>Get a full fake REST API with zero coding in less than 30 seconds (seriously)</p>\n</blockquote>\n<p>Ihan alkuperäisen <a href=\"https://en.wikipedia.org/wiki/Representational_state_transfer\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">määritelmän</a> mukainen RESTful API json-server ei ole, mutta ei ole kovin moni muukaan itseään REST:iksi kutsuva rajapinta.</p>\n<p>Tutustumme REST:iin tarkemmin kurssin <a href=\"/osa3\">seuraavassa osassa</a>, mutta jo nyt on tärkeä ymmärtää minkälaista <a href=\"https://en.wikipedia.org/wiki/Representational_state_transfer#Applied_to_Web_services\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">konventiota</a> json-server ja yleisemminkin REST API:t käyttävät <a href=\"https://github.com/typicode/json-server#routes\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">reittien</a>, eli URL:ien ja käytettävien HTTP-pyyntöjen tyyppien suhteen.</p>\n<h3>REST</h3>\n<p>REST:issä yksittäisiä asioita esim. meidän tapauksessamme muistiinpanoja kutsutaan <i>resursseiksi</i>. Jokaisella resurssilla on yksilöivä osoite eli URL. json-serverin noudattaman yleisen konvention mukaan yksittäistä muistiinpanoa kuvaavan resurssin URL on muotoa <em>notes/3</em>, missä 3 on resurssin tunniste. Osoite <em>notes</em> taas vastaa kaikkien yksittäisten muistiinpanojen kokoelmaa.</p>\n<p>Resursseja haetaan palvelimelta HTTP GET -pyynnöillä. Esim. HTTP GET osoitteeseen <em>notes/3</em> palauttaa muistiinpanon, jonka id-kentän arvo on 3. Kun taas HTTP GET -pyyntö osoitteeseen <em>notes</em> palauttaa kaikki muistiinpanot.</p>\n<p>Uuden muistiinpanoa vastaavan resurssin luominen tapahtuu json-serverin noudattamassa REST-konventiossa tekemällä HTTP POST -pyyntö, joka kohdistuu myös samaan osoitteeseen <em>notes</em>. Pyynnön mukana sen runkona eli <i>bodynä</i> lähetetään luotavan muistiinpanon tiedot.</p>\n<p>json-server vaatii, että tiedot lähetetään JSON-muodossa, eli käytännössä sopivasti muotoiltuna merkkijonona ja asettamalla headerille <em>Content-Type</em> arvo <em>application/json</em>.</p>\n<h3>Datan lähetys palvelimelle</h3>\n<p>Muutetaan nyt uuden muistiinpanon lisäämisestä huolehtivaa tapahtumankäsittelijää seuraavasti:</p>\n<pre><code class=\"language-js\">addNote = event => {\n  event.preventDefault()\n  const noteObject = {\n    content: this.state.newNote,\n    date: new Date(),\n    important: Math.random() > 0.5,\n  }\n\n// highlight-start\n  axios.post('http://localhost:3001/notes', noteObject).then(response => {\n    console.log(response)\n  })\n// highlight-end\n}\n</code></pre>\n<p>eli luodaan muistiinpanoa vastaava olio, ei kuitenkaan lisätä sille kenttää <em>id</em>, sillä on parempi jättää id:n generointi palvelimen vastuulle!</p>\n<p>Olio lähetetään palvelimelle käyttämällä axiosin metodia <code>post</code>. Rekisteröity tapahtumankäsittelijä tulostaa konsoliin palvelimen vastauksen.</p>\n<p>Kun nyt kokeillaan luoda uusi muistiinpano, konsoliin tulostus näyttää seuraavalta:</p>\n<p><img src=\"../images/2/20b.png\"></p>\n<p>Uusi muistiinpano on siis <em>response</em>-olion kentän <em>data</em> arvona. Palvelin on lisännyt muistiinpanolle tunnisteen, eli <em>id</em>-kentän.</p>\n<p>Joskus on hyödyllistä tarkastella HTTP-pyyntöjä <a href=\"/osa0#http-get\">osan 0 alussa</a> paljon käytetyn konsolin <i>Network</i>-välilehden kautta:</p>\n<p><img src=\"../images/2/21b.png\"></p>\n<p>Voimme esim. tarkastaa onko POST-pyynnön mukana menevä data juuri se mitä oletimme, onko headerit asetettu oikein ym.</p>\n<p>Koska POST-pyynnössä lähettämämme data oli Javascript-olio, osasi axios automaattisesti asettaa pyynnön <em>content-type</em> headerille oikean arvon eli <em>application/json</em>.</p>\n<p>Uusi muistiinpano ei vielä renderöidy ruudulle, sillä emme aseta komponentille <em>App</em> uutta tilaa muistiinpanon luomisen yhteydessä. Viimeistellään sovellus vielä tältä osin:</p>\n<pre><code class=\"language-js\">addNote = event => {\n  event.preventDefault()\n  const noteObject = {\n    content: this.state.newNote,\n    date: new Date(),\n    important: Math.random() > 0.5,\n  }\n\n  axios.post('http://localhost:3001/notes', noteObject).then(response => {\n    // highlight-start\n    setNotes(notes.concat(response.data))\n    setNewNote('')\n    // highlight-end\n  })\n}\n</code></pre>\n<p>Palvelimen palauttama uusi muistiinpano siis lisätään tuttuun tapaan funktiolla <code>setNotes</code> tilassa olevien muiden muistiinpanojen joukkoon (kannattaa <a href=\"/osa1#taulukon-k%C3%A4sittely%C3%A4\">muistaa tärkeä detalji</a> siitä, että metodi <code>concat</code> ei muuta komponentin alkuperäistä tilaa, vaan luo uuden taulukon) ja tyhjennetään lomakkeen teksti. </p>\n<p>Kun palvelimella oleva data alkaa vaikuttaa web-sovelluksen toimintalogiikkaan, tulee sovelluskehitykseen heti iso joukko uusia haasteita, joita tuo mukanaan mm. kommunikoinnin asynkronisuus. Debuggaamiseenkin tarvitaan uusia strategiota, debug-printtaukset ym. muuttuvat vain tärkeämmäksi, myös Javascriptin runtimen periaatteita ja React-komponenttien toimintaa on pakko tuntea riittävällä tasolla, arvaileminen ei riitä.</p>\n<p>Palvelimen tilaa kannattaa tarkastella myös suoraan, esim. selaimella:</p>\n<p><img src=\"../images/2/22b.png\"></p>\n<p>näin on mahdollista varmistua, mm. siirtyykö kaikki oletettu data palvelimelle.</p>\n<p>Kurssin seuraavassa osassa alamme toteuttaa itse myös palvelimella olevan sovelluslogiikan, tutustumme silloin tarkemmin palvelimen debuggausta auttaviin työkaluihin, mm. <a href=\"https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">postmaniin</a>. Tässä vaiheessa json-server-palvelimen tilan tarkkailuun riittänee selain.</p>\n<blockquote>\n<p><strong>HUOM:</strong> sovelluksen nykyisessä versiossa selain lisää uudelle muistiinpanolle sen luomishetkeä kuvaavan kentän. Koska koneen oma kello voi näyttää periaatteessa mitä sattuu, on aikaleimojen generointi todellisuudessa viisaampaa hoitaa palvelimella ja tulemmekin tekemään tämän muutoksen kurssin seuraavassa osassa.</p>\n</blockquote>\n<p>Sovelluksen tämän hetkinen koodi on kokonaisuudessaan <a href=\"https://github.com/FullStack-HY/part2-notes/tree/part2-5\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">githubissa</a>, branchissa <i>part2-5</i>.</p>\n<h3>Muistiinpanon tärkeyden muutos</h3>\n<p>Lisätään muistiinpanojen yhteyteen painike, millä niiden tärkeyttä voi muuttaa.</p>\n<p>Muistiinpanon määrittelevän komponentin muutos on seuraavat:</p>\n<pre><code class=\"language-js\">const Note = ({ note, toggleImportance }) => {\n  const label = note.important ? 'make not important' : 'make important'\n\n  return (\n    &#x3C;li>{note.content} &#x3C;button onClick={toggleImportance}>{label}&#x3C;/button>&#x3C;/li>\n  )\n}\n</code></pre>\n<p>Komponentissa on nappi, jolle on rekisteröity klikkaustapahtuman käsittelijäksi propsien avulla välitetty funktio <code>toggleImportance</code>.</p>\n<p>Komponentti <code>App</code> määrittelee tapahtumankäsittelijän <code>toggleImportanceOf</code> ja välittää sen jokaiselle <code>Note</code>-komponentille:</p>\n<pre><code class=\"language-js\">const App = () => {\n  const [notes, setNotes] = useState([]) \n  const [newNote, setNewNote] = useState('')\n  const [showAll, setShowAll] = useState(true)\n\n  // ...\n\n  // highlight-start\n  const toggleImportanceOf = id => {\n    console.log('importance of ' + id + ' needs to be toggled')\n  }\n  // highlight-end\n\n  const rows = () => notesToShow.map(note =>\n    &#x3C;Note\n      key={note.id}\n      note={note}\n      toggleImportance={() => toggleImportanceOf(note.id)} // highlight-line\n    />\n  )\n\n  return (\n    // ...\n  )\n}\n</code></pre>\n<p>Huomaa, että jokaisen muistiinpanon tapahtumankäsittelijäksi tulee nyt <i>yksilöllinen</i> funktio, sillä kunkin muistiinpanin <code>id</code> on uniikki.</p>\n<p>Esim. jos <code>node.id</code> on 3, tulee tapahtumankäsittelijäksi <em>this.toggleImportance(note.id)</em> eli käytännössä:</p>\n<pre><code class=\"language-js\">() => { console.log('importance of 3 needs to be toggled') }\n</code></pre>\n<p>Pieni huomio tähän väliin. Tapahtumankäsittelijän koodin tulostuksessa muodostetaan tulostettava merkkijono Javan tyyliin plussaamalla stringejä:</p>\n<pre><code class=\"language-js\">console.log('importance of ' + id + ' needs to be toggled')\n</code></pre>\n<p>ES6:n <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">template string</a> -ominaisuuden ansiosta Javascriptissa vastaavat merkkijonot voidaan kirjottaa hieman mukavammin:</p>\n<pre><code class=\"language-js\">console.log(`importance of ${id} needs to be toggled`)\n</code></pre>\n<p>Merkkijonon sisälle voi nyt määritellä \"dollari-aaltosulku\"-syntaksilla kohtia, minkä sisälle evaluoidaan javascript-lausekkeita, esim. muuttujan arvo. Huomaa, että template stringien hipsutyyppi poikkeaa Javascriptin normaaleista merkkijonojen käyttämistä hipsuista.</p>\n<p>Yksittäistä json-serverillä olevaa muistiinpanoa voi muuttaa kahdella tavalla, joko <i>korvaamalla</i> sen tekemällä HTTP PUT -pyyntö muistiinpanon yksilöivään osoitteeseen tai muuttamalla ainoastaan joidenkin muistiinpanon kenttien arvoja HTTP PATCH -pyynnöllä.</p>\n<p>Korvaamme nyt muistiinpanon kokonaan, sillä samalla tulee esille muutama tärkeä React:iin ja Javascriptiin liittyvä seikka.</p>\n<p>Funktio on seuraavassa:</p>\n<pre><code class=\"language-js\">const toggleImportanceOf = id => {\n  const url = `http://localhost:3001/notes/${id}`\n  const note = notes.find(n => n.id === id)\n  const changedNote = { ...note, important: !note.important }\n\n  axios.put(url, changedNote).then(response => {\n    setNotes(notes.map(note => note.id !== id ? note : response.data))\n  })\n}\n</code></pre>\n<p>Melkein jokaiselle riville sisältyy tärkeitä yksityiskohtia. Ensimmäinen rivi määrittelee jokaiselle muistiinpanolle id-kenttään perustuvan yksilöivän url:in.</p>\n<p>Taulukon metodilla <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">find</a> etsitään muutettava muistiinpano ja talletetaan muuttujaan <em>note</em> viite siihen.</p>\n<p>Sen jälkeen luodaan <i>uusi olio</i>, jonka sisältö on sama kuin vanhan olion sisältö poislukien kenttä important. Luominen näyttää hieman erikoiselta:</p>\n<pre><code class=\"language-js\">const changedNote = { ...note, important: !note.important }\n</code></pre>\n<p>Kyseessä on vielä standardoimattoman <a href=\"https://github.com/tc39/proposal-object-rest-spread\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">object spread</a> -operaation soveltaminen.</p>\n<p>Käytännössä <code>{ ... note}</code> luo olion, jolla on kenttinään kopiot olion <em>note</em> kenttien arvoista. Kun aaltosulkeisiin lisätään asioita, esim. <code>{ ...note, important: true }</code>, tulee uuden olion kenttä <em>important</em> saamaan arvon <em>true</em>. Eli esimerkissämme <code>important</code> saa uudessa oliossa vanhan arvonsa käänteisarvon.</p>\n<p>Uusi olio olisi voitu luoda myös vanhemmalla komennolla <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Object.assign</a></p>\n<pre><code class=\"language-js\">const changedNote = Object.assign({}, note, {important: !note.important} }\n</code></pre>\n<p>Object spread -syntaksi on kuitenkin yleisesti käytössä Reactissa, joten mekin käytämme sitä.</p>\n<p>Pari huomioita. Miksi teimme muutettavasta oliosta kopion vaikka myös seuraava koodi näyttää toimivan:</p>\n<pre><code class=\"language-js\">const note = notes.find(n => n.id === id)\nnote.important = !note.important\n\naxios.put(url, note).then(response => {\n</code></pre>\n<p>Näin ei ole suositetavaa tehdä, sillä muuttuja <code>note</code> on viite komponentin tilassa, eli <code>notes</code>-taulukossa olevaan olioon, ja kuten muistamme tilaa ei Reactissa saa muuttaa suoraan!</p>\n<p>Kannattaa myös huomata, että uusi olio <em>changedNote</em> on ainoastaan ns. <a href=\"https://en.wikipedia.org/wiki/Object_copying#Shallow_copy\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">shallow copy</a>, eli uuden olion kenttien arvoina on vanhan olion kenttien arvot. Jos vanhan olion kentät olisivat itsessään olioita, viittaisivat uuden olion kentät samoihin olioihin.</p>\n<p>Uusi muistiinpano lähetetään sitten PUT-pyynnön mukana palvelimelle, jossa se korvaa aiemman muistiinpanon.</p>\n<p>Takaisinkutsufunktiossa asetetaan komponentin <code>App</code> tilaan <code>notes</code>  kaikki vanhat muistiinpanot paitsi muuttuneen, josta tilaan asetetaan palvelimen palauttama versio:</p>\n<pre><code class=\"language-js\">axios.put(url, changedNote).then(response => {\n  setNotes(notes.map(note => note.id !== id ? note : response.data))\n})\n</code></pre>\n<p>Tämä saadaan aikaan metodilla <code>map</code> joka siis luo uuden taulukon vanhan taulukon perusteella. Jokainen uuden taulukon alkio luodaan ehdollisesti siten, että jos ehto <code>note.id !== id</code> on tosi, otetaan uuteen taulukkoon suoraan vanhan taulukon kyseinen alkio. Jos ehto on epätosi, eli kyseessä on muutettu muistiinpano, otetaan uuteen taulukkoon palvelimen palauttama olio.</p>\n<p>Käytetty <code>map</code>-kikka saattaa olla aluksi hieman hämmentävä. Asiaa kannattaakin miettiä tovi. Tapaa tullaan käyttämään kurssilla vielä kymmeniä kertoja.</p>\n<h3>Palvelimen kanssa tapahtuvan kommunikoinnin eristäminen omaan moduuliin</h3>\n<p><code>App</code>-komponentti alkaa kasvaa uhkaavasti kun myös palvelimen kanssa kommunikointi tapahtuu komponentissa. <a href=\"https://en.wikipedia.org/wiki/Single_responsibility_principle\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Single responsibility</a> -periaatteen hengessä kommunikointi onkin viisainta eristää omaan <a href=\"#refaktorointia---moduulit\">moduuliinsa</a>.</p>\n<p>Luodaan hakemisto <em>src/services</em> ja sinne tiedosto <em>notes.js</em>:</p>\n<pre><code class=\"language-js\">import axios from 'axios'\nconst baseUrl = 'http://localhost:3001/notes'\n\nconst getAll = () => {\n  return axios.get(baseUrl)\n}\n\nconst create = newObject => {\n  return axios.post(baseUrl, newObject)\n}\n\nconst update = (id, newObject) => {\n  return axios.put(`${baseUrl}/${id}`, newObject)\n}\n\nexport default { \n  getAll: getAll, \n  create: create, \n  update: update \n}\n</code></pre>\n<p>Moduuli palauttaa nyt olion, jonka kenttinä (<code>getAll</code>, <code>create</code> ja <code>update</code>) on kolme muistiinpanojen käsittelyä hoitavaa funktiota. Funktiot palauttavat suoraan axiosin metodien palauttaman promisen.</p>\n<p>Komponentti <code>App</code> saa moduulin käyttöön <code>import</code>-lauseella</p>\n<pre><code class=\"language-js\">import noteService from './services/notes' // highlight-line\n\nconst App = () => {\n</code></pre>\n<p>moduulin funktioita käytetään importatun muuttujan <em>noteService</em> kautta seuraavasti:</p>\n<pre><code class=\"language-js\">const App = () => {\n  // ...\n\n  useEffect(() => {\n    // highlight-start\n    noteService\n      .getAll().then(response => {\n        setNotes(response.data)\n      })\n    // highlight-end\n  }, [])\n\n  const toggleImportanceOf = id => {\n    const note = notes.find(n => n.id === id)\n    const changedNote = { ...note, important: !note.important }\n\n    // highlight-start\n    noteService\n      .update(changedNote).then(response => {\n        setNotes(notes.map(note => note.id !== id ? note : response.data))\n      })\n    // highlight-end\n  }\n\n  const addNote = (event) => {\n    event.preventDefault()\n    const noteObject = {\n      content: newNote,\n      date: new Date().toISOString(),\n      important: Math.random() > 0.5\n    }\n\n// highlight-start\n    noteService\n      .create(noteObject).then(response => {\n        setNotes(notes.concat(response.data))\n        setNewNote('')\n      })\n// highlight-end\n  }\n\n  // ...\n}\n\nexport default App\n</code></pre>\n<p>Voisimme viedä ratkaisua vielä askeleen pidemmälle, sillä käyttäessään moduulin funktioita komponentti <em>App</em> saa olion, joka sisältää koko HTTP-pyynnön vastauksen:</p>\n<pre><code class=\"language-js\">noteService\n  .getAll().then(response => {\n    setNotes(response.data)\n  })\n</code></pre>\n<p>Eli asia mistä <code>App</code> on kiinnostunut on parametrin kentässä <code>response.data</code>.</p>\n<p>Moduulia olisi miellyttävämpi käyttää, jos se HTTP-pyynnön vastauksen sijaan palauttaisi suoraan muistiinpanot sisältävän taulukon. Tällöin moduulin käyttö näyttäisi seuraavalta</p>\n<pre><code class=\"language-js\">noteService\n  .getAll().then(initialNotes => {\n    setNotes(initialNotes)\n  })\n</code></pre>\n<p>Tämä onnistuu muuttamalla moduulin koodia seuraavasti (koodiin jää ikävästi copy-pastea, emme kuitenkaan nyt välitä siitä):</p>\n<pre><code class=\"language-js\">import axios from 'axios'\nconst baseUrl = 'http://localhost:3001/notes'\n\nconst getAll = () => {\n  const request = axios.get(baseUrl)\n  return request.then(response => response.data)\n}\n\nconst create = newObject => {\n  const request = axios.post(baseUrl, newObject)\n  return request.then(response => response.data)\n}\n\nconst update = (id, newObject) => {\n  const request = axios.put(`${baseUrl}/${id}`, newObject)\n  return request.then(response => response.data)\n}\n\nexport default { \n  getAll: getAll, \n  create: create, \n  update: update \n}\n</code></pre>\n<p>eli enää ei palautetakaan suoraan axiosin palauttamaa promisea, vaan otetaan promise ensin muuttujaan <code>request</code> ja kutsutaan sille metodia <code>then</code>:</p>\n<pre><code class=\"language-js\">const getAll = () => {\n  const request = axios.get(baseUrl)\n  return request.then(response => response.data)\n}\n</code></pre>\n<p>Täydellisessä muodossa kirjoitettuna viimeinen rivi olisi:</p>\n<pre><code class=\"language-js\">const getAll = () => {\n  const request = axios.get(baseUrl)\n  return request.then(response => {\n    return response.data\n  })\n}\n</code></pre>\n<p>Myös nyt funktio <code>getAll</code>  palauttaa promisen, sillä promisen metodi <code>then</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">palauttaa promisen</a>.</p>\n<p>Koska <code>then</code>:in parametri palauttaa suoraan arvon <code>response.data</code>, on funktion <code>getAll</code> palauttama promise sellainen, että jos HTTP-kutsu onnistuu, antaa promise takaisinkutsulleen HTTP-pyynnön mukana olleen datan, eli se toimii juuri niin kuin haluamme.</p>\n<p>Moduulin muutoksen jälkeen täytyy komponentti <code>App</code> muokata <code>noteService</code>:n metodien takaisinkutsujen osalta ottamaan huomioon, että ne palauttavat datan suoraan:</p>\n<pre><code class=\"language-js\">const App = () => {\n  // ...\n\n  useEffect(() => {\n    noteService\n      // highlight-start\n      .getAll().then(initialNotes => {\n        setNotes(initialNotes)\n        // highlight-end\n      })\n  }, [])\n\n  const toggleImportanceOf = id => {\n    const note = notes.find(n => n.id === id)\n    const changedNote = { ...note, important: !note.important }\n\n    noteService\n      // highlight-start\n      .update(changedNote).then(returnedNote => {\n        setNotes(notes.map(note => note.id !== id ? note : returnedNote))\n      // highlight-end\n      })\n  }\n\n  const addNote = (event) => {\n    event.preventDefault()\n    const noteObject = {\n      content: newNote,\n      date: new Date().toISOString(),\n      important: Math.random() > 0.5\n    }\n\n    noteService\n    // highlight-start\n      .create(noteObject).then(returnedNote => {\n        setNotes(notes.concat(returnedNote))\n        // highlight-end\n        setNewNote('')\n      })\n  }\n\n  // ...\n}\n</code></pre>\n<p>Tämä kaikki on hieman monimutkaista ja asian selittäminen varmaan vaan vaikeuttaa sen ymmärtämistä. Internetistä löytyy paljon vaihtelevatasoista materiaalia aiheesta, esim. <a href=\"https://javascript.info/promise-chaining\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">tämä</a>.</p>\n<p><a href=\"https://github.com/getify/You-Dont-Know-JS\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">You do not know JS</a> sarjan kirja \"Async and performance\" selittää asian <a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">hyvin</a> mutta tarvitsee selitykseen kohtuullisen määrän sivuja.</p>\n<p>Promisejen ymmärtäminen on erittäin keskeistä modernissa Javascript-sovelluskehityksessä, joten asiaan kannattaa uhrata kohtuullisessa määrin aikaa.</p>\n<h3>Kehittyneempi tapa olioliteraalien kirjoittamiseen</h3>\n<p>Muistiinpanopalvelut määrittelevä moduuli siis eksporttaa olion, jonka kenttinä <code>getAll</code>, <code>create</code> ja <code>update</code> ovat muistiinpanojen käsittelyyn tarkoitetut funktiot. </p>\n<p>Moduulin määrittelu tapahtui seuraavasti:</p>\n<pre><code class=\"language-js\">import axios from 'axios'\nconst baseUrl = 'http://localhost:3001/notes'\n\nconst getAll = () => {\n  const request = axios.get(baseUrl)\n  return request.then(response => response.data)\n}\n\nconst create = newObject => {\n  const request = axios.post(baseUrl, newObject)\n  return request.then(response => response.data)\n}\n\nconst update = (id, newObject) => {\n  const request = axios.put(`${baseUrl}/${id}`, newObject)\n  return request.then(response => response.data)\n}\n\nexport default { \n  getAll: getAll, \n  create: create, \n  update: update \n}\n</code></pre>\n<p>Exportattava asia on siis seuraava, hieman erikoiselta näyttävä olio:</p>\n<pre><code class=\"language-js\">{ \n  getAll: getAll, \n  create: create, \n  update: update \n}\n</code></pre>\n<p>Olion määrittelyssä vasemmalla puolella kaksoispistettä olevat nimet tarkoittavat eksportoitavan olion kenttiä, kun taas oikealla puolella olevat nimet ovat moduulin sisällä määriteltyjä muuttujia. </p>\n<p>Koska olion kenttien nimet ovat samat kuin niiden arvon määrittelevien muuttujien nimet, voidaan olion määrittely kirjoittaa tiivimmässä muodossa:</p>\n<pre><code class=\"language-js\">{ \n  getAll, \n  create, \n  update \n}\n</code></pre>\n<p>Eli moduulin määrittely yksinkertaisuu seuraavaan muotoon </p>\n<pre><code class=\"language-js\">import axios from 'axios'\nconst baseUrl = 'http://localhost:3001/notes'\n\nconst getAll = () => {\n  const request = axios.get(baseUrl)\n  return request.then(response => response.data)\n}\n\nconst create = newObject => {\n  const request = axios.post(baseUrl, newObject)\n  return request.then(response => response.data)\n}\n\nconst update = (id, newObject) => {\n  const request = axios.put(`${baseUrl}/${id}`, newObject)\n  return request.then(response => response.data)\n}\n\nexport default { getAll, create, update } // highlight-line\n</code></pre>\n<p>Tässä tiiviimmässä olioiden määrittelytavassa hyödynnetään ES6:n myötä Javascriptiin  tullutta <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Property_definitions\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">uusi ominaisuutta</a>, joka mahdollistaa hieman tiiviimmän tavan muuttujien avulla tapahtuvaan olioiden määrittelyyn.</p>\n<p>Havainnollistaaksemme asiaa tarkastellaan tilannetta, jossa meillä on muuttujissa arvoja</p>\n<pre><code class=\"language-js\">const name = 'Leevi'\nconst age = 0\n</code></pre>\n<p>Vanhassa Javascriptissä olio täytyi määritellä seuraavaan tyyliin</p>\n<pre><code class=\"language-js\">const person = {\n  name: name,\n  age: age\n}\n</code></pre>\n<p>koska muuttujien ja luotavan olion kenttien nimi nyt on sama, riittää ES6:ssa kirjoittaa:</p>\n<pre><code class=\"language-js\">const person = { name, age }\n</code></pre>\n<p>lopputulos molemmissa on täsmälleen sama, eli ne luovat olion jonka kentän <code>name</code> arvo on <i>Leevi</i> ja kentän <code>age</code> arvo <i>0</i>.</p>\n<h3>Promise ja virheet</h3>\n<p>Jos sovelluksemme mahdollistaisi muistiinpanojen poistamisen, voisi syntyä tilanne, missä käyttäjä yrittää muuttaa sellaisen muistiinpanon tärkeyttä, joka on jo poistettu järjestelmästä.</p>\n<p>Simuloidaan tälläistä tilannetta \"kovakoodaamalla\" noteServiceen funktioon <code>getAll</code> muistiinpano, jota ei ole todellisuudessa (eli palvelimella) olemassa:</p>\n<pre><code class=\"language-js\">const getAll = () => {\n  const request = axios.get(baseUrl)\n  const nonExisting = {\n    id: 10000,\n    content: 'Tätä muistiinpanoa ei ole palvelimelta',\n    date: '2017-12-10T17:30:31.098Z',\n    important: true,\n  }\n  return request.then(response => response.data.concat(nonExisting))\n}\n</code></pre>\n<p>Kun valemuistiinpanon tärkeyttä yritetään muuttaa, konsoliin tulee virheilmoitus, joka kertoo palvelimen vastanneen urliin <em>/notes/10000</em> tehtyyn HTTP PUT -pyyntöön statuskoodilla 404 <em>not found</em>:</p>\n<p><img src=\"../images/2/23b.png\"></p>\n<p>Sovelluksen tulisi pystyä käsittelemään tilanne hallitusti. Jos konsoli ei ole auki, ei käyttäjä huomaa mitään muuta kuin sen, että muistiinpanon tärkeys ei vaihdu napin painelusta huolimatta.</p>\n<p>Jo <a href=\"#axios-ja-promiset\">aiemmin</a> mainittiin, että promisella voi olla kolme tilaa. Kun HTTP-pyyntö epäonnistuu, menee pyyntöä vastaava promise tilaan <code>rejected</code>. Emme tällä hetkellä käsittele koodissamme promisen epäonnistumista mitenkään.</p>\n<p>Promisen epäonnistuminen <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">käsitellään</a> antamalla <code>then</code>-metodille parametriksi myös toinen takaisinkutsufunktio, jota kutsutaan siinä tapauksessa jos promise epäonnistuu.</p>\n<p>Ehkä yleisempi tapa kuin kahden tapahtumankäsittelijän käyttö on liittää promiseen epäonnistumistilanteen käsittelijä kutsumalla metodia <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">catch</a>.</p>\n<p>Käytännössä virhetilanteen käsittelijän rekisteröiminen tapahtuisi seuraavasti</p>\n<pre><code class=\"language-js\">axios\n  .get('http://example.com/probably_will_fail')\n  .then(response => {\n    console.log('success!')\n  })\n  .catch(error => {\n    console.log('fail')\n  })\n</code></pre>\n<p>Jos pyyntö epäonnistuu, kutsutaan <code>catch</code>-metodin avulla rekisteröityä käsittelijää.</p>\n<p>Metodia <code>catch</code> hyödynnetään usein siten, että se sijoitetaan syvemmälle promiseketjuun.</p>\n<p>Kun sovelluksemme tekee HTTP-operaation syntyy oleellisesti ottaen <a href=\"https://javascript.info/promise-chaining\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">promiseketju</a>:</p>\n<pre><code class=\"language-js\">axios\n  .put(`${baseUrl}/${id}`, newObject)\n  .then(response => response.data)\n  .then(changedNote => {\n    // ...\n  })\n</code></pre>\n<p>Metodilla <code>catch</code> voidaan määritellä ketjun lopussa käsittelijäfunktio, jota kutsutaan siinä vaiheessa jos mikä tahansa ketjun promisesta epäonnistuu, eli menee tilaan <code>rejected</code>:</p>\n<pre><code class=\"language-js\">axios\n  .put(`${baseUrl}/${id}`, newObject)\n  .then(response => response.data)\n  .then(changedNote => {\n    // ...\n  })\n  .catch(error => {\n    console.log('fail')\n  })\n</code></pre>\n<p>Hyödynnetään tätä ominaisuutta, ja sijoitetaan virheenkäsittelijä komponenttiin <em>App</em>:</p>\n<pre><code class=\"language-js\">const toggleImportanceOf = id => {\n  const note = notes.find(n => n.id === id)\n  const changedNote = { ...note, important: !note.important }\n\n  noteService\n    .update(changedNote).then(returnedNote => {\n      setNotes(notes.map(note => note.id !== id ? note : returnedNote))\n    })\n    // highlight-start\n    .catch(error => {\n      alert(\n        `muistiinpano '${note.content}' on jo valitettavasti poistettu palvelimelta`\n      )\n      setNotes(notes.filter(n => n.id !== id))\n    })\n    // highlight-end\n}\n</code></pre>\n<p>Virheilmoitus annetaan vanhan kunnon <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/alert\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">alert</a>-dialogin avulla ja palvelimelta poistettu muistiinpano poistetaan tilasta.</p>\n<p>Olemattoman muistiinpanon poistaminen siis tapahtuu metodilla <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">filter</a>, joka muodostaa uuden taulukon, jonka sisällöksi tulee alkuperäisen taulukon sisällöstä ne alkiot, joille parametrina oleva funktio palauttaa arvon true:</p>\n<pre><code class=\"language-js\">notes.filter(n => n.id !== id)\n</code></pre>\n<p>Alertia tuskin kannattaa käyttää todellisissa React-sovelluksissa. Opimme kohta kehittyneemmän menetelmän käyttäjille tarkoitettujen tiedotteiden antamiseen. Toisaalta on tilanteita, joissa simppeli battle tested -menetelmä kuten <code>alert_</code> riittää aluksi aivan hyvin. Hienomman tavan voi sitten tehdä myöhemmin jos aikaa ja intoa riittää.</p>\n<p>Sovelluksen tämän hetkinen koodi on kokonaisuudessaan <a href=\"https://github.com/FullStack-HY/part2-notes/tree/part2-6\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">githubissa</a>, branchissa <em>part2-6</em>.</p>\n</div>\n<div class=\"tasks\">\n<h3>Tehtäviä</h3>\n<h4>2.15: puhelinluettelo osa 7</h4>\n<p>Palataan jälleen puhelinluettelon pariin.</p>\n<p>Tällä hetkellä luetteloon lisättäviä uusia numeroita ei synkronoida palvelimelle. Korjaa tilanne.</p>\n<h4>2.16: puhelinluettelo osa 8</h4>\n<p>Siirrä palvelimen kanssa kommunikoinnista vastaava toiminnallisuus omaan moduuliin osan 2 <a href=\"/osa2/#palvelimen-kanssa-tapahtuvan-kommunikoinnin-erist%C3%A4minen-omaan-moduuliin\">esimerkin</a> tapaan.</p>\n<h4>2.17: puhelinluettelo osa 9</h4>\n<p>Tee ohjelmaan mahdollisuus yhteystietojen poistamiseen. Poistaminen voi tapahtua esim. nimen yhteyteen liitetyllä napilla. Poiston suorittaminen voidaan varmistaa käyttäjältä <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/confirm\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">window.confirm</a>-metodilla:</p>\n<p><img src=\"../images/2/24b.png\"></p>\n<p>Palvelimelta tiettyä henkilöä vastaava resurssi tuhotaan tekemällä HTTP DELETE -pyyntö resurssia vastaavaan <i>URL</i>:iin, eli jos poistaisimme esim. käyttäjän, jonka <em>id</em> on 2, tulisi tapauksessamme tehdä HTTP DELETE osoitteeseen <em>localhost:3001/persons/2</em>. Pyynnön mukana ei lähetetä mitään dataa.</p>\n<p><a href=\"https://github.com/axios/axios\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Axios</a>-kirjaston avulla HTTP DELETE -pyyntö tehdään samaan tapaan kuin muutkin pyynnöt.</p>\n<p><strong>Huom:</strong> et voi käyttää Javascriptissa muuttujan nimeä <code>delete</code> sillä kyseessä on kielen varattu sana, eli seuraava ei onnistu:</p>\n<pre><code class=\"language-js\">// käytä jotain muuta muuttujan nimeä\nconst delete = (id) => {\n  // ...\n}\n</code></pre>\n<h4>2.18*: puhelinluettelo osa 10</h4>\n<p>Muuta toiminnallisuutta siten, että jos jo olemassaolevalle henkilölle lisätään numero, korvaa lisätty numero aiemman numeron. Korvaaminen kannattaa tehdä HTTP PUT -pyynnöllä.</p>\n<p>Jos henkilön tiedot löytyvät jo luettelosta, voi ohjelma kysyä käyttäjältä varmistuksen korvataanko numero:</p>\n<p><img src=\"../images/teht/16a.png\"></p>\n</div>","frontmatter":{"mainImage":{"publicURL":"/static/part-2-2c709798e38da8a809241016507d8154.svg"},"part":2,"letter":"d"}}},"pageContext":{"part":2,"letter":"d"}}