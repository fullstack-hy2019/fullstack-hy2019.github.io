{"data":{"markdownRemark":{"html":"<div class=\"content\">\n<h2>Kirjautuminen</h2>\n<p>Käyttäjien tulee pystyä kirjautumaan sovellukseemme ja muistiinpanot pitää automaattisesti liittää kirjautuneen käyttäjän tekemiksi.</p>\n<p>Toteutamme nyt backendiin tuen <a href=\"https://scotch.io/tutorials/the-ins-and-outs-of-token-based-authentication#toc-how-token-based-works\">token-perustaiselle</a> autentikoinnille.</p>\n<p>Token-autentikaation periaatetta kuvaa seuraava sekvenssikaavio:</p>\n<picture><img src=\"/static/937c92fa6024387eb9d4674be612f63e/14be6/12a.png\" srcset=\"/static/937c92fa6024387eb9d4674be612f63e/4cce7/12a.png 200w,\n/static/937c92fa6024387eb9d4674be612f63e/bae5f/12a.png 400w,\n/static/937c92fa6024387eb9d4674be612f63e/14be6/12a.png 800w,\n/static/937c92fa6024387eb9d4674be612f63e/1b35a/12a.png 1200w,\n/static/937c92fa6024387eb9d4674be612f63e/c7c74/12a.png 1494w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<ul>\n<li>\n<p>Alussa käyttäjä kirjautuu Reactilla toteutettua kirjautumislomaketta käyttäen</p>\n<ul>\n<li>lisäämme kirjautumislomakkeen frontendiin <a href=\"/osa5\">osassa 5</a></li>\n</ul>\n</li>\n<li>Tämän seurauksena selaimen React-koodi lähettää käyttäjätunnuksen ja salasanan HTTP POST -pyynnöllä palvelimen osoitteeseen <em>/api/login</em></li>\n<li>\n<p>Jos käyttäjätunnus ja salasana ovat oikein, generoi palvelin <em>Tokenin</em>, joka yksilöi jollain tavalla kirjautumisen tehneen käyttäjän</p>\n<ul>\n<li>token on kryptattu, joten sen väärentäminen on (kryptografisesti) mahdotonta</li>\n</ul>\n</li>\n<li>backend vastaa selaimelle onnistumisesta kertovalla statuskoodilla ja palauttaa Tokenin vastauksen mukana</li>\n<li>Selain tallentaa tokenin esimerkiksi React-sovelluksen tilaan</li>\n<li>Kun käyttäjä luo uuden muistiinpanon (tai tekee jonkin operaation, joka edellyttää tunnistautumista), lähettää React-koodi Tokenin pyynnön mukana palvelimelle</li>\n<li>Palvelin tunnistaa pyynnön tekijän tokenin perusteella</li>\n</ul>\n<p>Tehdään ensin kirjautumistoiminto. Asennetaan <a href=\"https://github.com/auth0/node-jsonwebtoken\">jsonwebtoken</a>-kirjasto, jonka avulla koodimme pystyy generoimaan <a href=\"https://jwt.io/\">JSON web token</a> -muotoisia tokeneja.</p>\n<pre><code class=\"language-bash\">npm install jsonwebtoken --save\n</code></pre>\n<p>Tehdään kirjautumisesta vastaava koodi tiedostoon <em>controllers/login.js</em></p>\n<pre><code class=\"language-js\">const jwt = require('jsonwebtoken');\nconst bcrypt = require('bcrypt');\nconst loginRouter = require('express').Router();\nconst User = require('../models/user');\n\nloginRouter.post('/', async (request, response) => {\n  const body = request.body;\n\n  const user = await User.findOne({ username: body.username });\n  const passwordCorrect =\n    user === null\n      ? false\n      : await bcrypt.compare(body.password, user.passwordHash);\n\n  if (!(user &#x26;&#x26; passwordCorrect)) {\n    return response.status(401).json({ error: 'invalid username or password' });\n  }\n\n  const userForToken = {\n    username: user.username,\n    id: user._id,\n  };\n\n  const token = jwt.sign(userForToken, process.env.SECRET);\n\n  response\n    .status(200)\n    .send({ token, username: user.username, name: user.name });\n});\n\nmodule.exports = loginRouter;\n</code></pre>\n<p>Koodi aloittaa etsimällä pyynnön mukana olevaa <em>username</em>:a vastaavan käyttäjän tietokannasta. Seuraavaksi katsotaan onko pyynnön mukana oleva <em>password</em> oikea. Koska tietokantaan ei ole talletettu salasanaa, vaan salasanasta laskettu <em>hash</em>, tehdään vertailu metodilla <em>bcrypt.compare</em>:</p>\n<pre><code class=\"language-js\">await bcrypt.compare(body.password, user.passwordHash);\n</code></pre>\n<p>Jos käyttäjää ei ole olemassa tai salasana on väärä, vastataan kyselyyn statuskoodilla <a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.2\">401 unauthorized</a> ja kerrotaan syy vastauksen bodyssä.</p>\n<p>Jos salasana on oikein, luodaan metodin <em>jwt.sign</em> avulla token, joka sisältää kryptatussa muodossa käyttäjätunnuksen ja käyttäjän id:</p>\n<pre><code class=\"language-js\">const userForToken = {\n  username: user.username,\n  id: user._id,\n};\n\nconst token = jwt.sign(userForToken, process.env.SECRET);\n</code></pre>\n<p>Token on digitaalisesti allekirjoitettu käyttämällä <em>salaisuutena</em> ympäristömuuttujassa <em>SECRET</em> olevaa merkkijonoa. Digitaalinen allekirjoitus varmistaa sen, että ainoastaan salaisuuden tuntevilla on mahdollisuus generoida validi token. Ympäristömuuttujalle pitää muistaa asettaa arvo tiedostoon .env.</p>\n<p>Onnistuneeseen pyyntöön vastataan statuskoodilla <em>200 ok</em> ja generoitu token sekä kirjautuneen käyttäjän käyttäjätunnus ja nimi lähetetään vastauksen bodyssä pyynnön tekijälle.</p>\n<p>Kirjautumisesta huolehtiva koodi on vielä liitettävä sovellukseen lisäämällä tiedostoon <em>index.js</em> muiden routejen käyttöönoton yhteyteen</p>\n<pre><code class=\"language-js\">const loginRouter = require('./controllers/login');\n\n//...\n\napp.use('/api/login', loginRouter);\n</code></pre>\n<p>Kokeillaan kirjautumista, käytetään VS Coden REST-clientiä:</p>\n<picture><img src=\"/static/a0ba801b7b49480529affd825c89942d/14be6/12b.png\" srcset=\"/static/a0ba801b7b49480529affd825c89942d/4cce7/12b.png 200w,\n/static/a0ba801b7b49480529affd825c89942d/bae5f/12b.png 400w,\n/static/a0ba801b7b49480529affd825c89942d/14be6/12b.png 800w,\n/static/a0ba801b7b49480529affd825c89942d/1b35a/12b.png 1200w,\n/static/a0ba801b7b49480529affd825c89942d/52ebc/12b.png 1498w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Kirjautuminen ei kuitenkaan toimi, konsoli näyttää seuraavalta:</p>\n<pre><code class=\"language-bash\">Method: POST\nPath:   /api/login\nBody:   { username: 'mluukkai', password: 'salainen' }\n---\n(node:17486) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 2): Error: secretOrPrivateKey must have a value\n</code></pre>\n<p>Ongelman aiheuttaa komento <em>jwt.sign(userForToken, process.env.SECRET)</em> sillä ympäristömuuttujalle <em>SECRET</em> on unohtunut määritellä arvo. Kun arvo määritellään tiedostoon <em>.env</em>, alkaa kirjautuminen toimia.</p>\n<p>Onnistunut kirjautuminen palauttaa kirjautuneen käyttäjän tiedot ja tokenin:</p>\n<picture><img src=\"/static/9aff0d00a1833383b5f71c2608d3d2aa/14be6/12c.png\" srcset=\"/static/9aff0d00a1833383b5f71c2608d3d2aa/4cce7/12c.png 200w,\n/static/9aff0d00a1833383b5f71c2608d3d2aa/bae5f/12c.png 400w,\n/static/9aff0d00a1833383b5f71c2608d3d2aa/14be6/12c.png 800w,\n/static/9aff0d00a1833383b5f71c2608d3d2aa/1b35a/12c.png 1200w,\n/static/9aff0d00a1833383b5f71c2608d3d2aa/9ee03/12c.png 1600w,\n/static/9aff0d00a1833383b5f71c2608d3d2aa/4c220/12c.png 1702w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Virheellisellä käyttäjätunnuksella tai salasanalla kirjautuessa annetaan asianmukaisella statuskoodilla varustettu virheilmoitus</p>\n<picture><img src=\"/static/5ba2a0f4032cc34fae12b3da01b97972/14be6/12d.png\" srcset=\"/static/5ba2a0f4032cc34fae12b3da01b97972/4cce7/12d.png 200w,\n/static/5ba2a0f4032cc34fae12b3da01b97972/bae5f/12d.png 400w,\n/static/5ba2a0f4032cc34fae12b3da01b97972/14be6/12d.png 800w,\n/static/5ba2a0f4032cc34fae12b3da01b97972/1b35a/12d.png 1200w,\n/static/5ba2a0f4032cc34fae12b3da01b97972/9ee03/12d.png 1600w,\n/static/5ba2a0f4032cc34fae12b3da01b97972/dfb2e/12d.png 1658w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<h3>Muistiinpanojen luominen vain kirjautuneille</h3>\n<p>Muutetaan vielä muistiinpanojen luomista, siten että luominen onnistuu ainoastaan jos luomista vastaavan pyynnön mukana on validi token. Muistiinpano talletetaan tokenin identifioiman käyttäjän tekemien muistiinpanojen listaan.</p>\n<p>Tapoja tokenin välittämiseen selaimesta backendiin on useita. Käytämme ratkaisussamme <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization\">Authorization</a>-headeria. Tokenin lisäksi headerin avulla kerrotaan mistä <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication#Authentication_schemes\">autentikointiskeemasta</a> on kyse. Tämä voi olla tarpeen, jos palvelin tarjoaa useita eri tapoja autentikointiin. Skeeman ilmaiseminen kertoo näissä tapauksissa palvelimelle, miten mukana olevat kredentiaalit tulee tulkita.\nMeidän käyttöömme sopii <em>Bearer</em>-skeema.</p>\n<p>Käytännössä tämä tarkoittaa, että jos token on esimerkiksi merkkijono <em>eyJhbGciOiJIUzI1NiIsInR5c2VybmFtZSI6Im1sdXVra2FpIiwiaW</em>, laitetaan pyynnöissä headerin Authorization arvoksi merkkijono</p>\n<pre>\nBearer eyJhbGciOiJIUzI1NiIsInR5c2VybmFtZSI6Im1sdXVra2FpIiwiaW\n</pre>\n<p>Modifioitu muistiinpanojen luomisesta huolehtiva koodi seuraavassa:</p>\n<pre><code class=\"language-js\">const jwt = require('jsonwebtoken');\n\n// ...\n\nconst getTokenFrom = request => {\n  const authorization = request.get('authorization');\n  if (authorization &#x26;&#x26; authorization.toLowerCase().startsWith('bearer ')) {\n    return authorization.substring(7);\n  }\n  return null;\n};\n\nnotesRouter.post('/', async (request, response) => {\n  const body = request.body;\n\n  try {\n    const token = getTokenFrom(request);\n    const decodedToken = jwt.verify(token, process.env.SECRET);\n\n    if (!token || !decodedToken.id) {\n      return response.status(401).json({ error: 'token missing or invalid' });\n    }\n\n    if (body.content === undefined) {\n      return response.status(400).json({ error: 'content missing' });\n    }\n\n    const user = await User.findById(decodedToken.id);\n\n    const note = new Note({\n      content: body.content,\n      important: body.important === undefined ? false : body.important,\n      date: new Date(),\n      user: user._id,\n    });\n\n    const savedNote = await note.save();\n\n    user.notes = user.notes.concat(savedNote._id);\n    await user.save();\n\n    response.json(Note.format(note));\n  } catch (exception) {\n    if (exception.name === 'JsonWebTokenError') {\n      response.status(401).json({ error: exception.message });\n    } else {\n      console.log(exception);\n      response.status(500).json({ error: 'something went wrong...' });\n    }\n  }\n});\n</code></pre>\n<p>Apufunktio <em>getTokenFrom</em> eristää tokenin headerista <em>authorization</em>. Tokenin oikeellisuus varmistetaan metodilla <em>jwt.verify</em>. Metodi myös dekoodaa tokenin, eli palauttaa olion, jonka perusteella token on laadittu:</p>\n<pre><code class=\"language-js\">const decodedToken = jwt.verify(token, process.env.SECRET);\n</code></pre>\n<p>Tokenista dekoodatun olion sisällä on kentät <em>username</em> ja <em>id</em> eli se kertoo palvelimelle kuka pyynnön on tehnyt.</p>\n<p>Jos tokenia ei ole tai tokenista dekoodattu olio ei sisällä käyttäjän identiteettiä (eli <em>decodedToken.id</em> ei ole määritelty), palautetaan virheestä kertova statuskoodi <a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.2\">401 unauthorized</a> ja kerrotaan syy vastauksen bodyssä:</p>\n<pre><code class=\"language-js\">if (!token || !decodedToken.id) {\n  return response.status(401).json({ error: 'token missing or invalid' });\n}\n</code></pre>\n<p>Kun pyynnön tekijän identiteetti on selvillä, jatkuu suoritus entiseen tapaan.</p>\n<p>Tokenin verifiointi voi myös aiheuttaa poikkeuksen <em>JsonWebTokenError</em>. Syynä tälle voi olla viallinen, väärennetty tai eliniältään vanhentunut token. Poikkeusten käsittelyssä haaraudutaan virheen tyypin perusteella ja vastataan 401 jos poikkeus johtuu tokenista, ja muuten vastataan <a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.1\">500 internal server error</a>.</p>\n<p>Uuden muistiinpanon luominen onnistuu nyt postmanilla jos <em>authorization</em>-headerille asetetaan oikeanlainen arvo, eli merkkijono <em>bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ</em>, missä osa on <em>login</em>-operaation palauttama token.</p>\n<p>Postmanilla luominen näyttää seuraavalta</p>\n<picture><img src=\"/static/65b86b25c754bcad64c12aee31805c2e/14be6/14.png\" srcset=\"/static/65b86b25c754bcad64c12aee31805c2e/4cce7/14.png 200w,\n/static/65b86b25c754bcad64c12aee31805c2e/bae5f/14.png 400w,\n/static/65b86b25c754bcad64c12aee31805c2e/14be6/14.png 800w,\n/static/65b86b25c754bcad64c12aee31805c2e/1b35a/14.png 1200w,\n/static/65b86b25c754bcad64c12aee31805c2e/9ee03/14.png 1600w,\n/static/65b86b25c754bcad64c12aee31805c2e/fa119/14.png 1750w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>ja Visual Studio Coden REST clientillä</p>\n<picture><img src=\"/static/b8b19b2b276ac7c5a0781ea4fc6cb377/14be6/14a.png\" srcset=\"/static/b8b19b2b276ac7c5a0781ea4fc6cb377/4cce7/14a.png 200w,\n/static/b8b19b2b276ac7c5a0781ea4fc6cb377/bae5f/14a.png 400w,\n/static/b8b19b2b276ac7c5a0781ea4fc6cb377/14be6/14a.png 800w,\n/static/b8b19b2b276ac7c5a0781ea4fc6cb377/1b35a/14a.png 1200w,\n/static/b8b19b2b276ac7c5a0781ea4fc6cb377/9ee03/14a.png 1600w,\n/static/b8b19b2b276ac7c5a0781ea4fc6cb377/925bb/14a.png 2012w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Sovelluksen tämänhetkinen koodi on kokonaisuudessaan <a href=\"https://github.com/FullStack-HY/part3-notes-backend/tree/part4-6\">githubissa</a>, tagissa <em>part4-6</em>.</p>\n<p>Jos sovelluksessa on useampia rajapintoja jotka vaativat kirjautumisen kannattaa JWT:n validointi eriyttää omaksi middlewarekseen, tai käyttää jotain jo olemassa olevaa kirjastoa kuten <a href=\"https://www.npmjs.com/package/express-jwt\">express-jwt</a>.</p>\n<h3>Loppuhuomioita</h3>\n<p>Koodissa on tapahtunut paljon muutoksia ja matkan varrella on tapahtunut tyypillinen kiivaasti etenevän ohjelmistoprojektin ilmiö: suuri osa testeistä on hajonnut. Koska kurssin tämä osa on jo muutenkin täynnä uutta asiaa, jätämme testien korjailun harjoitustehtäväksi.</p>\n<p>Käyttäjätunnuksia, salasanoja ja tokenautentikaatiota hyödyntäviä sovelluksia tulee aina käyttää salatun <a href=\"https://en.wikipedia.org/wiki/HTTPS\">HTTPS</a>-yhteyden yli. Voimme käyttää sovelluksissamme Noden <a href=\"https://nodejs.org/docs/latest-v8.x/api/http.html\">HTTP</a>-serverin sijaan <a href=\"https://nodejs.org/api/https.html\">HTTPS</a>-serveriä (se vaatii lisää konfiguraatiota). Toisaalta koska sovelluksemme tuotantoversio on Herokussa, sovelluksemme pysyy käyttäjien kannalta suojattuna sen ansiosta, että Heroku reitittää kaiken liikenteen selaimen ja Herokun palvelimien välillä HTTPS:n yli.</p>\n<p>Toteutamme kirjautumisen frontendin puolelle kurssin <a href=\"/osa5\">seuraavassa osassa</a>.</p>\n<h2>Tehtäviä</h2>\n<p>Tee nyt tehtävät <a href=\"/teht%C3%A4v%C3%A4t/#blogilistan-k%C3%A4ytt%C3%A4j%C3%A4t\">4.15-4.21</a></p>\n<!---\nnote left of kayttaja\n  käyttäjä täyttää kirjautumislomakkeelle\n  käyttäjätunnuksen ja salasanan\nend note\nkayttaja -> selain: painetaan login-nappia\n\nselain -> backend: HTTP POST /api/login {username, password}\nnote left of backend\n  backend generoi käyttäjän identifioivan TOKENin\nend note\nbackend -> selain: TOKEN palautetaan vastauksen bodyssä\nnote left of selain\n  selain tallettaa TOKENin\nend note\nnote left of kayttaja\n  käyttäjä luo uden muistiinpanon\nend note\nkayttaja -> selain: painetaan create note -nappia\nselain -> backend: HTTP POST /api/notes {content} headereissa TOKEN\nnote left of backend\n  backend tunnistaa TOKENin perusteella kuka käyttää kyseessä\nend note\n\nbackend -> selain: 201 created\n\nkayttaja -> kayttaja:\n-->\n</div>","frontmatter":{"title":"osa 4","subTitle":"Web","path":"/osa4/web","mainImage":{"publicURL":"/static/osa5-8edc6044aad809a3143dc36c5e7f3b4c.png"},"partColor":"yellow","part":4,"letter":"e"}}},"pageContext":{}}