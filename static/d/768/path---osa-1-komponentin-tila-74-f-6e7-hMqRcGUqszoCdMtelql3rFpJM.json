{"data":{"markdownRemark":{"html":"<div class=\"content\">\n<p>Palataan jälleen Reactin pariin.</p>\n<p>Sovelluksemme jäi seuraavaan tilaan</p>\n<pre><code class=\"language-react\">const Hello = (props) => {\n  return (\n    &#x3C;div>\n      &#x3C;p>Hello {props.name}, you are {props.age} years old&#x3C;/p>\n    &#x3C;/div>\n  )\n}\n\nconst App = () => {\n  const nimi = 'Pekka'\n  const ika = 10\n\n  return (\n    &#x3C;div>\n      &#x3C;h1>Greetings&#x3C;/h1>\n      &#x3C;Hello name=\"Arto\" age={26 + 10} />\n      &#x3C;Hello name={nimi} age={ika} />\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<h3>Komponenttien apufunktiot</h3>\n<p>Laajennetaan komponenttia <em>Hello</em> siten, että se antaa arvion tervehdittävän henkilön syntymävuodesta:</p>\n<pre><code class=\"language-js\">const Hello = (props) => {\n  const bornYear = () => {\n    const yearNow = new Date().getFullYear()\n    return yearNow - props.age\n  }\n\n  return (\n    &#x3C;div>\n      &#x3C;p>Hello {props.name}, you are {props.age} years old&#x3C;/p>\n      &#x3C;p>So you were probably born {bornYear()}&#x3C;/p>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Syntymävuoden arvauksen tekevä logiikka on erotettu omaksi funktiokseen, jota kutsutaan renderöinnin yhteydessä. </p>\n<p>Tervehdittävän henkilön ikää ei metodille tarvitse välittää parametrina, sillä funktio näkee sen sisältävälle komponentille välitettävät propsit.</p>\n<p>Teknisesti ajatellen syntymävuoden määrittelevä funktio on määritelty komponentin toiminnan määrittelevän funktion sisällä. Esim. Javalla ohjelmoitaessa metodien määrittely toisen metodin sisällä ei onnistu. Javascriptissa taas funktioiden sisällä määritellyt funktiot on hyvin yleisesti käytetty tekniikka.</p>\n<h3>Destrukturointi</h3>\n<p>Ennen kuin siirrymme eteenpäin, tarkastellaan erästä pientä, mutta käyttökelpoista ES6:n mukanaan tuomaa uutta piirrettä Javascriptissä, eli sijoittamisen yhteydessä tapahtuvaa <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\">destrukturointia</a>.</p>\n<p>Jouduimme äskeisessä koodissa viittaamaan propseina välitettyyn dataan hieman ikävästi muodossa <em>props.name</em> ja <em>props.age</em>. Näistä <em>props.age</em> pitää toistaa komponentissa kahteen kertaan.</p>\n<p>Koska <em>props</em> on nyt olio</p>\n<pre><code class=\"language-js\">props = {\n  name: 'Arto Hellas',\n  age: 35,\n};\n</code></pre>\n<p>voimme suoraviivaistaa komponenttia siten, että sijoitamme kenttien arvot muuttujiin <em>name</em> ja <em>age</em> jonka jälkeen niitä on mahdollista käyttää koodissa suoraan:</p>\n<pre><code class=\"language-react\">const Hello = (props) => {\n  const name = props.name\n  const age = props.age\n\n  const bornYear = () => new Date().getFullYear() - age\n\n  return (\n    &#x3C;div>\n      &#x3C;p>Hello {name}, you are {age} years old&#x3C;/p>\n      &#x3C;p>So you were probably born {bornYear()}&#x3C;/p>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Huomaa, että olemme myös hyödyntäneet nuolifunktion kompaktimpaa kirjoitustapaa metodin <em>bornYear</em> määrittelyssä. Kuten aiemmin totesimme, jos nuolifunktio koostuu ainoastaan yhdestä komennosta, ei funktion runkoa tarvitse kirjoittaa aaltosulkeiden sisään ja funktio palauttaa ainoan komentonsa arvon.</p>\n<p>Seuraavat ovat siis vaihtoehtoiset tavat määritellä sama funktio:</p>\n<pre><code class=\"language-js\">const bornYear = () => new Date().getFullYear() - age\n\nconst bornYear = () => {\n  return new Date().getFullYear() - age\n}\n</code></pre>\n<p>Destrukturointi tekee apumuuttujien määrittelyn vielä helpommaksi, sen avulla voimme \"kerätä\" olion oliomuuttujien arvot suoraan omiin yksittäisiin muuttujiin:</p>\n<pre><code class=\"language-react\">const Hello = (props) => {\n  const { name, age } = props\n  const bornYear = () => new Date().getFullYear() - age\n\n  return (\n    &#x3C;div>\n      &#x3C;p>Hello {name}, you are {props.age} years old&#x3C;/p>\n      &#x3C;p>So you were probably born {bornYear()}&#x3C;/p>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Eli koska</p>\n<pre><code class=\"language-js\">props = {\n  name: 'Arto Hellas',\n  age: 35,\n};\n</code></pre>\n<p>saa <code> const { name, age } = props</code> aikaan sen, että muuttuja <em>name</em> saa arvon 'Arto Hellas' ja muuttuja <em>age</em> arvon 35.</p>\n<p>Voimme viedä destrukturoinnin vielä askeleen verran pidemmälle</p>\n<pre><code class=\"language-js\">const Hello = ({ name, age }) => {\n  const bornYear = () => new Date().getFullYear() - age\n\n  return (\n    &#x3C;div>\n      &#x3C;p>Hello {name}, you are {age} years old&#x3C;/p>\n      &#x3C;p>So you were probably born {bornYear()}&#x3C;/p>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Destrukturointi tehdään nyt suodaan sijoittamalla komponentin saamat propsit muuttujiin <em>name</em> ja <em>age</em>. </p>\n<p>Eli sensijaan että props-olio otettaisiin vastaan muuttujaan <em>props</em> ja sen kentät sijoitettaisiin tämän jälkeen muuttujiin <em>name</em> ja <em>age</em></p>\n<pre><code class=\"language-react\">const Hello = (props) => {\n  const { name, age } = props\n</code></pre>\n<p>sijoitamme destrukturoinnin avulla propsin kentät suoraan muuttujiin kun määrittelemme komponettifunktion saaman parametrin:</p>\n<pre><code class=\"language-react\">const Hello = ({ name, age }) => {\n</code></pre>\n<h3>Sivun uudelleenrenderöinti</h3>\n<p>Toistaiseksi tekemämme sovellukset ovat olleet sellaisia, että kun niiden komponentit on kerran renderöity, niiden ulkoasua ei ole enää voinut muuttaa. Entä jos haluaisimme toteuttaa laskurin, jonka arvo kasvaa esim. ajan kuluessa tai nappien painallusten yhteydessä?</p>\n<p>Aloitetaan seuraavasta rungosta:</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  const {counter} = props\n  return (\n    &#x3C;div>{counter.value}&#x3C;/div>\n  )\n}\n\nconst counter = {\n  value: 1\n}\n\nReactDOM.render(\n  &#x3C;App counter={counter} />,\n  document.getElementById('root')\n)\n</code></pre>\n<p>Sovelluksen juurikomponentille siis annetaan viite laskuriin. Juurikomponentti renderöi arvon ruudulle. Entä laskurin arvon muuttuessa? Jos lisäämme ohjelmaan esim. komennon</p>\n<pre><code class=\"language-react\">counter.value += 1\n</code></pre>\n<p>ei komponenttia kuitenkaan renderöidä uudelleen. Voimme saada komponentin uudelleenrenderöitymään kutsumalla uudelleen metodia <em>ReactDOM.render</em>, esim. seuraavasti</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  const { counter } = props\n  return (\n    &#x3C;div>{counter}&#x3C;/div>\n  )\n}\n\nlet counter = 1\n\nconst renderoi = () => {\n  ReactDOM.render(\n    &#x3C;App counter={counter} />,\n    document.getElementById('root')\n  )\n}\n\nrenderoi()\ncounter += 1\nrenderoi()\ncounter += 1\nrenderoi()\n</code></pre>\n<p>Copypastea vähentämään on komponentin renderöinti kääritty funktioon <em>renderoi</em>.</p>\n<p>Nyt komponentti renderöityy kolme kertaa, saaden ensin arvon 1, sitten 2 ja lopulta 3. 1 ja 2 tosin ovat ruudulla niin vähän aikaa, että niitä ei ehdi havaita.</p>\n<p>Hieman mielenkiintoisempaan toiminnallisuuteen pääsemme tekemällä renderöinnin ja laskurin kasvatuksen toistuvasti sekunnin välein käyttäen <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval\">SetInterval</a>:</p>\n<pre><code class=\"language-js\">setInterval(() => {\n  renderoi()\n  counter += 1\n}, 1000)\n</code></pre>\n<p><em>ReactDOM.render</em>-metodin toistuva kutsuminen ei kuitenkaan ole suositeltu tapa päivittää komponentteja. Tutustutaan seuraavaksi järkevämpään tapaan.</p>\n<h3>Tilallinen komponentti</h3>\n<p>Tähänastiset komponenttimme ovat olleet siinä mielessä yksinkertaisia, että niillä ei ole ollut ollenkaan omaa tilaa, joka voisi muuttua komponentin elinaikana. </p>\n<p>Määritellään nyt sovelluksemme komonentille <em>App</em> tila Reactin <a href=\"https://reactjs.org/docs/hooks-state.html\">state hookin</a> avulla.</p>\n<pre><code class=\"language-react\">import React, { useState } from 'react'\nimport ReactDOM from 'react-dom'\n\nconst App = (props) => {\n  const [ counter, setCounter ] = useState(0)\n\n  setInterval(\n    () => setCounter(counter + 1),\n    1000\n  )\n\n  return (\n    &#x3C;div>{counter}&#x3C;/div>\n  )\n}\n\nReactDOM.render(\n  &#x3C;App />,\n  document.getElementById('root')\n)\n</code></pre>\n<p>Muutetaan esimerkkisovelluksen komponentti <em>App</em> luokkaperustaiseksi:</p>\n<pre><code class=\"language-react\">class App extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      counter: 1\n    }\n  }\n\n  render() {\n    return (\n      &#x3C;div>{this.state.counter}&#x3C;/div>\n    )\n  }\n}\n\nReactDOM.render(\n  &#x3C;App />,\n  document.getElementById('root')\n)\n</code></pre>\n<p>Komponentilla on nyt metodin <em>render</em> lisäksi <em>konstruktori</em>. Komponentin konstruktori saa parametrikseen sille välitettävät muuttujat parametrin <em>props</em> välityksellä, konstruktorin ensimmäisen rivin on oltava kutsu <code>super(props)</code>.</p>\n<p>Luokkiin perustuvilla komponenteilla voi olla <em>tila</em>, joka talletetaan muuttujaan <em>state</em>.</p>\n<p>Konstruktori määrittelee komponentin alkutilan olevan:</p>\n<pre><code class=\"language-js\">{\n  counter: 1;\n}\n</code></pre>\n<p>Eli tila sisältää kentän <em>counter</em>, jonka arvo on 1. React-komponenttien tilaa, eli muuttujaa <em>this.state</em> <strong>ei saa päivittää suoraan</strong>, tilan päivitys on tehtävä <strong>aina</strong> funktion <a href=\"https://reactjs.org/docs/faq-state.html#what-does-setstate-do\">setState</a> avulla. Metodin kutsuminen päivittää tilan <em>ja</em> aiheuttaa komponentin uuden renderöinnin (ellei sitä ole estetty myöhemmin esiteltävällä tavalla). Uudelleenrenderöinnin yhteydessä myös kaikki komponentin sisältämät alikomponentit renderöidään.</p>\n<p>Muutetaan komponenttia <em>App</em> siten, että konstruktorissa käynnistetään ajastin, joka kutsuu funktiota <em>setState</em> toistuvasti sekunnin välein korottaen laskurin arvoa aina yhdellä:</p>\n<pre><code class=\"language-react\">class App extends React.Component {\n  constructor() {\n    super()\n    this.state = {\n      counter: 1\n    }\n\n    setInterval(() => {\n      this.setState({ counter: this.state.counter + 1 })\n    }, 1000)\n  }\n  render() {\n    return (\n      &#x3C;div>{this.state.counter}&#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<p>Ruudulle renderöity laskurin arvo päivittyy sillä aina komponentin tilan muuttuessa <em>React</em> kutsuu komponentin metodia <em>render</em>.</p>\n<p>Jos komponentti ei renderöidy vaikka sen omasta mielestä pitäisi, tai se renderöityy \"väärään aikaan\", debuggaamista auttaa joskus metodiin <em>render</em> liitetty konsoliin tulostus. Esim. jos lisäämme koodiin seuraavan,</p>\n<pre><code class=\"language-react\">class App extends React.Component {\n  // ...\n  render() {\n    console.log('renderöidään', this.state.counter)\n    return (\n      &#x3C;div>{this.state.counter}&#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<p>on konsolista helppo seurata metodin <em>render</em> kutsuja:</p>\n<picture><img src=\"/static/5a2248873f442ef831d6561303c99b41/14be6/27a.png\" srcset=\"/static/5a2248873f442ef831d6561303c99b41/4cce7/27a.png 200w,\n/static/5a2248873f442ef831d6561303c99b41/bae5f/27a.png 400w,\n/static/5a2248873f442ef831d6561303c99b41/14be6/27a.png 800w,\n/static/5a2248873f442ef831d6561303c99b41/1b35a/27a.png 1200w,\n/static/5a2248873f442ef831d6561303c99b41/9ee03/27a.png 1600w,\n/static/5a2248873f442ef831d6561303c99b41/c659e/27a.png 1668w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<h3>Tapahtumankäsittely</h3>\n<p>Mainitsimme jo <a href=\"/osa0\">osassa 0</a> muutamaan kertaan <em>tapahtumankäsittelijät</em>, eli funktiot, jotka on rekisteröity kutsuttavaksi tiettyjen tapahtumien eli eventien yhteydessä. Esim. käyttäjän interaktio sivun elementtien kanssa aiheuttaa joukon erinäisiä tapahtumia.</p>\n<p>Muutetaan sovellusta siten, että laskurin kasvaminen tapahtuukin käyttäjän painaessa <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button\">button</a>-elementin avulla toteutettua nappia.</p>\n<p>Button-elementit tukevat mm. <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\">hiiritapahtumia</a> (mouse events), joista yleisin on <a href=\"https://developer.mozilla.org/en-US/docs/Web/Events/click\">click</a>.</p>\n<p>Reactissa funktion rekisteröiminen tapahtumankäsittelijäksi tapahtumalle <em>click</em> <a href=\"https://reactjs.org/docs/handling-events.html\">tapahtuu</a> seuraavasti:</p>\n<pre><code class=\"language-react\">const funktio = () => { /* koodi */ }\n\n//...\n\n&#x3C;button onClick={funktio}>\n  plus\n&#x3C;/button>\n</code></pre>\n<p>Eli laitetaan <em>button</em>:in onClick-attribuutin arvoksi aaltosulkeissa oleva viite koodissa määriteltyyn funktioon.</p>\n<p>Tapahtumankäsittelijäfunktio voidaan määritellä suoraan onClick-määrittelyn yhteydessä:</p>\n<pre><code class=\"language-react\">class App extends React.Component {\n  constructor() {\n    super()\n    this.state = {\n      counter: 1\n    }\n  }\n\n  render() {\n    return (\n      &#x3C;div>\n        &#x3C;div>{this.state.counter}&#x3C;/div>\n        &#x3C;button onClick={() => console.log('clicked')}>\n          plus\n        &#x3C;/button>\n      &#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<p>Nyt jokainen napin <em>plus</em> painallus tulostaa konsoliin <em>clicked</em>.</p>\n<p>Muuttamalla tapahtumankäsittelijä seuraavaan muotoon</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={() => this.setState({ counter: this.state.counter + 1 })}>\n  plus\n&#x3C;/button>\n</code></pre>\n<p>saamme halutun toiminnallisuuden.</p>\n<p>Lisätään sovellukseen myös nappi laskurin nollaamiseen:</p>\n<pre><code class=\"language-react\">class App extends React.Component {\n  constructor() {\n    super()\n    this.state = {\n      counter: 1\n    }\n  }\n\n  render() {\n    return (\n      &#x3C;div>\n        &#x3C;div>{this.state.counter}&#x3C;/div>\n        &#x3C;div>\n          &#x3C;button onClick={() => this.setState({ counter: this.state.counter + 1 })}>\n            plus\n          &#x3C;/button>\n          &#x3C;button onClick={() => this.setState({ counter: 0 })}>\n            zero\n          &#x3C;/button>\n        &#x3C;/div>\n      &#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<p>Sovelluksemme on valmis!</p>\n<h3>Metodien käyttö ja <em>this</em></h3>\n<p>Tapahtumankäsittelijöiden määrittely suoraan JSX-templatejen sisällä ei useimmiten ole kovin viisasta. Eriytetään nappien tapahtumankäsittelijät omiksi metodeikseen:</p>\n<pre><code class=\"language-react\">class App extends React.Component {\n  constructor() {\n    super()\n    this.state = {\n      counter: 1\n    }\n  }\n\n  kasvataYhdella() {\n    this.setState({ counter: this.state.counter + 1 })\n  }\n\n  nollaa() {\n    this.setState({ counter: 0 })\n  }\n\n  render() {\n    return (\n      &#x3C;div>\n        &#x3C;div>{this.state.counter}&#x3C;/div>\n        &#x3C;div>\n          &#x3C;button onClick={this.kasvataYhdella}>\n            plus\n          &#x3C;/button>\n          &#x3C;button onClick={this.nollaa}>\n            zero\n          &#x3C;/button>\n        &#x3C;/div>\n      &#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<p>Komponentin määrittelemälle luokalle on nyt lisätty metodit <em>kasvataYhdella</em> ja <em>nollaa</em>. Metodeihin <em>viitataan</em> nappeja vastaavista React-elementeistä:</p>\n<pre><code class=\"language-jsx\">&#x3C;button onClick={this.kasvataYhdella}>\n</code></pre>\n<p>Kun testaamme nyt sovellusta, törmäämme ongelmaan. Virheilmoitus on erittäin hyvä:</p>\n<picture><img src=\"/static/619813ceac00763e0059edcb67000297/14be6/28.png\" srcset=\"/static/619813ceac00763e0059edcb67000297/4cce7/28.png 200w,\n/static/619813ceac00763e0059edcb67000297/bae5f/28.png 400w,\n/static/619813ceac00763e0059edcb67000297/14be6/28.png 800w,\n/static/619813ceac00763e0059edcb67000297/1b35a/28.png 1200w,\n/static/619813ceac00763e0059edcb67000297/e8af6/28.png 1284w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Eli törmäämme jo <a href=\"#olioiden-metodit-ja-this\">aiemmin mainittuun</a> ongelmaan alkuperäisen <em>this</em>:in kadottamisesta.</p>\n<p>Kun selaimen Javascriptin runtime kutsuu takaisinkutsufunktiota, <em>this</em> ei enää viittaa komponenttiin <em>App</em> vaan on arvoltaan <em>undefined</em> eli määrittelemätön:</p>\n<picture><img src=\"/static/1d47fd8edd2312f959c103151e0db442/14be6/29.png\" srcset=\"/static/1d47fd8edd2312f959c103151e0db442/4cce7/29.png 200w,\n/static/1d47fd8edd2312f959c103151e0db442/bae5f/29.png 400w,\n/static/1d47fd8edd2312f959c103151e0db442/14be6/29.png 800w,\n/static/1d47fd8edd2312f959c103151e0db442/1b35a/29.png 1200w,\n/static/1d47fd8edd2312f959c103151e0db442/d600f/29.png 1224w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Ongelmaan on useita erilaisia ratkaisuja. Eräs näistä on jo <a href=\"#olioiden-metodit-ja-this\">aiemmin mainittu</a> <em>bindaaminen</em>, eli esim. komennolla <code>this.kasvataYhdella.bind(this)</code> voimme muodostaa uuden funktion, jonka koodi on alkuperäisen funktion koodi, missä <em>this</em> on sidottu viittaamaan parametrina olevaan arvoon, eli komponenttiin itseensä.</p>\n<p>Eli sovellus toimii taas jos koodi muutetaan muotoon:</p>\n<pre><code class=\"language-html\">&#x3C;button onClick=\"{this.kasvataYhdella.bind(this)}\">plus&#x3C;/button>\n&#x3C;button onClick=\"{this.nollaa.bind(this)}\">zero&#x3C;/button>\n</code></pre>\n<p>Jos samaa metodia joudutaan kutsumaan useasta kohtaa koodia, on hieman ikävää kirjoittaa toistuvasti metodin bindattu muoto React-elementtien sekaan.</p>\n<p>Yksi mahdollisuus onkin suorittaa bindaukset konstruktorissa:</p>\n<pre><code class=\"language-react\">class App extends React.Component {\n  constructor() {\n    super()\n    this.state = {\n      counter: 1\n    }\n    this.kasvataYhdella = this.kasvataYhdella.bind(this)\n    this.nollaa = this.nollaa.bind(this)\n  }\n</code></pre>\n<p>Nyt riittää viitata metodeihin \"normaalisti\", ilman bindiä:</p>\n<pre><code class=\"language-html\">&#x3C;button onClick=\"{this.kasvataYhdella}\">plus&#x3C;/button>\n&#x3C;button onClick=\"{this.nollaa}\">zero&#x3C;/button>\n</code></pre>\n<p>Teknisesti ottaen konstruktorissa korvataan kenttään <em>kasvataYhdella</em> alunperin määritelty metodi uudella metodilla, jolla on alkuperäisen metodin koodi siten, että <em>this</em> on pysyvästi bindattu komponenttiin.</p>\n<p>Ehkä paras ratkaisu <em>this</em>-ongelman estämiseen on käyttää tulevaan Javascript-standardiin ehdotettua <a href=\"https://babeljs.io/docs/plugins/transform-class-properties/\">class properties</a> -ominaisuutta, jonka avulla voimme määritellä this:in suhteen hyvin käyttäytyviä metodeja seuraavasti:</p>\n<pre><code class=\"language-react\">class App extends React.Component {\n  constructor() {\n    super()\n    this.state = {\n      counter: 1\n    }\n  }\n\n  kasvataYhdella = () => {\n    this.setState({ counter: this.state.counter + 1 })\n  }\n\n  nollaa = () => {\n    this.setState({ counter: 0 })\n  }\n\n  render() {\n    // ...\n  }\n</code></pre>\n<p>Näin jokainen <em>App</em>-komponentti saa kentät <em>kasvataYhdella</em> ja <em>nollaa</em> jotka ovat funktioita, joiden <em>this</em> on sidottu komponenttiin riippumatta siitä miten ja kenen toimesta metodia kutsutaan.</p>\n<p>Syy miksi nuolifunktiolla määritelty metodi toimii <em>this</em>:in suhteen samaan tapaan kuin esim. Javassa, on se, että nuolifunktioilla on ns. <em>leksikaalinen (lexical) this</em>, eli nuolifunktion <em>this</em> määräytyy sen määrittelykontekstin <em>this</em>:in mukaan. Kun metodi määritellään class propertynä, on määrittelykontekstina <em>App</em>-komponentti. Tarkempaa selitystä esim. <a href=\"https://medium.com/@reasoncode/javascript-es6-arrow-functions-and-lexical-this-f2a3e2a5e8c4\">täällä</a>.</p>\n<p>Käytämme kurssilla jatkossa tätä tapaa komponenttien metodien määrittelemiseen.</p>\n<p><a href=\"https://babeljs.io/docs/plugins/transform-class-properties/\">class propertyt</a> siis eivät ole vielä mukana uusimmassa javascript-standardissa eli kesäkuussa 2017 ilmestyneessä ES8:ssa. Voimme kuitenkin käyttää ominaisuutta create-react-app:illa luoduissa sovelluksissa, sillä <a href=\"https://babeljs.io/\">babel</a> osaa kääntää (eli transpiloida) ominaisuuden selainten ymmärtämään muotoon.</p>\n<p>Node.js ei oletusarvoisesti vielä tue ominaisuutta, eli kääntämätöntä koodia joka sisältää class propertyjä ei voi vielä suorittaa Node.js:llä.</p>\n<h3>Pari huomiota funktion setState käytöstä</h3>\n<p>Käytimme metodia <em>setState</em> kahteen kertaan:</p>\n<pre><code class=\"language-js\">kasvataYhdella = () => {\n  this.setState({ counter: this.state.counter + 1 });\n};\n\nnollaa = () => {\n  this.setState({ counter: 0 });\n};\n</code></pre>\n<p>Näistä ensimmäinen tapa <code>this.setState({ counter: this.state.counter + 1 })</code> ei ole kaikissa tilanteissa suositeltava, sillä React ei takaa että metodin <em>setState</em> kutsut tapahtuvat <a href=\"https://reactjs.org/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous\">siinä järjestyksessä missä ne on kirjoitettu koodiin</a>.</p>\n<p>Jos halutaan määritellä uusi tila olemassaolevan tilan perusteella, on varmempi kutsua <em>setState</em>:a seuraavasti:</p>\n<pre><code class=\"language-js\">this.setState(prevState => ({\n  counter: prevState.counter + 1,\n}));\n</code></pre>\n<p>Nyt metodin parametrina on funktio, jonka parametrina on edellinen tila <em>prevState</em> ja tilan päivitys tapahtuu varmuudella kutsuhetken edellisen tilan perusteella.</p>\n<p>Emme nyt viitsi käyttää tätä monimutkaisempaa muotoa, sillä emme välitä vaikka sovelluksessamme ilmenisikin silloin tällöin pieni epäkonsistenssi (on epäselvää olisiko se sovelluksessamme edes teoriassa mahdollista).</p>\n<p>Asia tulee kuitenkin ehdottomasti pitää mielessä, <em>setState</em>:n vääränlainen käyttö saattaa aiheuttaa hankalasti löydettäviä, harvoin toistuvia bugeja.</p>\n<p>Tärkeä mielessä pidettävä seikka on myös se, että <strong>React kutsuu funktiota setState asynkroonisesti</strong>, eli jos meillä on seuraava koodi</p>\n<pre><code class=\"language-js\">console.log(this.state.counter);\nthis.setState({ counter: 55 });\nconsole.log(this.state.counter);\n</code></pre>\n<p>tulostavat molemmat rivit saman arvon sillä Reactin tila <strong>ei saa uutta arvoa</strong> heti komennon <em>this.setState</em> jälkeen, vaan vasta sitten, kun suorituksen alla oleva metodi on suoritettu loppuun ja <em>setState</em> on saanut mahdollisuuden suoritukselle.</p>\n<h3>Funktio joka palauttaa funktion</h3>\n<p>Metodit <em>kasvataYhdella</em> ja <em>nollaa</em> toimivat melkein samalla tavalla, ne asettavat uuden arvon laskurille. Tehdään koodiin yksittäinen metodi, joka sopii molempiin käyttötarkoituksiin:</p>\n<pre><code class=\"language-react\">asetaArvoon = (arvo) => {\n  this.setState({ counter: arvo })\n}\n\nrender() {\n  //...\n  &#x3C;button onClick={this.asetaArvoon(this.state.counter+1)}>\n    Plus\n  &#x3C;/button>\n  &#x3C;button onClick={this.asetaArvoon(0)}>\n    Zero\n  &#x3C;/button>\n  //...\n}\n</code></pre>\n<p>Huomaamme kuitenkin että muutos hajottaa sovelluksemme täysin:</p>\n<picture><img src=\"/static/1216f0a01360b09bc66aedec7f9b6d5e/14be6/30.png\" srcset=\"/static/1216f0a01360b09bc66aedec7f9b6d5e/4cce7/30.png 200w,\n/static/1216f0a01360b09bc66aedec7f9b6d5e/bae5f/30.png 400w,\n/static/1216f0a01360b09bc66aedec7f9b6d5e/14be6/30.png 800w,\n/static/1216f0a01360b09bc66aedec7f9b6d5e/1b35a/30.png 1200w,\n/static/1216f0a01360b09bc66aedec7f9b6d5e/9ee03/30.png 1600w,\n/static/1216f0a01360b09bc66aedec7f9b6d5e/a098b/30.png 1680w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Mistä on kyse? Tapahtumankäsittelijäksi on tarkoitus määritellä viite <em>funktioon</em>. Kun koodissa on</p>\n<pre><code class=\"language-react\">&#x3C;button onClick={this.asetaArvoon(0)}>\n</code></pre>\n<p>tapahtumankäsittelijäksi tulee määriteltyä <em>funktiokutsu</em>. Sekin on monissa tilanteissa ok, mutta ei nyt, nimittäin kun React suorittaa metodin <em>render</em>, se suorittaa kutsun <code>this.asetaArvoon(0)</code>. Kutsu aiheuttaa metodin <em>setState</em> kutsun. Tämä taas aiheuttaa uuden <em>render</em>-kutsun jne...</p>\n<p>Tässä tilanteessa meidän onkin käytettävä yleistä Javascriptin ja yleisemminkin funktionaalisen ohjelmoinnin kikkaa, eli määritellä <em>funktio joka palauttaa funktion</em>:</p>\n<pre><code class=\"language-react\">class App extends React.Component {\n  constructor() {\n    super()\n    this.state = {\n      counter: 1\n    }\n  }\n\n  asetaArvoon = (arvo) => {\n    return () => {\n      this.setState({ counter: arvo })\n    }\n  }\n\n  render() {\n    return (\n      &#x3C;div>\n        &#x3C;div>{this.state.counter}&#x3C;/div>\n        &#x3C;div>\n          &#x3C;button onClick={this.asetaArvoon(this.state.counter + 1)}>\n            Plus\n          &#x3C;/button>\n          &#x3C;button onClick={this.asetaArvoon(0)}>\n            Zero\n          &#x3C;/button>\n        &#x3C;/div>\n      &#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<p>Jos et ole aiemmin törmännyt tekniikkaan, siihen totutteluun voi mennä tovi.</p>\n<p>Olemme siis määritelleet komponentin metodin <em>asetaArvoon</em> seuraavasti:</p>\n<pre><code class=\"language-js\">asetaArvoon = arvo => {\n  return () => {\n    this.setState({ counter: arvo });\n  };\n};\n</code></pre>\n<p>Kun <em>render</em>-metodissa määritellään tapahtumankäsittelijä kutsumalla <code>this.asetaArvoon(0)</code>, on lopputuloksena</p>\n<pre><code class=\"language-js\">() => {\n  this.setState({ counter: 0 });\n};\n</code></pre>\n<p>eli juuri oikeanlainen tilan nollaamisen aiheuttava funktio!</p>\n<p>Plus-napin tapahtumankäsittelijä määritellään kutsumalla <code>this.asetaArvoon(this.state.counter + 1)</code>. Kun komponentti renderöidään ensimmäisen kerran, <em>this.state.counter</em> on saanut konstruktorissa arvon 1, eli plus-napin tapahtumankäsittelijäksi tulee metodikutsun <code>this.asetaArvoon(1 + 1)</code> tulos, eli funktio</p>\n<pre><code class=\"language-js\">() => {\n  this.setState({ counter: 2 });\n};\n</code></pre>\n<p>Vastaavasti, kun laskurin tila on esim 41, tulee plus-napin tapahtumakuuntelijaksi</p>\n<pre><code class=\"language-js\">() => {\n  this.setState({ counter: 42 });\n};\n</code></pre>\n<p>Tarkastellaan vielä hieman metodia <em>asetaArvoon</em>:</p>\n<pre><code class=\"language-js\">asetaArvoon = arvo => {\n  return () => {\n    this.setState({ counter: arvo });\n  };\n};\n</code></pre>\n<p>Koska metodi itse sisältää ainoastaan yhden komennon, eli <em>returnin</em>, joka palauttaa funktion, voidaan hyödyntää nuolifunktion tiiviimpää muotoa:</p>\n<pre><code class=\"language-js\">asetaArvoon = arvo => () => {\n  this.setState({ counter: arvo });\n};\n</code></pre>\n<p>Usein tälläisissä tilanteissa kaikki kirjoitetaan samalle riville, jolloin tuloksena on \"kaksi nuolta sisältävä funktio\":</p>\n<pre><code class=\"language-js\">asetaArvoon = arvo => () => this.setState({ counter: arvo });\n</code></pre>\n<p>Kaksinuolisen funktion voi ajatella funktiona, jota lopullisen tuloksen saadakseen täytyy kutsua kaksi kertaa.</p>\n<p>Ensimmäisellä kutsulla \"konfiguroidaan\" varsinainen funktio, sijoittamalla osalle parametreista arvo. Eli kutsu <code>asetaArvoon(5)</code> sitoo muuttujaan <em>arvo</em> arvon 5 ja funktiosta \"jää jäljelle\" seuraava funktio:</p>\n<pre><code class=\"language-js\">() => this.setState({ counter: 5 });\n</code></pre>\n<p>Tässä näytetty tapa soveltaa funktioita palauttavia funktioita on oleellisesti sama asia mistä funktionaalisessa ohjelmoinnissa käytetään termiä <a href=\"http://www.datchley.name/currying-vs-partial-application/\">currying</a>. Termi currying ei ole lähtöisin funktionaalisen ohjelmoinnin piiristä vaan sillä on juuret <a href=\"https://en.wikipedia.org/wiki/Currying\">syvällä matematiikassa</a>.</p>\n<p>Jo muutamaan kertaan mainittu termi <em>funktionaalinen ohjelmointi</em> ei ole välttämättä kaikille tässä vaiheessa tuttu. Asiaa avataan hiukan kurssin kuluessa, sillä React tukee ja osin edellyttää funktionaalisen tyylin käyttöä.</p>\n<p><strong>HUOM:</strong> muutos, missä korvasimme metodit <em>kasvataArvoa</em> ja <em>nollaa</em> metodilla <em>asetaArvoon</em> ei välttämättä ole järkevä, sillä erikoistuneemmat metodit ovat paremmin nimettyjä. Teimme muutoksen oikeastaan ainoastaan demonstroidaksemme <em>currying</em>-tekniikan soveltamista.</p>\n<h3>Tilan vieminen alikomponenttiin</h3>\n<p>Reactissa suositaan pieniä komponentteja, joita on mahdollista uusiokäyttää monessa osissa sovellusta ja jopa useissa eri sovelluksissa. Refaktoroidaan koodiamme vielä siten, että yhden komponentin sijaan koostamme laskurin näytöstä ja kahdesta painikkeesta.</p>\n<p>Tehdään ensin näytöstä vastaava komponentti <em>Display</em>.</p>\n<p>Reactissa parhaana käytänteenä on sijoittaa tila <a href=\"https://reactjs.org/docs/lifting-state-up.html\">mahdollisimman ylös</a> komponenttihierarkiassa, mielellään sovelluksen juurikomponenttiin.</p>\n<p>Jätetään sovelluksen tila, eli laskimen arvo komponenttiin <em>App</em> ja välitetään tila <em>props</em>:ien avulla komponentille <em>Display</em>:</p>\n<pre><code class=\"language-react\">const Display = (props) => {\n  return (\n    &#x3C;div>{props.counter}&#x3C;/div>\n  )\n}\n</code></pre>\n<p>Kyseessä on siis todella yksinkertainen komponentti joka kannattaa ehdottomasti määritellä funktion avulla eli funktionaalisena komponenttina.</p>\n<p>Voimme hyödyntää aiemmin mainittua <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\">destrukturointia</a> myös metodien parametreissa. Eli koska olemme kiinnostuneita <em>props</em>:in kentästä <em>counter</em>, on edellinen mahdollista yksinkertaistaa seuraavaan muotoon:</p>\n<pre><code class=\"language-react\">const Display = ({ counter }) => {\n  return (\n    &#x3C;div>{counter}&#x3C;/div>\n  )\n}\n</code></pre>\n<p>Koska komponentin määrittelevä metodi ei sisällä muuta kuin returnin, voimme ilmaista sen hyödyntäen nuolifunktioiden tiiviimpää ilmaisumuotoa</p>\n<pre><code class=\"language-react\">const Display = ({ counter }) => &#x3C;div>{counter}&#x3C;/div>\n</code></pre>\n<p>Komponentin käyttö on suoraviivaista, riittää että sille välitetään laskurin tila eli <em>this.state.counter</em>:</p>\n<pre><code class=\"language-react\">class App extends React.Component {\n  // ...\n  render() {\n    return (\n      &#x3C;div>\n        &#x3C;Display counter={this.state.counter}/>\n        &#x3C;div>\n          &#x3C;button onClick={this.asetaArvoon(this.state.counter+1)}>\n            Plus\n          &#x3C;/button>\n          &#x3C;button onClick={this.asetaArvoon(0)}>\n            Zero\n          &#x3C;/button>\n        &#x3C;/div>\n      &#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<p>Kaikki toimii edelleen. Kun nappeja painetaan ja <em>App</em> renderöityy uudelleen, renderöityvät myös kaikki sen alikomponentit, siis myös <em>Display</em> automaattisesti uudelleen.</p>\n<p>Tehdään seuraavaksi napeille tarkoitettu komponentti <em>Button</em>. Napille on välitettävä propsien avulla tapahtumankäsittelijä sekä napin teksti:</p>\n<pre><code class=\"language-react\">const Button = (props) => (\n  &#x3C;button onClick={props.handleClick}>\n    {props.text}\n  &#x3C;/button>\n)\n</code></pre>\n<p>ja hyödynnetään taas destrukturointia ottamaan <em>props</em>:in tarpeelliset kentät suoraan:</p>\n<pre><code class=\"language-react\">const Button = ({ handleClick, text }) => (\n  &#x3C;button onClick={handleClick}>\n    {text}\n  &#x3C;/button>\n)\n</code></pre>\n<p>Komponentin <em>App</em> metodi <em>render</em> muuttuu nyt muotoon:</p>\n<pre><code class=\"language-react\">render() {\n  return (\n    &#x3C;div>\n      &#x3C;Display counter={this.state.counter}/>\n      &#x3C;div>\n        &#x3C;Button\n          handleClick={this.asetaArvoon(this.state.counter + 1)}\n          text=\"Plus\"\n        />\n        &#x3C;Button\n          handleClick={this.asetaArvoon(this.state.counter - 1)}\n          text=\"Minus\"\n        />\n        &#x3C;Button\n          handleClick={this.asetaArvoon(0)}\n          text=\"Zero\"\n        />\n      &#x3C;/div>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Koska meillä on nyt uudelleenkäytettävä nappi, sovellukselle on lisätty uutena toiminnallisuutena nappi, jolla laskurin arvoa voi vähentää.</p>\n<p>Tapahtumankäsittelijä välitetään napeille propsin <em>handleClick</em> välityksellä. Propsin nimellä ei ole sinänsä merkitystä, mutta valinta ei ollut täysin sattumanvarainen, esim. Reactin <a href=\"https://reactjs.org/tutorial/tutorial.html\">tutoriaali</a> suosittelee tätä konventiota.</p>\n<h3>Monimutkaisemman tilan päivittäminen</h3>\n<p>Tarkastellaan sovellusta, jonka tila on hieman monimutkaisempi:</p>\n<pre><code class=\"language-react\">class App extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      vasen: 0,\n      oikea: 0\n    }\n  }\n\n  klikVasen = () => {\n    this.setState({\n      vasen: this.state.vasen + 1\n    })\n  }\n\n  klikOikea = () => {\n    this.setState({\n      oikea: this.state.oikea + 1\n    })\n  }\n\n  render() {\n    return (\n      &#x3C;div>\n        &#x3C;div>\n          {this.state.vasen}\n          &#x3C;button onClick={this.klikVasen}>vasen&#x3C;/button>\n          &#x3C;button onClick={this.klikOikea}>oikea&#x3C;/button>\n          {this.state.oikea}\n        &#x3C;/div>\n      &#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<p>Tilassa on siis kaksi kenttää, <em>vasen</em> ja <em>oikea</em> jotka laskevat vastaavien nappien painalluksia.</p>\n<p>Kun tilaa päivitetään, riittää asettaa ainoastaan muuttuvan kentän arvo, sillä React <a href=\"https://reactjs.org/docs/state-and-lifecycle.html#state-updates-are-merged\">lomittaa</a> tai \"mergeää\" muutokset olemassaolevaan tilaan.</p>\n<p>Eli kun päivitämme esim. vasemman napin painalluksia, riittää seuraava koodi</p>\n<pre><code class=\"language-js\">klikVasen = () => {\n  this.setState({\n    vasen: this.state.vasen + 1,\n  });\n};\n</code></pre>\n<p>tilassa oleva kenttä <em>oikea</em> jää muutoksen yhteydessä ennalleen.</p>\n<h3>Taulukon käsittelyä</h3>\n<p>Tehdään sovellukseen vielä laajennus, lisätään tilaan taulukko <em>kaikki</em> joka muistaa kaikki näppäimenpainallukset.</p>\n<pre><code class=\"language-react\">class App extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      vasen: 0,\n      oikea: 0,\n      kaikki: []\n    }\n  }\n\n  klikVasen = () => {\n    this.setState({\n      vasen: this.state.vasen + 1,\n      kaikki: this.state.kaikki.concat('v')\n    })\n  }\n\n  klikOikea = () => {\n    this.setState({\n      oikea: this.state.oikea + 1,\n      kaikki: this.state.kaikki.concat('o')\n    })\n  }\n\n  render() {\n    const historia = () => this.state.kaikki.join(' ')\n    return (\n      &#x3C;div>\n        &#x3C;div>\n          {this.state.vasen}\n          &#x3C;button onClick={this.klikVasen}>vasen&#x3C;/button>\n          &#x3C;button onClick={this.klikOikea}>oikea&#x3C;/button>\n          {this.state.oikea}\n          &#x3C;div>{historia()}&#x3C;/div>\n        &#x3C;/div>\n      &#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<p>Kun esim. nappia <em>vasen</em> painetaan, lisätään tilan taulukkoon <em>kaikki</em> kirjain <em>v</em>:</p>\n<pre><code class=\"language-js\">klikVasen = () => {\n  this.setState({\n    vasen: this.state.vasen + 1,\n    kaikki: this.state.kaikki.concat('v'),\n  });\n};\n</code></pre>\n<p>Tilan kenttä <em>kaikki</em> saa nyt arvokseen entisen tilan, mihin on liitetty <em>v</em> metodilla <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat\">concat</a>, joka toimii siten, että se ei muuta olemassaolevaa taulukkoa vaan luo <em>uuden taulukon</em>, mihin uusi alkio on lisätty.</p>\n<p>Javascriptissa on myös mahdollista lisätä taulukkoon metodilla <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push\">push</a> ja sovellus näyttäisi tässä tilanteessa toimivan myös jos lisäys tapahtuisi komennolla</p>\n<pre><code class=\"language-js\">kaikki: this.state.kaikki.push('v');\n</code></pre>\n<p>mutta älä tee niin. React-komponentin tilaa, eli muuttujaa <em>this.state</em> ei saa muuttaa suoraan!</p>\n<p><strong>Jos tilan kentissä on olioita, älä muuta niitä vaan tee muutos aina kopioon!</strong></p>\n<p>Katsotaan vielä tarkemmin, miten kaikkien painallusten historia renderöidään ruudulle:</p>\n<pre><code class=\"language-react\">render() {\n  const historia = () => this.state.kaikki.join(' ')\n  return (\n    &#x3C;div>\n      &#x3C;div>\n        {this.state.vasen}\n        &#x3C;button onClick={this.klikVasen}>vasen&#x3C;/button>\n        &#x3C;button onClick={this.klikOikea}>oikea&#x3C;/button>\n        {this.state.oikea}\n        &#x3C;div>{historia()}&#x3C;/div>\n      &#x3C;/div>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Metodiin <em>render</em> on nyt määritelty apufunktio:</p>\n<pre><code class=\"language-react\">const historia = () => this.state.kaikki.join(' ')\n</code></pre>\n<p>Taulukon <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join\">join</a>-metodilla muodostetaan taulukosta merkkijono, joka sisältää taulukon alkiot erotettuina välilyönnillä.</p>\n<h3>Ehdollinen renderöinti</h3>\n<p>Muutetaan apufunktiota hiukan:</p>\n<pre><code class=\"language-react\">const historia = () => {\n  if (this.state.kaikki.length === 0) {\n    return (\n      &#x3C;div>\n        &#x3C;em>sovellusta käytetään nappeja painelemalla&#x3C;/em>\n      &#x3C;/div>\n    )\n  }\n  return (\n    &#x3C;div>\n      näppäilyhistoria: {this.state.kaikki.join(' ')}\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Nyt funktion palauttama sisältö riippuu siitä, onko näppäimiä jo painettu. Jos ei, eli taulukko <code>this.state.kaikki</code> on tyhjä, palauttaa metodi \"käyttöohjeen\" sisältävän elementin</p>\n<pre><code class=\"language-html\">&#x3C;div>&#x3C;em>sovellusta käytetään nappeja painelemalla&#x3C;/em>&#x3C;/div>\n</code></pre>\n<p>ja muussa tapauksessa näppäilyhistorian:</p>\n<pre><code class=\"language-html\">&#x3C;div>näppäilyhistoria: {this.state.kaikki.join(' ')}&#x3C;/div>\n</code></pre>\n<p>Komponentin <em>App</em> ulkoasun muodostamat React-elementit siis ovat erilaisia riippuen sovelluksen tilasta, eli komponentissa on <em>ehdollista renderöintiä</em>.</p>\n<p>Reactissa on monia muitakin tapoja <a href=\"https://reactjs.org/docs/conditional-rendering.html\">ehdolliseen renderöintiin</a>. Katsotaan niitä tarkemmin <a href=\"/osa2\">seuraavassa osassa</a>.</p>\n<p>Näppäilyhistorian esittäminen alkaa olla jo sen verran monimutkainen operaatio, että se kannattaisi eristää omaksi komponentikseen. Jätämme sen kuitenkin tekemättä.</p>\n<h2>Funktionaalinen vai luokkasyntaksiin perustuva komponentti?</h2>\n<p>Olemme nyt esitelleet kaksi erilaista tapaa komponenttien määrittelemiseen. Kumpaa tulisi käyttää? Useimpien vastauksena on, <a href=\"https://hackernoon.com/react-stateless-functional-components-nine-wins-you-might-have-overlooked-997b0d933dbc\">käytä funktionaalista komponenttia aina kun se on mahdollista</a>.</p>\n<p>Jos komponentti tarvitsee tilaa, on luokkasyntaksin käyttäminen välttämätöntä. Kannattaa kuitenkin muistaa, että Reactin filosofian mukaista on sijoittaa tila <a href=\"https://reactjs.org/docs/lifting-state-up.html\">mahdollisimman ylös</a> komponenttihierarkiaan, mielellään ainoastaan sovelluksen juurikomponenttiin. Näin tilallisten komponenttien potentiaalinen tarvekin on vähäisempi.</p>\n<p>Joskus komponenttien on käytettävä <a href=\"/osa2#komponenttien-lifecycle-metodit\">osassa 2 esiteltäviä</a> lifecycle-metodeja, myös niissä tapauksissa on pakko käyttää luokkiin perustuvia komponentteja.</p>\n<p>Yleisohjeena on siis se, että käytä funktionaalisia komponentteja ellet aivan pakosti tarvitse jotain luokkasyntaksin omaavien komponenttien ominaisuuksia.</p>\n<p>Internetistä löytyy kyllä aiheesta päinvastaisiakin mielipiteitä, esim. <a href=\"https://medium.freecodecamp.org/7-reasons-to-outlaw-reacts-functional-components-ff5b5ae09b7c\">7 Reasons to Outlaw React’s Functional Components</a></p>\n<h2>React-sovellusten debuggaus</h2>\n<p>Ohjelmistokehittäjän elämä koostuu pääosin debuggaamisesta (ja olemassaolevan koodin lukemisesta). Silloin tällöin syntyy toki muutama rivi uuttakin koodia, mutta suuri osa ajasta ihmetellään miksi joku on rikki tai miksi joku asia ylipäätään toimii. Hyvät debuggauskäytänteet ja työkalut ovatkin todella tärkeitä.</p>\n<p>Onneksi React on debuggauksen suhteen jopa harvinaisen kehittäjäystävällinen kirjasto.</p>\n<p>Muistutetaan vielä tärkeimmästä web-sovelluskehitykseen liittyvästä asiasta:</p>\n<div class=\"important\">\n  <h3>Web-sovelluskehityksen sääntö numero yksi</h3>\n  <div>Pidä selaimen developer-konsoli koko ajan auki.</div>\n  <br />\n  <div>Välilehdistä tulee olla auki nimenomaan <em>Console</em> jollei ole erityistä syytä käyttää jotain muuta välilehteä.\n  </div>\n</div>\n<p>Pidä myös koodi ja web-sivu <strong>koko ajan</strong> molemmat yhtä aikaa näkyvillä.</p>\n<p>Jos ja kun koodi ei käänny, eli selaimessa alkaa näkyä punaista</p>\n<picture><img src=\"/static/18270e38776d63a180eaa5d0e835c47b/14be6/31.png\" srcset=\"/static/18270e38776d63a180eaa5d0e835c47b/4cce7/31.png 200w,\n/static/18270e38776d63a180eaa5d0e835c47b/bae5f/31.png 400w,\n/static/18270e38776d63a180eaa5d0e835c47b/14be6/31.png 800w,\n/static/18270e38776d63a180eaa5d0e835c47b/1b35a/31.png 1200w,\n/static/18270e38776d63a180eaa5d0e835c47b/1069f/31.png 1570w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>älä kirjota enää lisää koodia vaan selvitä ongelma <strong>välittömästi</strong>. Koodauksen historia ei tunne tilannetta, missä kääntymätön koodi alkaisi ihmeenomaisesti toimimaan kirjoittamalla suurta määrää lisää koodia, en usko että sellaista ihmettä nähdään tälläkään kurssilla.</p>\n<p>Vanha kunnon printtaukseen perustuva debuggaus kannattaa aina. Eli jos esim. komponentissa</p>\n<pre><code class=\"language-react\">const Button = ({ handleClick, text }) => (\n  &#x3C;button onClick={handleClick}>\n    {text}\n  &#x3C;/button>\n)\n</code></pre>\n<p>olisi jotain ongelmia, kannattaa komponentista alkaa printtailla konsoliin. Pystyäksemme printtaamaan, tulee funktio muuttaa pitempään muotoon ja propsit kannattaa kenties vastaanottaa ilman destrukturointia:</p>\n<pre><code class=\"language-react\">const Button = (props) => {\n  console.log(props)\n  const { handleClick, text } = props\n  return (\n    &#x3C;button onClick={handleClick}>\n      {text}\n    &#x3C;/button>\n  )\n}\n</code></pre>\n<p>näin selviää heti onko esim. joku propsia vastaava attribuutti nimetty väärin komponenttia käytettäessä.</p>\n<p><strong>HUOM</strong> kun käytät komentoa <em>console.log</em> debuggaukseen, älä yhdistele asioita \"javamaisesti\" plussalla, eli sen sijaan että kirjoittaisit</p>\n<pre><code class=\"language-js\">console.log('propsin arvo on' + props);\n</code></pre>\n<p>erottele tulostettavat asiat pilkulla:</p>\n<pre><code class=\"language-js\">console.log('propsin arvo on', props);\n</code></pre>\n<p>Jos yhdistät merkkijonoon olion, tuloksena on suhteellisen hyödytön tulostusmuoto</p>\n<pre><code class=\"language-bash\">propsin arvo on [Object object]\n</code></pre>\n<p>kun taas pilkulla tulostettavat asiat erotellessa saat developer-konsoliin olion, jonka sisältöä on mahdollista tarkastella.</p>\n<p>Koodin suorituksen voi pysäyttää chromen developer konsolin debuggeriin kirjoittamalla mihin tahansa kohtaa koodia komennon <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger\">debugger</a>.</p>\n<p>Koodi pysähtyy kun suoritus etenee sellaiseen pisteeseen, että komento <em>debugger</em> suoritetaan:</p>\n<picture><img src=\"/static/167e2809b58a918d3712bc3f3bde44f4/14be6/32.png\" srcset=\"/static/167e2809b58a918d3712bc3f3bde44f4/4cce7/32.png 200w,\n/static/167e2809b58a918d3712bc3f3bde44f4/bae5f/32.png 400w,\n/static/167e2809b58a918d3712bc3f3bde44f4/14be6/32.png 800w,\n/static/167e2809b58a918d3712bc3f3bde44f4/1b35a/32.png 1200w,\n/static/167e2809b58a918d3712bc3f3bde44f4/9ee03/32.png 1600w,\n/static/167e2809b58a918d3712bc3f3bde44f4/a6552/32.png 1778w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Menemällä välilehdelle <em>Console</em> on helppo tutkia muuttujien tilaa:</p>\n<picture><img src=\"/static/818bfabf9c172ac61a6a1ed04cfa839f/14be6/33.png\" srcset=\"/static/818bfabf9c172ac61a6a1ed04cfa839f/4cce7/33.png 200w,\n/static/818bfabf9c172ac61a6a1ed04cfa839f/bae5f/33.png 400w,\n/static/818bfabf9c172ac61a6a1ed04cfa839f/14be6/33.png 800w,\n/static/818bfabf9c172ac61a6a1ed04cfa839f/1b35a/33.png 1200w,\n/static/818bfabf9c172ac61a6a1ed04cfa839f/9ee03/33.png 1600w,\n/static/818bfabf9c172ac61a6a1ed04cfa839f/dd788/33.png 1632w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Kun bugi selviää, voi komennon <em>debugger</em> poistaa ja uudelleenladata sivun.</p>\n<p>Debuggerissa on mahdollista suorittaa koodia tarvittaessa rivi riviltä <em>Source</em> välilehden oikealta laidalta.</p>\n<p>Debuggeriin pääsee myös ilman komentoa <em>debugger</em> lisäämällä <em>Source</em>-välilehdellä sopiviin kohtiin koodia <em>breakpointeja</em>. Haluttujen muuttujien arvojen tarkkailu on mahdollista määrittelemällä ne <em>Watch</em>-osassa:</p>\n<picture><img src=\"/static/4f7c09049d9ada807b3d2864c7b01bae/14be6/34.png\" srcset=\"/static/4f7c09049d9ada807b3d2864c7b01bae/4cce7/34.png 200w,\n/static/4f7c09049d9ada807b3d2864c7b01bae/bae5f/34.png 400w,\n/static/4f7c09049d9ada807b3d2864c7b01bae/14be6/34.png 800w,\n/static/4f7c09049d9ada807b3d2864c7b01bae/1b35a/34.png 1200w,\n/static/4f7c09049d9ada807b3d2864c7b01bae/9ee03/34.png 1600w,\n/static/4f7c09049d9ada807b3d2864c7b01bae/6b9c5/34.png 1612w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Chromeen kannattaa ehdottomasti asentaa <a href=\"https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi\">React developer tools</a> -lisäosa, joka tuo konsoliin uuden tabin <em>React</em>:</p>\n<picture><img src=\"/static/71448901a59a141227a6b67f7a53ffa2/14be6/35.png\" srcset=\"/static/71448901a59a141227a6b67f7a53ffa2/4cce7/35.png 200w,\n/static/71448901a59a141227a6b67f7a53ffa2/bae5f/35.png 400w,\n/static/71448901a59a141227a6b67f7a53ffa2/14be6/35.png 800w,\n/static/71448901a59a141227a6b67f7a53ffa2/1b35a/35.png 1200w,\n/static/71448901a59a141227a6b67f7a53ffa2/9ee03/35.png 1600w,\n/static/71448901a59a141227a6b67f7a53ffa2/a9b85/35.png 1748w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Uuden konsolitabin avulla voidaan tarkkailla sovelluksen React-elementtejä ja niiden tilaa (eli this.state:a) ja propseja.</p>\n<h2>Tapahtumankäsittely revisited</h2>\n<p>Pajan ja telegrammin havaintojen perusteella tapahtumankäsittely on osoittautunut haastavaksi.</p>\n<p>Tarkastellaan asiaa vielä uudelleen.</p>\n<p>Oletetaan, että käytössä on äärimmäisen yksinkertainen sovellus:</p>\n<pre><code class=\"language-bash\">class App extends React.Component {\n  constructor() {\n    super()\n    this.state = {\n      value: 10\n    }\n  }\n  render(){\n    return (\n      &#x3C;div>\n        {this.state.value}\n        &#x3C;button>nollaa&#x3C;/button>\n      &#x3C;/div>\n    )\n  }\n}\n\nReactDOM.render(\n  &#x3C;App />,\n  document.getElementById('root')\n)\n</code></pre>\n<p>Haluamme, että napin avulla tilassa oleva <em>value</em> saadaan nollattua.</p>\n<p>Jotta saamme napin reagoimaan, on sille lisättävä <em>tapahtumankäsittelijä</em>.</p>\n<p>Tapahtumankäsittelijän tulee aina olla <em>funktio</em>. Jos tapahtumankäisttelijän paikalle yritetään laittaa jotain muuta, ei nappi toimi.</p>\n<p>Jos esim. antaisimme tapahtumankäsittelijäksi merkkijonon:</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={\"roskaa\"}>nappi&#x3C;/button>\n</code></pre>\n<p>React varoittaa asiasta konsolissa</p>\n<pre><code class=\"language-bash\">index.js:2178 Warning: Expected `onClick` listener to be a function, instead got a value of `string` type.\n    in button (at index.js:20)\n    in div (at index.js:18)\n    in App (at index.js:27)\n</code></pre>\n<p>eli esim. seuraavanlainen yritys olisi tuhoon tuomittu</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={this.state.value+1}>nappi&#x3C;/button>\n</code></pre>\n<p>nyt tapahtumankäsittelijäksi on yritetty laittaa <em>this.state.value+1</em> mikä tarkoittaa laskuoperaation tulosta. React varoittaa tästäkin konsolissa</p>\n<pre><code class=\"language-bash\">index.js:2178 Warning: Expected `onClick` listener to be a function, instead got a value of `number` type.\n</code></pre>\n<p>Myöskään seuraava ei toimi</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={this.state.value = 0}>nappi&#x3C;/button>\n</code></pre>\n<p>taaskaan tapahtumankäsittelijänä ei ole funktio vaan sijoitusoperaatio. Konsoliin tulee valitus. Tämä tapa on myös toisella tavalla väärin. Kuten on jo mainittu, reactin tilaa <em>ei saa muuttaa suoraan</em>, vaan ainoastaan funktion setState-avulla.</p>\n<p>Entä seuraava:</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={console.log('nappia painettu')}>nappi&#x3C;/button>\n</code></pre>\n<p>konsoliin tulostuu kertaalleen <em>nappia painettu</em>, mutta nappia painellessa ei tapahdu mitään. Miksi tämä ei toimi vaikka tapahtumankäsittelijänä on nyt funktio <em>console.log</em>?</p>\n<p>Ongelma on nyt siinä, että tapahtumankäsittelijänä on funktion kutsu, eli varsinaiseksi tapahtumankäsittelijäksi tulee funktion kutsun paluuarvo, joka on tässä tapauksessa <em>undefined</em>.</p>\n<p>Funktiokutsu <em>console.log('nappia painettu')</em> suoritetaan siinä vaiheessa kun komponentti renderöidään, ja tämän takia konsoliin tulee tulostus kertalleen.</p>\n<p>Myös seuraava yritys on virheellinen</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={this.setState({value: 0})}>nappi&#x3C;/button>\n</code></pre>\n<p>jälleen olemme yrittäneet laittaa tapahtumankäsittelijäksi funktiokutsun. Ei toimi. Tämä yritys aiheuttaa myös toisen ongelman. Kun komponenttia renderöidään, suoritetaan tapahtumankäsittelijänä oleva funktiokutsu <em>this.setState({value: 0})</em> joka taas saa aikaan komponentin uudelleenrenderöinnin. Ja uudelleenrenderöinnin yhteydessä funktiota kutsutaan uudelleen käynnistäen jälleen uusi uudelleenrenderöinti, ja joudutaan päättymättömään rekursioon.</p>\n<p>Jos haluamme tietyn funktiokutsun tapahtuvan nappia painettaessa, toimii seuraava</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={() => console.log('nappia painettu')}>nappi&#x3C;/button>\n</code></pre>\n<p>Nyt tapahtumankäsittelijä on nuolisyntaksilla määritelty funktio <em>() => console.log('nappia painettu')</em>. Kun komponentti renderöidään, ei suoriteta mitään, ainoastaan talletetaan funktioviite tapahtumankäsittelijäksi. Itse funktion suoritus tapahtuu vasta napin painallusten yhteydessä.</p>\n<p>Saamme myös nollauksen toimimaan samalla tekniikalla</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={() => this.setState({value: 0})}>nappi&#x3C;/button>\n</code></pre>\n<p>eli nyt tapahtumankäsittelijä on funktio <em>() => this.setState({value: 0})</em>.</p>\n<p>Tapahtumakäsittelijäfunktioiden määrittely suoraan napin määrittelyn yhteydessä ei välttämättä ole paras mahdollinen idea.</p>\n<p>Usein tapahtumankäsittelijä määritelläänkin jossain muualla. Seuraavassa määritellään funktio metodin render alussa ja sijoitetaan se muuttujaan <em>handler</em>:</p>\n<pre><code class=\"language-react\">render() {\n  const handler = () => console.log('nappia painettu')\n\n  return (\n    &#x3C;div>\n      {this.state.value}\n      &#x3C;button onClick={handler}>nappi&#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Muuttujassa <em>handler</em> on nyt talletettuna viite itse funktioon. Viite annetaan napin määrittelyn yhteydessä</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={handler}>nappi&#x3C;/button>\n</code></pre>\n<p>Tapahtumankäsittelijäfunktio voi luonnollisesti koostua useista komennoista, tällöin käytetään nuolifunktion aaltosulullista muotoa:</p>\n<pre><code class=\"language-react\">render() {\n  const handler = () => {\n    console.log('nappia painettu')\n    this.setState({ value: 0 })\n  }\n\n  return (\n    &#x3C;div>\n      {this.state.value}\n      &#x3C;button onClick={handler}>nappi&#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Joissain tilanteissa tapahtumankäsittelijät kannattaa määritellä komponentin metodeina:</p>\n<pre><code class=\"language-react\">class App extends React.Component {\n  // ...\n\n  handler = () => {\n    console.log('nappia painettu')\n    this.setState({ value: 0 })\n  }\n\n  render() {\n    return (\n      &#x3C;div>\n        {this.state.value}\n        &#x3C;button onClick={this.handler}>nappi&#x3C;/button>\n      &#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<p>Koska <em>handler</em> on nyt komponentin metodi, päästään siihen käsiksi viitteen <em>this</em> avulla:</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={this.handler}>nappi&#x3C;/button>\n</code></pre>\n<p>Mennään lopuksi funktioita palauttavaan funktioon.</p>\n<p>Muutetaan koodia seuraavasti</p>\n<pre><code class=\"language-react\">render() {\n  const hello = () => {\n    const handler = () => console.log('hello world')\n\n    return handler\n  }\n\n  return (\n    &#x3C;div>\n      {this.state.value}\n      &#x3C;button onClick={hello()}>nappi&#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Koodi näyttää hankalalta mutta se ihme kyllä toimii.</p>\n<p>Tapahtumankäsittelijäksi on nyt \"rekisteröity\" funktiokutsu:</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={hello()}>nappi&#x3C;/button>\n</code></pre>\n<p>Aiemmin varoteltiin, että tapahtumankäsittelijä ei saa olla funktiokutsu vaan sen on oltava funktio tai viite funktioon. Miksi funktiokutsu kuitenkin toimii nyt?</p>\n<p>Kun komponenttia renderöidään suoritetaan seuraava funktio:</p>\n<pre><code class=\"language-react\">const hello = () => {\n  const handler = () => console.log('hello world')\n\n  return handler\n}\n</code></pre>\n<p>funktion <em>paluuarvona</em> on nyt toinen, muuttujaan <em>handler</em> määritelty funktio.</p>\n<p>eli kun react renderöi seuraavan rivin</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={hello()}>nappi&#x3C;/button>\n</code></pre>\n<p>sijoittaa se onClick-käsittelijäksi funktiokutsun <em>hello()</em> paluuarvon. Eli oleellisesti ottaen rivi \"muuttuu\" seuraavaksi</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={() => console.log('hello world')}>nappi&#x3C;/button>\n</code></pre>\n<p>koska funktio <em>hello</em> palautti funktion, on tapahtumankäsittelijä nyt funktio.</p>\n<p>Mitä järkeä tässä konseptissa on?</p>\n<p>Muutetaan koodia hiukan:</p>\n<pre><code class=\"language-bash\">render() {\n  const hello = (who) => {\n    const handler = () => { \n      console.log('hello', who)\n    }\n\n    return handler\n  }\n\n  return (\n    &#x3C;div>\n      {this.state.value}\n      &#x3C;button onClick={hello('world')}>nappi&#x3C;/button>\n      &#x3C;button onClick={hello('react')}>nappi&#x3C;/button>\n      &#x3C;button onClick={hello('function')}>nappi&#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Nyt meillä on kolme nappia joiden tapahtumankäsittelijät määritellään parametrin saavan funktion <em>hello</em> avulla.</p>\n<p>Ensimmäinen nappi määritellään seuraavasti</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={hello('world')}>nappi&#x3C;/button>\n</code></pre>\n<p>Tapahtumankäsittelijä siis saadaan <em>suorittamalla</em> funktiokutsu <em>hello('world')</em>. Funktiokutsu palauttaa funktion</p>\n<pre><code class=\"language-bash\">() => { \n  console.log('hello', 'world')\n}\n</code></pre>\n<p>Toinen nappi määritellään seuraavasti</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={hello('react')}>nappi&#x3C;/button>\n</code></pre>\n<p>Tapahtumankäsittelijän määrittelevä funktiokutsu <em>hello('react')</em> palauttaa</p>\n<pre><code class=\"language-bash\">() => { \n  console.log('hello', 'react')\n}\n</code></pre>\n<p>eli nappi saa oman yksilöllisen tapahtumankäsittelijänsä.</p>\n<p>Funktioita palauttavia funktioita voikin hyödyntää määrittelemään geneeristä toiminnallisuutta, jota voi tarkentaa parametrien avulla. Tapahtumankäsittelijöitä luovan funktion <em>hello</em> voikin ajatella olevan eräänlainen tehdas, jota voi pyytää valmistamaan sopivia tervehtimiseen tarkoitettuja tapahtumankäsittelijäfunktioita.</p>\n<p>Käyttämämme määrittelytapa</p>\n<pre><code class=\"language-bash\">const hello = (who) => {\n  const handler = () => { \n    console.log('hello', who)\n  }\n\n  return handler\n}\n</code></pre>\n<p>on hieman verboosi. Eliminoidaan apumuuttuja, ja määritellään palautettava funktio suoraan returnin yhteydessä:</p>\n<pre><code class=\"language-bash\">const hello = (who) => {\n  return () => { \n    console.log('hello', who)\n  }\n}\n</code></pre>\n<p>ja koska funktio <em>hello</em> sisältää ainoastaan yhden komennon, eli returnin, voidaan käyttää aaltosulutonta muotoa</p>\n<pre><code class=\"language-bash\">const hello = (who) =>\n  () => { \n    console.log('hello', who)\n  }\n</code></pre>\n<p>ja tuodaan vielä \"kaikki nuolet\" samalle riville</p>\n<pre><code class=\"language-bash\">const hello = (who) => () => { \n  console.log('hello', who)\n}\n</code></pre>\n<p>Voimme käyttää samaa kikkaa myös muodostamaan tapahtumankäsittelijöitä, jotka asettavat komponentin tilalle halutun arvon. Muutetaan koodi muotoon:</p>\n<pre><code class=\"language-bash\">render() {\n  const setToValue = (newValue) => () => { \n    this.setState({ value: newValue })\n  }\n\n  return (\n    &#x3C;div>\n      {this.state.value}\n      &#x3C;button onClick={setToValue(1000)}>tuhat&#x3C;/button>\n      &#x3C;button onClick={setToValue(0)}>nollaa&#x3C;/button>\n      &#x3C;button onClick={setToValue(this.state.value+1)}>kasvata&#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Kun komponentti renderöidään, ja tehdään nappia tuhat</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={setToValue(1000)}>tuhat&#x3C;/button>\n</code></pre>\n<p>tulee tapahtumankäsittelijäksi funktiokutsun <em>setToValue(1000)</em> paluuarvo eli seuraava funktio</p>\n<pre><code class=\"language-bash\">() => { \n  this.setState({ value: 1000 })\n}\n</code></pre>\n<p>Kasvatusnapin generoima rivi on seuraava</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={setToValue(this.state.value+1)}>kasvata&#x3C;/button>\n</code></pre>\n<p>Tapahtumankäsittelijän muodostaa funktiokutsu <em>setToValue(this.state.value+1)</em>, joka saa parametrikseen tilan kentän <em>value</em> nykyisen arvon kasvatettuna yhdellä. Jos <em>this.state.value</em> olisi 10, tulisi tapahtumankäsittelijäksi funktio</p>\n<pre><code class=\"language-bash\">() => { \n  this.setState({ value: 11 })\n}\n</code></pre>\n<h3>Hyödyllistä materiaalia</h3>\n<p>Internetissä on todella paljon Reactiin liittyvää materiaalia, tässä muutamia linkkejä:</p>\n<ul>\n<li>Reactin <a href=\"https://reactjs.org/docs/hello-world.html\">docs</a> kannattaa ehdottomasti käydä läpi, ei välttämättä kaikkea nyt, osa on ajankohtaista vasta kurssin myöhemmissä osissa</li>\n<li>Reactin sivuilla oleva <a href=\"https://reactjs.org/tutorial/tutorial.html\">tutoriaali</a> sen sijaan on aika huono</li>\n<li><a href=\"https://egghead.io\">Egghead.io</a>:n kursseista <a href=\"https://egghead.io/courses/start-learning-react\">Start learning React</a> on laadukas, ja hieman uudempi <a href=\"https://egghead.io/courses/the-beginner-s-guide-to-reactjs\">The Beginner's guide to React</a> on myös kohtuullisen hyvä; molemmat sisältävät myös asioita jotka tulevat tällä kurssilla vasta myöhemmissä osissa.</li>\n</ul>\n</div>\n<div class=\"tasks\">\n  <h3>Tehtävät 1.6</h3>\n  <h4>unicafe osa1</h4>\n<p>Monien firmojen tapaan nykyään myös <a href=\"https://www.unicafe.fi/#/9/4\">Unicafe</a> kerää asiakaspalautetta. Tee Unicafelle verkossa toimiva palautesovellus. Vastausvaihtoehtoja olkoon vain kolme: <i>hyvä</i>, <i>neutraali</i> ja <i>huono</i>.</p>\n<p>Sovelluksen tulee näyttää jokaisen palautteen lukumäärä. Sovellus voi näyttää esim. seuraavalta:</p>\n<picture><img src=\"/static/41cc3de89532b4d79fa7700e66e333fb/14be6/4c.png\" srcset=\"/static/41cc3de89532b4d79fa7700e66e333fb/4cce7/4c.png 200w,\n/static/41cc3de89532b4d79fa7700e66e333fb/bae5f/4c.png 400w,\n/static/41cc3de89532b4d79fa7700e66e333fb/14be6/4c.png 800w,\n/static/41cc3de89532b4d79fa7700e66e333fb/1b35a/4c.png 1200w,\n/static/41cc3de89532b4d79fa7700e66e333fb/0d767/4c.png 1460w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Huomaa, että sovelluksen tarvitsee toimia vain yhden selaimen käyttökerran ajan, esim. kun selain refreshataan, tilastot saavat hävitä.</p>\n<h3>Tehtävät 1.7</h3>\n<h4>unicafe osa2</h4>\n<p>Laajenna sovellusta siten, että se näyttää palautteista statistiikkaa, keskiarvon (hyvän arvo 1, neutraalin 0, huonon -1) ja sen kuinka monta prosenttia palautteista on ollut positiivisia:</p>\n<picture><img src=\"/static/8eeaee33949da20b66c30a6737f127aa/14be6/4d.png\" srcset=\"/static/8eeaee33949da20b66c30a6737f127aa/4cce7/4d.png 200w,\n/static/8eeaee33949da20b66c30a6737f127aa/bae5f/4d.png 400w,\n/static/8eeaee33949da20b66c30a6737f127aa/14be6/4d.png 800w,\n/static/8eeaee33949da20b66c30a6737f127aa/1b35a/4d.png 1200w,\n/static/8eeaee33949da20b66c30a6737f127aa/0dd5e/4d.png 1294w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<h3>Tehtävät 1.8</h3>\n<h4>unicafe osa3</h4>\n<p>Refaktoroi sovelluksesi siten, että se koostuu monista komponenteista. Pidä tila kuitenkin sovelluksen <em>juurikomponentissa</em>.</p>\n<p>Tee sovellukseen ainakin seuraavat komponentit:</p>\n<ul>\n<li><i>Button</i> vastaa yksittäistä palautteenantonappia</li>\n<li><i>Statistics</i> huolehtii tilastojen näyttämisestä</li>\n<li><i>Statistic</i> huolehtii yksittäisen tilastorivin, esim. keskiarvon näyttämisestä</li>\n</ul>\n<h3>Tehtävät 1.9</h3>\n<h4>unicafe osa4</h4>\n<p>Muuta sovellusta siten, että numeeriset tilastot näytetään ainoastaan jos palautteita on jo annettu:</p>\n<picture><img src=\"/static/ca65701774021dc5840250dfdb6778d2/14be6/5.png\" srcset=\"/static/ca65701774021dc5840250dfdb6778d2/4cce7/5.png 200w,\n/static/ca65701774021dc5840250dfdb6778d2/bae5f/5.png 400w,\n/static/ca65701774021dc5840250dfdb6778d2/14be6/5.png 800w,\n/static/ca65701774021dc5840250dfdb6778d2/1b35a/5.png 1200w,\n/static/ca65701774021dc5840250dfdb6778d2/d5d69/5.png 1424w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<h3>Tehtävät 1.10*</h3>\n<h4>unicafe osa5</h4>\n<p>Jos olet määritellyt jokaiselle napille oman tapahtumankäsittelijän, refaktoroi sovellustasi siten, että kaikki napit käyttävät samaa tapahtumankäsittelijäfunktiota samaan tapaan kuin materiaalin luvussa <a href=\"/osa1/#funktio-joka-palauttaa-funktion\">funktio joka palauttaa funktion</a>.</p>\n<p>Pari vihjettä. Ensinnäkin kannattaa muistaa, että olion kenttiin voi viitata pistenotaation lisäksi hakasulkeilla, eli:</p>\n<pre><code class=\"language-js\">const olio = {\n  a: 1,\n  b: 2,\n};\n\nolio['c'] = 3;\n\nconsole.log(olio.a); // tulostuu 1\n\nconsole.log(olio['b']); // tulostuu 2\n\nconst apu = 'c';\nconsole.log(olio[apu]); // tulostuu 3\n</code></pre>\n<p>Myös ns. <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer\">Computed property names</a> voi olla tässä tehtävässä hyödyksi.</p>\n<h3>Tehtävät 1.11</h3>\n<h4>unicafe osa6</h4>\n<p>Toteuta tilastojen näyttäminen HTML:n <a href=\"https://developer.mozilla.org/en-US/docs/Learn/HTML/Tables/Basics\">taulukkona</a> siten, että saat sovelluksesi näyttämään suunnilleen seuraavanlaiselta:</p>\n<picture><img src=\"/static/7500dfe6da204285cc1702be1538b140/14be6/6a.png\" srcset=\"/static/7500dfe6da204285cc1702be1538b140/4cce7/6a.png 200w,\n/static/7500dfe6da204285cc1702be1538b140/bae5f/6a.png 400w,\n/static/7500dfe6da204285cc1702be1538b140/14be6/6a.png 800w,\n/static/7500dfe6da204285cc1702be1538b140/1b35a/6a.png 1200w,\n/static/7500dfe6da204285cc1702be1538b140/97121/6a.png 1394w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Muista pitää konsoli koko ajan auki. Jos saat konsoliin seuraavan warningin:</p>\n<picture><img src=\"/static/cd8396f95df840c13fee0f449f049a06/14be6/7.png\" srcset=\"/static/cd8396f95df840c13fee0f449f049a06/4cce7/7.png 200w,\n/static/cd8396f95df840c13fee0f449f049a06/bae5f/7.png 400w,\n/static/cd8396f95df840c13fee0f449f049a06/14be6/7.png 800w,\n/static/cd8396f95df840c13fee0f449f049a06/1b35a/7.png 1200w,\n/static/cd8396f95df840c13fee0f449f049a06/9ee03/7.png 1600w,\n/static/cd8396f95df840c13fee0f449f049a06/a6552/7.png 1778w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>tee tarvittavat toimenpiteet jotta saat warningin katoamaan. Googlaa tarvittaessa virheilmoituksella.</p>\n<p><strong>Huolehdi nyt ja jatkossa, että konsolissa ei näy mitään warningeja!</strong></p>\n<h3>Tehtävät 1.12*</h3>\n<h4>anekdootit osa1</h4>\n<p>Ohjelmistotuotannossa tunnetaan lukematon määrä <a href=\"http://www.comp.nus.edu.sg/~damithch/pages/SE-quotes.htm\">anekdootteja</a> eli pieniä \"onelinereita\", jotka kiteyttävät alan ikuisia totuuksia.</p>\n<p>Laajenna seuraavaa sovellusta siten, että siihen tulee nappi, jota painamalla sovellus näyttää <em>satunnaisen</em> ohjelmistotuotantoon liittyvän anekdootin:</p>\n<pre><code class=\"language-react\">import React from 'react'\nimport ReactDOM from 'react-dom'\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      selected: 0\n    }\n  }\n\n  render() {\n    return (\n      &#x3C;div>\n        {this.props.anecdotes[this.state.selected]}\n      &#x3C;/div>\n    )\n  }\n}\n\nconst anecdotes = [\n  'If it hurts, do it more often',\n  'Adding manpower to a late software project makes it later!',\n  'The first 90 percent of the code accounts for the first 90 percent of the development time...The remaining 10 percent of the code accounts for the other 90 percent of the development time.',\n  'Any fool can write code that a computer can understand. Good programmers write code that humans can understand.',\n  'Premature optimization is the root of all evil.',\n  'Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.'\n]\n\nReactDOM.render(\n  &#x3C;App anecdotes={anecdotes} />,\n  document.getElementById('root')\n)\n</code></pre>\n<p>Google kertoo, miten voit generoida Javascriptilla sopivia satunnaisia lukuja. Muista, että voit testata esim. satunnaislukujen generointia konsolissa.</p>\n<p>Sovellus voi näyttää esim. seuraavalta:</p>\n<picture><img src=\"/static/a58354ed43c6ee83bab346b1ed5240a7/14be6/2.png\" srcset=\"/static/a58354ed43c6ee83bab346b1ed5240a7/4cce7/2.png 200w,\n/static/a58354ed43c6ee83bab346b1ed5240a7/bae5f/2.png 400w,\n/static/a58354ed43c6ee83bab346b1ed5240a7/14be6/2.png 800w,\n/static/a58354ed43c6ee83bab346b1ed5240a7/1b35a/2.png 1200w,\n/static/a58354ed43c6ee83bab346b1ed5240a7/e8390/2.png 1492w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<h3>Tehtävät 1.13*</h3>\n<h4>anekdootit osa2</h4>\n<p>Laajenna sovellusta siten, että näytettävää anekdoottia on mahdollista äänestää:</p>\n<picture><img src=\"/static/fbb8bc0bc2a60aa9b725f45b2c2911d1/14be6/3.png\" srcset=\"/static/fbb8bc0bc2a60aa9b725f45b2c2911d1/4cce7/3.png 200w,\n/static/fbb8bc0bc2a60aa9b725f45b2c2911d1/bae5f/3.png 400w,\n/static/fbb8bc0bc2a60aa9b725f45b2c2911d1/14be6/3.png 800w,\n/static/fbb8bc0bc2a60aa9b725f45b2c2911d1/1b35a/3.png 1200w,\n/static/fbb8bc0bc2a60aa9b725f45b2c2911d1/0d767/3.png 1460w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p><strong>Huom:</strong> jos päätät tallettaa kunkin anekdootin äänet komponentin tilassa olevan olion kenttiin tai taulukkoon, saatat tarvita päivittäessäsi tilaa oikeaoppisesti olion tai taulukon <em>kopioimista</em>.</p>\n<p>Olio voidaan kopioida esim. seuraavasti:</p>\n<pre><code class=\"language-js\">const pisteet = { 0: 1, 1: 3, 2: 4, 3: 2 };\n\nconst kopio = { ...pisteet };\nkopio[2] += 1; // kasvatetaan olion kentän 2 arvoa yhdellä\n</code></pre>\n<p>ja taulukko esim. seuraavasti:</p>\n<pre><code class=\"language-js\">const pisteet = [1, 4, 6, 3];\n\nconst kopio = [...pisteet];\nkopio[2] += 1; // kasvatetaan taulukon paikan 2 arvoa yhdellä\n</code></pre>\n<h3>Tehtävät 1.14*</h3>\n<h4>anekdootit osa3</h4>\n<p>Ja sitten vielä lopullinen versio, joka näyttää eniten ääniä saaneen anekdootin:</p>\n<picture><img src=\"/static/2b1a015cd08c9b5ef3eb334813978d99/14be6/3b.png\" srcset=\"/static/2b1a015cd08c9b5ef3eb334813978d99/4cce7/3b.png 200w,\n/static/2b1a015cd08c9b5ef3eb334813978d99/bae5f/3b.png 400w,\n/static/2b1a015cd08c9b5ef3eb334813978d99/14be6/3b.png 800w,\n/static/2b1a015cd08c9b5ef3eb334813978d99/1b35a/3b.png 1200w,\n/static/2b1a015cd08c9b5ef3eb334813978d99/97121/3b.png 1394w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Jos suurimman äänimäärän saaneita anekdootteja on useita, riittää että niistä näytetään yksi.</p>\n<p>Tämä saattaa olla jo hieman haastavampi. Taulukolta löytyy monia hyviä metodeja, katso lisää <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\">Mozillan dokumentaatiosta</a>.</p>\n<p>Youtubessa on kohtuullisen hyvä <a href=\"https://www.youtube.com/watch?v=BMUiFMZr7vk&#x26;list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84\">johdatus funktionaaliseen javascript-ohjelmointiin</a>. Kolmen ensimmäisen osan katsominen riittää hyvin tässä vaiheessa.</p>\n</div>","frontmatter":{"title":"osa 1","subTitle":"React-komponentin tila","path":"/osa1/komponentin_tila","mainImage":{"publicURL":"/static/osa1-b7ac07cbe6df8ed745701fabe73af8ef.png"},"partColor":"green","part":1,"letter":"c"}}},"pageContext":{}}