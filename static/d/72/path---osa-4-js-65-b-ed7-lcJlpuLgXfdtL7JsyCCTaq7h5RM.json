{"data":{"markdownRemark":{"html":"<div class=\"content\">\n<h3>virheiden käsittely ja async/await</h3>\n<p>Jos sovellus POST-pyyntöä käsitellessään aiheuttaa jonkinlaisen ajonaikaisen virheen, syntyy jälleen tuttu tilanne:</p>\n<pre>\n(node:30644) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): TypeError: formattedNote.nonexistingMethod is not a function\n</pre>\n<p>eli käsittelemätön promisen rejektoituminen. Pyyntöön ei vastata tilanteessa mitenkään.</p>\n<p>Async/awaitia käyttäessä kannattaa käyttää vanhaa kunnon <em>try/catch</em>-mekanismia virheiden käsittelyyn:</p>\n<pre><code class=\"language-js\">notesRouter.post('/', async (request, response) => {\n  try {\n    const body = request.body;\n\n    if (body.content === undefined) {\n      return response.status(400).json({ error: 'content missing' });\n    }\n\n    const note = new Note({\n      content: body.content,\n      important: body.important === undefined ? false : body.important,\n      date: new Date(),\n    });\n\n    const savedNote = await note.save();\n    response.json(formatNote(note));\n  } catch (exception) {\n    console.log(exception);\n    response.status(500).json({ error: 'something went wrong...' });\n  }\n});\n</code></pre>\n<p>Iso try/catch tuo koodiin hieman ikävän vivahteen, mutta mikään ei ole ilmaista.</p>\n<p>Tehdään sitten testit yksittäisen muistiinpanon tietojen katsomiselle ja muistiinpanon poistolle:</p>\n<pre><code class=\"language-js\">test('a specific note can be viewed', async () => {\n  const resultAll = await api\n    .get('/api/notes')\n    .expect(200)\n    .expect('Content-Type', /application\\/json/);\n\n  const aNoteFromAll = resultAll.body[0];\n\n  const resultNote = await api.get(`/api/notes/${aNoteFromAll.id}`);\n\n  const noteObject = resultNote.body;\n\n  expect(noteObject).toEqual(aNoteFromAll);\n});\n\ntest('a note can be deleted', async () => {\n  const newNote = {\n    content: 'HTTP DELETE poistaa resurssin',\n    important: true,\n  };\n\n  const addedNote = await api.post('/api/notes').send(newNote);\n\n  const notesAtBeginningOfOperation = await api.get('/api/notes');\n\n  await api.delete(`/api/notes/${addedNote.body.id}`).expect(204);\n\n  const notesAfterDelete = await api.get('/api/notes');\n\n  const contents = notesAfterDelete.body.map(r => r.content);\n\n  expect(contents).not.toContain('HTTP DELETE poistaa resurssin');\n  expect(notesAfterDelete.body.length).toBe(\n    notesAtBeginningOfOperation.body.length - 1\n  );\n});\n</code></pre>\n<p>Testit eivät tässä vaiheessa ole optimaaliset, parannetaan niitä kohta. Ensin kuitenkin refaktoroidaan backend käyttämään async/awaitia.</p>\n<pre><code class=\"language-js\">notesRouter.get('/:id', async (request, response) => {\n  try {\n    const note = await Note.findById(request.params.id);\n\n    if (note) {\n      response.json(formatNote(note));\n    } else {\n      response.status(404).end();\n    }\n  } catch (exception) {\n    console.log(exception);\n    response.status(400).send({ error: 'malformatted id' });\n  }\n});\n\nnotesRouter.delete('/:id', async (request, response) => {\n  try {\n    await Note.findByIdAndRemove(request.params.id);\n\n    response.status(204).end();\n  } catch (exception) {\n    console.log(exception);\n    response.status(400).send({ error: 'malformatted id' });\n  }\n});\n</code></pre>\n<p>Async/await ehkä selkeyttää koodia jossain määrin, mutta saavutettava hyöty ei ole sovelluksessamme vielä niin iso mitä se tulee olemaan jos asynkronisia kutsuja on tehtävä useampia.</p>\n<p>Kaikki eivät kuitenkaan ole vakuuttuneita siitä, että async/await on hyvä lisä Javascriptiin, lue esim. <a href=\"https://spion.github.io/posts/es7-async-await-step-in-the-wrong-direction.html\">ES7 async functions - a step in the wrong direction</a></p>\n<p>Sovelluksen tämänhetkinen koodi on kokonaisuudessaan <a href=\"https://github.com/FullStack-HY/part3-notes-backend/tree/part4-4\">githubissa</a>, tagissa <em>part4-4</em>. Samassa on \"vahingossa\" mukana testeistä seuraavan luvun jälkeinen paranneltu versio.</p>\n<h3>Varoitus</h3>\n<p>Jos huomaat kirjoittavasi sekaisin async/awaitia ja <em>then</em>-kutsuja, on 99% varmaa, että teet jotain väärin. Käytä siis jompaa kumpaa tapaa, älä missään tapauksessa \"varalta\" molempia.</p>\n<h2>Tehtäviä</h2>\n<p>Tee nyt tehtävät <a href=\"/teht%C3%A4v%C3%A4t/#apin-testaaminen\">4.8-4.11</a></p>\n<h2>Testien refaktorointi</h2>\n<p>Testimme sisältävät tällä hetkellä jossain määrin toisteisuutta ja niiden rakenne ei ole optimaalinen. Testit ovat myös osittain epätäydelliset, esim. reittejä GET /api/notes/:id ja DELETE /api/notes/:id ei tällä hetkellä testata epävalidien id:iden osalta.</p>\n<p>Testeissä on myös eräs hieman ikävä ja jopa riskialtis piirre. Testit luottavat siihen, että ne suoritetaan siinä järjestyksessä, missä ne on kirjoitettu testitiedostoon. Tämä pitää kyllä paikkansa, vaikkakin se ei ole kovin selkeästi määritelty ominaisuus eli siihen ei ole hyvä luottaa. Testit tuleekin kirjoittaa siten, että yksittäiset testit ovat riippumattomia toistensa suorituksesta.</p>\n<p>Parannellaan testejä hiukan.</p>\n<p>Tehdään testejä varten muutama apufunktio moduuliin <em>tests/test</em>helper.js_</p>\n<pre><code class=\"language-js\">const Note = require('../models/note');\n\nconst initialNotes = [\n  {\n    content: 'HTML on helppoa',\n    important: false,\n  },\n  {\n    content: 'HTTP-protokollan tärkeimmät metodit ovat GET ja POST',\n    important: true,\n  },\n];\n\nconst format = note => {\n  return {\n    content: note.content,\n    important: note.important,\n    id: note._id,\n  };\n};\n\nconst nonExistingId = async () => {\n  const note = new Note();\n  await note.save();\n  await note.remove();\n\n  return note._id.toString();\n};\n\nconst notesInDb = async () => {\n  const notes = await Note.find({});\n  return notes.map(format);\n};\n\nmodule.exports = {\n  initialNotes,\n  format,\n  nonExistingId,\n  notesInDb,\n};\n</code></pre>\n<p>Tärkein apufunktioista on <em>notesInDb</em> joka palauttaa kaikki tietokannassa kutsuhetkellä olevat oliot.</p>\n<p>Jossain määrin parannellut testit seuraavassa:</p>\n<pre><code class=\"language-js\">const supertest = require('supertest');\nconst { app, server } = require('../index');\nconst api = supertest(app);\nconst Note = require('../models/note');\nconst {\n  format,\n  initialNotes,\n  nonExistingId,\n  notesInDb,\n} = require('./test_helper');\n\ndescribe('when there is initially some notes saved', async () => {\n  beforeAll(async () => {\n    await Note.remove({});\n\n    const noteObjects = initialNotes.map(n => new Note(n));\n    await Promise.all(noteObjects.map(n => n.save()));\n  });\n\n  test('all notes are returned as json by GET /api/notes', async () => {\n    const notesInDatabase = await notesInDb();\n\n    const response = await api\n      .get('/api/notes')\n      .expect(200)\n      .expect('Content-Type', /application\\/json/);\n\n    expect(response.body.length).toBe(notesInDatabase.length);\n\n    const returnedContents = response.body.map(n => n.content);\n    notesInDatabase.forEach(note => {\n      expect(returnedContents).toContain(note.content);\n    });\n  });\n\n  test('individual notes are returned as json by GET /api/notes/:id', async () => {\n    const notesInDatabase = await notesInDb();\n    const aNote = notesInDatabase[0];\n\n    const response = await api\n      .get(`/api/notes/${aNote.id}`)\n      .expect(200)\n      .expect('Content-Type', /application\\/json/);\n\n    expect(response.body.content).toBe(aNote.content);\n  });\n\n  test('404 returned by GET /api/notes/:id with nonexisting valid id', async () => {\n    const validNonexistingId = await nonExistingId();\n\n    const response = await api\n      .get(`/api/notes/${validNonexistingId}`)\n      .expect(404);\n  });\n\n  test('400 is returned by GET /api/notes/:id with invalid id', async () => {\n    const invalidId = '5a3d5da59070081a82a3445';\n\n    const response = await api.get(`/api/notes/${invalidId}`).expect(400);\n  });\n\n  describe('addition of a new note', async () => {\n    test('POST /api/notes succeeds with valid data', async () => {\n      const notesAtStart = await notesInDb();\n\n      const newNote = {\n        content: 'async/await yksinkertaistaa asynkronisten funktioiden kutsua',\n        important: true,\n      };\n\n      await api\n        .post('/api/notes')\n        .send(newNote)\n        .expect(200)\n        .expect('Content-Type', /application\\/json/);\n\n      const notesAfterOperation = await notesInDb();\n\n      expect(notesAfterOperation.length).toBe(notesAtStart.length + 1);\n\n      const contents = notesAfterOperation.map(r => r.content);\n      expect(contents).toContain(\n        'async/await yksinkertaistaa asynkronisten funktioiden kutsua'\n      );\n    });\n\n    test('POST /api/notes fails with proper statuscode if content is missing', async () => {\n      const newNote = {\n        important: true,\n      };\n\n      const notesAtStart = await notesInDb();\n\n      await api\n        .post('/api/notes')\n        .send(newNote)\n        .expect(400);\n\n      const notesAfterOperation = await notesInDb();\n\n      const contents = notesAfterOperation.map(r => r.content);\n\n      expect(notesAfterOperation.length).toBe(notesAtStart.length);\n    });\n  });\n\n  describe('deletion of a note', async () => {\n    let addedNote;\n\n    beforeAll(async () => {\n      addedNote = new Note({\n        content: 'poisto pyynnöllä HTTP DELETE',\n        important: false,\n      });\n      await addedNote.save();\n    });\n\n    test('DELETE /api/notes/:id succeeds with proper statuscode', async () => {\n      const notesAtStart = await notesInDb();\n\n      await api.delete(`/api/notes/${addedNote._id}`).expect(204);\n\n      const notesAfterOperation = await notesInDb();\n\n      const contents = notesAfterOperation.map(r => r.content);\n\n      expect(contents).not.toContain(addedNote.content);\n      expect(notesAfterOperation.length).toBe(notesAtStart.length - 1);\n    });\n  });\n\n  afterAll(() => {\n    server.close();\n  });\n});\n</code></pre>\n<p>Muutama huomio testeistä. Olemme jaotelleet testejä <a href=\"http://facebook.github.io/jest/docs/en/api.html#describename-fn\">describe</a>-lohkojen avulla ja muutamissa lohkoissa on oma <a href=\"http://facebook.github.io/jest/docs/en/api.html#beforeallfn-timeout\">beforeAll</a>-funktiolla suoritettava alustuskoodi.</p>\n<p>Joissain tapauksissa tämä olisi parempi tehdä operaatiolla <a href=\"https://facebook.github.io/jest/docs/en/api.html#beforeeachfn-timeout\">beforeEach</a>, joka suoritetaan <em>ennen jokaista testiä</em>, näin testeistä saisi varmemmin toisistaan riippumattomia. Esimerkissä beforeEachia ei kuitenkaan ole käytetty.</p>\n<p>Testien raportointi tapahtuu <em>describe</em>-lohkojen ryhmittelyn mukaan:</p>\n<picture><img src=\"/static/fb864403ed08f27b73849e774e120969/14be6/5.png\" srcset=\"/static/fb864403ed08f27b73849e774e120969/4cce7/5.png 200w,\n/static/fb864403ed08f27b73849e774e120969/bae5f/5.png 400w,\n/static/fb864403ed08f27b73849e774e120969/14be6/5.png 800w,\n/static/fb864403ed08f27b73849e774e120969/1b35a/5.png 1200w,\n/static/fb864403ed08f27b73849e774e120969/27c3e/5.png 1528w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Backendin tietokannan tilaa muuttavat testit, esim. uuden muistiinpanon lisäämistä testaava testi <em>'addition of a new note'</em>, on tehty siten, että ne ensin aluksi selvittävät tietokannan tilan apufunktiolla <em>notesInDb()</em></p>\n<pre><code class=\"language-js\">const notesAtBeginningOfOperation = await notesInDb();\n</code></pre>\n<p>suorittavat testattavan operaation:</p>\n<pre><code class=\"language-js\">const newNote = {\n  content: 'async/await yksinkertaistaa asynkronisten funktioiden kutsua',\n  important: true,\n};\n\nawait api\n  .post('/api/notes')\n  .send(newNote)\n  .expect(200)\n  .expect('Content-Type', /application\\/json/);\n</code></pre>\n<p>selvittävät tietokannan tilan operaation jälkeen</p>\n<pre><code class=\"language-js\">const notesAfterOperation = await notesInDb();\n</code></pre>\n<p>ja varmentavat, että operaation suoritus vaikutti tietokantaan halutulla tavalla</p>\n<pre><code class=\"language-js\">expect(notesAfterOperation.length).toBe(notesAtBeginningOfOperation.length + 1);\n\nconst contents = notesAfterOperation.map(r => r.content);\nexpect(contents).toContain(\n  'async/await yksinkertaistaa asynkronisten funktioiden kutsua'\n);\n</code></pre>\n<p>Testeihin jää vielä paljon parannettavaa mutta on jo aika siirtyä eteenpäin.</p>\n<p>Käytetty tapa API:n testaamiseen, eli HTTP-pyyntöinä tehtävät operaatiot ja tietokannan tilan tarkastelu Mongoosen kautta ei ole suinkaan ainoa tai välttämättä edes paras tapa tehdä API-tason integraatiotestausta. Universaalisti parasta tapaa testien tekoon ei ole, vaan kaikki on aina suhteessa käytettäviin resursseihin ja testattavaan ohjelmistoon.</p>\n<h2>Tehtäviä</h2>\n<p>Tee nyt tehtävät <a href=\"/teht%C3%A4v%C3%A4t#lis%C3%A4%C3%A4-toiminnallisuutta-ja-testej%C3%A4\">4.12-4.14</a></p>\n</div>","frontmatter":{"title":"osa 4","subTitle":"JS","path":"/osa4/js","mainImage":{"publicURL":"/static/osa5-8edc6044aad809a3143dc36c5e7f3b4c.png"},"partColor":"yellow","part":4,"letter":"c"}}},"pageContext":{}}