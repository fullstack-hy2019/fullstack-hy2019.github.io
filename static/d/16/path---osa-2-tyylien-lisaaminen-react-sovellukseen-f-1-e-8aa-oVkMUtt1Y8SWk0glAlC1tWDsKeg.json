{"data":{"markdownRemark":{"html":"<div class=\"content\">\n<p>Sovelluksemme ulkoasu on tällä hetkellä hyvin vaatimaton. Osaan 0 liittyvässä <a href=\"/teht%C3%A4v%C3%A4t/#web-sovellusten-perusteet\">tehtävässä 0.1</a> oli tarkoitus tutustua Mozillan <a href=\"https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/CSS_basics\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">CSS-tutoriaaliin</a>.</p>\n<p>Katsotaan vielä tämän osan lopussa nopeasti kahta tapaa liittää tyylejä React-sovellukseen. Tapoja on useita ja tulemme tarkastelemaan muita myöhemmin. Liitämme ensin CSS:n sovellukseemme vanhan kansan tapaan yksittäisenä, käsin eli ilman <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/CSS_preprocessor\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">esiprosessorien</a> apua kirjoitettuna tiedostona (tämä ei itseasiassa ole täysin totta, kuten myöhemmin tulemme huomaamaan).</p>\n<p>Tehdään sovelluksen hakemistoon <em>src</em> tiedosto <em>index.css</em> ja liitetään se sovellukseen lisäämällä tiedostoon <em>index.js</em> seuraava import:</p>\n<pre><code class=\"language-js\">import './index.css'\n</code></pre>\n<p>Lisätään seuraava sääntö tiedostoon <em>index.css</em>:</p>\n<pre><code class=\"language-css\">h1 {\n  color: green;\n}\n</code></pre>\n<p>CSS-säännöt koostuvat valitsimesta, eli <em>selektorista</em> ja määrittelystä eli <em>deklaraatiosta</em>. Valitsin määrittelee, mihin elementteihin sääntö kohdistuu. Valitsimena on nyt <em>h1</em>, eli kaikki sovelluksessa käytetyt <em>h1</em>-otsikkotägit.</p>\n<p>Määrittelyosa asettaa ominaisuuden <em>color</em>, eli fontin värin arvoksi vihreän, eli <em>green</em>.</p>\n<p>Sääntö voi sisältää mielivaltaisen määrän määrittelyjä. Muutetaan edellistä siten, että tekstistä tulee kursivoitua, eli fontin tyyliksi asetetaan <em>italics</em>:</p>\n<pre><code class=\"language-css\">h1 {\n  color: green;\n  font-style: italic;  // highlight-line\n}\n</code></pre>\n<p>Erilaisia selektoreja eli tapoja valita tyylien kohde on <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">lukuisia</a>.</p>\n<p>Jos haluamme kohdistaa tyylejä esim. jokaiseen muistiinpanoon, voisimme nyt käyttää selektoria <code>li</code>, sillä muistiinpanot ovat <code>li</code>-tagien sisällä:</p>\n<pre><code class=\"language-js\">const Note = ({ note, toggleImportance }) => {\n  const label = note.important \n    ? 'make not important' \n    : 'make important';\n\n  return (\n    &#x3C;li>\n      {note.content} \n      &#x3C;button onClick={toggleImportance}>{label}&#x3C;/button>\n    &#x3C;/li>\n  )\n}\n</code></pre>\n<p>lisätään tyylitiedostoon seuraava (koska osaamiseni tyylikkäiden web-sivujen tekemiseen on lähellä nollaa, nyt käytettävissä tyyleissä ei ole sinänsä mitään järkeä):</p>\n<pre><code class=\"language-css\">li {\n  color: grey;\n  padding-top: 3px;\n  font-size: 15px;\n}\n</code></pre>\n<p>Tyylien kohdistaminen elementtityypin sijaan on kuitenkin hieman ongelmallista, jos sovelluksessa olisi myös muita  <code>li</code>-tageja, kaikki saisivat samat tyylit.</p>\n<p>Jos haluamme kohdistaa tyylit nimenomaan muistiinpanoihin, on parempi käyttää <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">class selectoreja</a>.</p>\n<p>Normaalissa HTML:ssä luokat määritellään elementtien attribuutin  <code>class</code> arvona:</p>\n<pre><code class=\"language-html\">&#x3C;li class=\"note\">tekstiä&#x3C;/li>\n</code></pre>\n<p>Reactissa tulee kuitenkin classin sijaan käyttää attribuuttia <a href=\"https://reactjs.org/docs/dom-elements.html#classname\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">className</a>, eli muutetaan komponenttia <em>Note</em> seuraavasti:</p>\n<pre><code class=\"language-js\">const Note = ({ note, toggleImportance }) => {\n  const label = note.important \n    ? 'make not important' \n    : 'make important';\n\n  return (\n    &#x3C;li className='note'> // highlight-line\n      {note.content} \n      &#x3C;button onClick={toggleImportance}>{label}&#x3C;/button>\n    &#x3C;/li>\n  )\n}\n</code></pre>\n<p>Luokkaselektori määritellään syntaksilla <em>.classname</em>, eli:</p>\n<pre><code class=\"language-css\">.note {\n  color: grey;\n  padding-top: 5px;\n  font-size: 15px;\n}\n</code></pre>\n<p>Jos nyt lisäät sovellukseen muita li-elementtejä, ne eivät saa muistiinpanoille määriteltyjä tyylejä.</p>\n<h3>Parempi virheilmoitus</h3>\n<p>Toteutimme äsken olemassaolemattoman muistiinpanon tärkeyden muutokseen liittyvän virheilmoituksen <code>alert</code>-metodilla. Toteutetaan se nyt Reactilla omana komponenttinaan.</p>\n<p>Komponentti on yksinkertainen:</p>\n<pre><code class=\"language-js\">const Notification = ({ message }) => {\n  if (message === null) {\n    return null\n  }\n\n  return (\n    &#x3C;div className=\"error\">\n      {message}\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Jos propsin <code>message</code> arvo on <code>null</code> ei renderöidä mitään, muussa tapauksessa renderöidään viesti div-elementtiin. Elementille on liitetty tyylien lisäämistä varten luokka <code>error</code>.</p>\n<p>Lisätään komponentin <code>App</code> tilaan kenttä <code>error</code> virheviestiä varten, laitetaan kentälle heti jotain sisältöä, jotta pääsemme heti testaamaan komponenttia:</p>\n<pre><code class=\"language-js\">const App = () => {\n  const [notes, setNotes] = useState([]) \n  const [newNote, setNewNote] = useState('')\n  const [showAll, setShowAll] = useState(true)\n  const [errorMessage, setErrorMessage] = useState(null) // highlight-line\n\n  // ...\n\n  return (\n    &#x3C;div>\n      &#x3C;h1>Muistiinpanot&#x3C;/h1>\n\n      &#x3C;Notification message={errorMessage} /> // highlight-line\n      \n      &#x3C;div>\n        &#x3C;button onClick={() => setShowAll(!showAll)}>\n          näytä {showAll ? 'vain tärkeät' : 'kaikki'}\n        &#x3C;/button>\n      &#x3C;/div>\n      &#x3C;ul>\n        {rows()}\n      &#x3C;/ul>\n\n      &#x3C;form onSubmit={addNote}>\n        &#x3C;input\n          value={newNote}\n          onChange={handleNoteChange}\n        />\n        &#x3C;button type=\"submit\">tallenna&#x3C;/button>\n      &#x3C;/form>      \n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Lisätään sitten virheviestille sopiva tyyli:</p>\n<pre><code class=\"language-css\">.error {\n  color: red;\n  background: lightgrey;\n  font-size: 20px;\n  border-style: solid;\n  border-radius: 5px;\n  padding: 10px;\n  margin-bottom: 10px;\n}\n</code></pre>\n<p>Nyt olemme valmiina lisäämään virheviestin logiikan. Mmuutetaan metodia <code>toggleImportanceOf</code> seuraavasti:</p>\n<pre><code class=\"language-js\">  const toggleImportanceOf = id => {\n    const note = notes.find(n => n.id === id)\n    const changedNote = { ...note, important: !note.important }\n\n    noteService\n      .update(changedNote).then(returnedNote => {\n        setNotes(notes.map(note => note.id !== id ? note : returnedNote))\n      })\n      .catch(error => {\n        // highlight-start\n        setErrorMessage(`muistiinpano '${note.content}' on jo valitettavasti poistettu palvelimelta`)\n        setTimeout(() => {\n          setErrorMessage(null)\n        }, 5000)\n        // highlight-end\n        setNotes(notes.filter(n => n.id !== id))\n      })\n  }\n</code></pre>\n<p>Eli virheen yhteydessä asetetaan tilaan <code>errorMessage</code> sopiva virheviesti. Samalla käynnistetään ajastin, joka asettaa 5 sekunnin kuluttua tilan <code>errorMessage</code>-kentän arvoksi <code>null</code>.</p>\n<p>Lopputulos näyttää seuraavalta</p>\n<p><img src=\"../images/2/26b.png\"></p>\n<p>Sovelluksen tämänhetkinen koodi on kokonaisuudessaan <a href=\"https://github.com/FullStack-HY/part2-notes/tree/part2-7\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">githubissa</a>, branchissa <em>part2-7</em>.</p>\n<h3>Inline-tyylit</h3>\n<p>React mahdollistaa myös tyylien kirjoittamisen suoraan komponenttien koodin joukkoon niin sanoittuina <a href=\"https://react-cn.github.io/react/tips/inline-styles.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">inline-tyyleinä</a>.</p>\n<p>Periaate inline-tyylien määrittelyssä on erittäin yksinkertainen. Mihin tahansa React-komponenttiin tai elementtiin voi liittää attribuutin <a href=\"https://reactjs.org/docs/dom-elements.html#style\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">style</a>, jolle annetaan arvoksi Javascript-oliona määritelty joukko CSS-sääntöjä.</p>\n<p>CSS-säännöt määritellään olioden avulla hieman eri tavalla kuin normaaleissa CSS-tiedostoissa. Jos haluamme esimerkisi asettaa jollekin elementille vihreän, kursivoidun ja 16 pikselin korkuisen fontin, eli CSS-syntaksilla ilmaistuna</p>\n<pre><code class=\"language-css\">{\n  color: green;\n  font-style: italic;\n  font-size: 16px;\n}\n</code></pre>\n<p>tulee tämä muotilla Reactin inline-tyylin määrittelevänä oliona seuraavasti</p>\n<pre><code class=\"language-js\"> {\n  color: 'green',\n  fontStyle: 'italic',\n  fontSize: 16\n}\n</code></pre>\n<p>Jokainen CSS-sääntö on olion kenttä, joten ne erotetaan Javascript-syntaksin mukaan pilkuilla. Pikseleinä ilmaistut numeroarvot voidaan määritellä kokonaislukuina. Merkittävin ero normaaliin CSS:ään on väliviivan sisältämien CSS-ominaisuuksien kirjoittaminen camelCase-muodossa.</p>\n<p>Voisimme nyt lisätä sovelluksemme \"alapalkin\", muodostavan komponentin <code>Footer</code>, ja määritellä sille inline-tyylit seuraavasti:</p>\n<pre><code class=\"language-js\">const Footer = () => {\n  const footerStyle = {\n    color: 'green',\n    fontStyle: 'italic',\n    fontSize: 16\n  }\n\n  return (\n    &#x3C;div style={footerStyle}>\n      &#x3C;br />\n      &#x3C;em>Note app, Department of Computer Science 2019&#x3C;/em>\n    &#x3C;/div> \n  )\n}\n\nconst App = () => {\n  // ...\n\n  return (\n    &#x3C;div>\n      &#x3C;h1>Muistiinpanot&#x3C;/h1>\n\n      &#x3C;Notification message={errorMessage} />\n\n      // ...  \n\n      &#x3C;Footer /> // highlight-line\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Inline-tyyleillä on tiettyjä rajoituksia, esim. ns. pseudo-selektoreja ei ole mahdollisuutta käyttää (ainakaan helposti).</p>\n<p>Inline-tyylit ja muutamat myöhemmin kurssilla katsomamme tavat lisätä tyylejä Reactiin ovat periaatteessa täysin vastoin vanhoja hyviä periaatteita, joiden mukaan Web-sovellusten ulkoasujen määrittely eli CSS tulee erottaa sisällön (HTML) ja toiminnallisuuden (Javascript) määrittelystä. Vanha koulukunta pyrkiikin siihen että sovelluksen CSS, HTML ja Javascript on kaikki kirjoitettu omiin tiedostoihinsa.</p>\n<p>Itseasiassa Reactin filosofia on täysin päinvastainen. Koska CSS:n, HTML:n ja Javascriptin erottelu eri tiedostoihin ei ole kuitenkaan osoittautunut erityisen skaalautuvaksi ratkaisuksi suurissa järjestelmissä, on Reactissa periaatteena tehdä erottelu (eli jakaa sovelluksen koodi eri tiedostoihin) noudattaen sovelluksen loogisia toiminnallisia kokonaisuuksia.</p>\n<p>Toiminnallisen kokonaisuuden strukturointiyksikkö on React-komponentti, joka määrittelee niin sisällön rakenteen kuvaavan HTML:n, toiminnan määrittelevät Javascript-funktiot kuin komponentin tyylinkin yhdessä paikassa, siten että komponenteista tulee mahdollisimman riippumattomia ja yleiskäyttöisiä.</p>\n</div>\n<div class=\"tasks\">\n<h3>Tehtäviä</h3>\n<h4>2.19: puhelinluettelo osa 11</h4>\n<p>Toteuta osan 2 esimerkin <a href=\"/osa2/#parempi-virheilmoitus\">parempi virheilmoitus</a> tyyliin ruudulla muutaman sekunnin näkyvä ilmoitus, joka kertoo onnistuneista operaatioista (henkilön lisäys ja poisto, sekä numeron muutos):</p>\n<p><img src=\"../images/2/27b.png\"></p>\n<h4>2.20*: puhelinluettelo osa 12</h4>\n<p>Jos poistat jonkun henkilön toisesta selaimesta hieman ennen kun yrität <em>muuttaa henkilön numeroa</em> toisesta selaimesta, tapahtuu virhetilanne:</p>\n<p><img src=\"../images/2/29b.png\"></p>\n<p>Korjaa ongelma osan 2 esimerkin <a href=\"/osa2/#promise-ja-virheet\">promise ja virheet</a> hengessä, mutta siten että\nkäyttäjälle ilmoitetaan operaation epäonnistumisesta. Onnistuneen ja epäonnistuneen operaation ilmoitusten tulee erota toisistaan: </p>\n<p><img src=\"../images/2/28a.png\"></p>\n<p>Tämä oli osan viimeinen tehtävä ja on aika pushata koodi githubiin merkata tehdyt tehtävät <a href=\"https://studies.cs.helsinki.fi/courses/#fullstack2019\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">palautussovellukseen</a>.</p>\n</div>","frontmatter":{"mainImage":{"publicURL":"/static/part-2-2c709798e38da8a809241016507d8154.svg"},"part":2,"letter":"e"}}},"pageContext":{"part":2,"letter":"e"}}