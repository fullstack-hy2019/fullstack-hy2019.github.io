{"data":{"markdownRemark":{"html":"<div class=\"content\">\n<h3>Testejä ja backendin refaktorointia</h3>\n<p>Koodia refaktoroidessa vaanii aina <a href=\"https://en.wikipedia.org/wiki/Regression_testing\">regression</a> vaara, eli on olemassa riski, että jo toimineet ominaisuudet hajoavat. Tehdäänkin muiden operaatioiden refaktorointi siten, että ennen koodin muutosta tehdään jokaiselle API:n routelle sen toiminnallisuuden varmistavat testit.</p>\n<p>Aloitetaan lisäysoperaatiosta. Tehdään testi, joka lisää uuden muistiinpanon ja tarkistaa, että API:n palauttamien muistiinpanojen määrä kasvaa, ja että lisätty muistiinpano on palautettujen joukossa:</p>\n<pre><code class=\"language-js\">test('a valid note can be added ', async () => {\n  const newNote = {\n    content: 'async/await yksinkertaistaa asynkronisten funktioiden kutsua',\n    important: true,\n  };\n\n  await api\n    .post('/api/notes')\n    .send(newNote)\n    .expect(200)\n    .expect('Content-Type', /application\\/json/);\n\n  const response = await api.get('/api/notes');\n\n  const contents = response.body.map(r => r.content);\n\n  expect(response.body.length).toBe(initialNotes.length + 1);\n  expect(contents).toContain(\n    'async/await yksinkertaistaa asynkronisten funktioiden kutsua'\n  );\n});\n</code></pre>\n<p>Kuten odotimme ja toivoimme, menee testi läpi.</p>\n<p>Tehdään myös testi, joka varmistaa, että muistiinpanoa, jolle ei ole asetettu sisältöä, ei talleteta</p>\n<pre><code class=\"language-js\">test('note without content is not added ', async () => {\n  const newNote = {\n    important: true,\n  };\n\n  const initialNotes = await api.get('/api/notes');\n\n  await api\n    .post('/api/notes')\n    .send(newNote)\n    .expect(400);\n\n  const response = await api.get('/api/notes');\n\n  expect(response.body.length).toBe(initialNotes.length);\n});\n</code></pre>\n<p>Testi ei mene läpi.</p>\n<p>Käy ilmi, että myös operaation suoritus postman tai Visual Studio Coden REST clientillä johtaa virhetilanteeseen. Koodissa on siis bugi.</p>\n<blockquote>\n<p><strong>Huom:</strong> testejä tehdessä täytyy aina varmistua siitä, että testi testaa oikeaa asiaa, ja usein ensimmäistä kertaa testiä tehdessä se että testi ei mene läpi tarkoittaa sitä, että testi on tehty väärin. Myös päinvastaista tapahtuu, eli testi menee läpi mutta koodissa onkin virhe, eli testi ei testaa sitä mitä sen piti testata. Tämän takia testit kannattaa aina \"testata\" rikkomalla koodi ja varmistamalla, että testi huomaa koodiin tehdyt virheet.</p>\n</blockquote>\n<p>Kun suoritamme operaation postmanilla konsoli paljastaa, että kyseessä on <em>Unhandled promise rejection</em>, eli koodi ei käsittele promisen virhetilannetta:</p>\n<pre>\nServer running on port 3001\nMethod: POST\nPath:   /api/notes/\nBody:   { important: true }\n---\n(node:28657) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error: Can't set headers after they are sent.\n(node:28657) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.\n</pre>\n<p>Kuten jo edellisessä osassa mainittiin, tämä ei ole hyvä idea. Kannattaakin aloittaa lisäämällä promise-ketjuun metodilla <em>catch</em> virheenkäsittelijä, joka tulostaa konsoliin virheen syyn:</p>\n<pre><code class=\"language-js\">notesRouter.post('/', (request, response) => {\n  // ...\n\n  note\n    .save()\n    .then(note => {\n      return formatNote(note)\n    })\n    .then(formattedNote => {\n      response.json(formattedNote)\n    })\n    .catch(error => {\n      console.log(error)\n      response.status(500).json({ error: 'something went wrong...' })\n    })\n</code></pre>\n<p>Konsoliin tulostuu seuraava virheilmoitus</p>\n<pre>\nError: Can't set headers after they are sent.\n    at validateHeader (_http_outgoing.js:489:11)\n    at ServerResponse.setHeader (_http_outgoing.js:496:3)\n</pre>\n<p>Aloittelijalle virheilmoitus ei välttämättä kerro paljoa, mutta googlaamalla virheilmoituksella, pieni etsiminen tuottaisi jo tuloksen.</p>\n<p>Kyse on siitä, että koodi kutsuu <em>response</em>-olion metodia <em>send</em> kaksi kertaa, tai oikeastaan koodi kutsuu metodia <em>json</em>, joka kutsuu edelleen metodia <em>send</em>.</p>\n<p>Kaksi kertaa tapahtuva <em>send</em>-kutsu johtuu siitä, että koodin alun <em>if</em>-lauseessa on ongelma:</p>\n<pre><code class=\"language-js\">notesRouter.post('/', (request, response) => {\n  const body = request.body\n\n  if (body.content === undefined) {\n    response.status(400).json({ error: 'content missing' })\n    // suoritus jatkuu!\n  }\n\n  //...\n}\n</code></pre>\n<p>kun koodi kutsuu <code>response.status(400).json(...)</code> suoritus jatkaa koodin alla olevaa osaan ja se taas aiheuttaa uuden <code>response.json()</code>-kutsun.</p>\n<p>Korjataan ongelma lisäämällä <em>if</em>-lauseeseen <em>return</em>:</p>\n<pre><code class=\"language-js\">notesRouter.post('/', (request, response) => {\n  const body = request.body\n\n  if (body.content === undefined) {\n    return response.status(400).json({ error: 'content missing' })\n  }\n\n  //...\n}\n</code></pre>\n<p>Edellisen osan lopussa koodi oli vielä oikein, mutta siirtäessämme osan alussa koodia tiedostosta <em>index.js</em> uuteen paikkaan, on <em>return</em> kadonnut matkalta.</p>\n<p>Promiseja käyttävä koodi toimii nyt ja testitkin menevät läpi. Olemme valmiit muuttamaan koodin käyttämään async/await-syntaksia.</p>\n<p>Koodi muuttuu seuraavasti (huomaa, että käsittelijän alkuun on laitettava määre <em>async</em>):</p>\n<pre><code class=\"language-js\">notesRouter.post('/', async (request, response) => {\n  const body = request.body;\n\n  if (body.content === undefined) {\n    return response.status(400).json({ error: 'content missing' });\n  }\n\n  const note = new Note({\n    content: body.content,\n    important: body.important === undefined ? false : body.important,\n    date: new Date(),\n  });\n\n  const savedNote = await note.save();\n  response.json(formatNote(savedNote));\n});\n</code></pre>\n<p>Koodiin jää kuitenkin pieni ongelma: virhetilanteita ei nyt käsitellä ollenkaan. Miten niiden suhteen tulisi toimia?</p>\n</div>","frontmatter":{"title":"osa 4","subTitle":"Node.js -sovellusten testaus","path":"/osa4/node-testaus","mainImage":{"publicURL":"/static/osa5-8edc6044aad809a3143dc36c5e7f3b4c.png"},"partColor":"yellow","part":4,"letter":"b"}}},"pageContext":{}}