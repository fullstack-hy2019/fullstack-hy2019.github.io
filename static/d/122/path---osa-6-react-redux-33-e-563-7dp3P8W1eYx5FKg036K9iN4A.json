{"data":{"markdownRemark":{"html":"<div class=\"content\">\n<h2>Muistiinpano-sovelluksen refaktorointia</h2>\n<p>Jatketaan osan 5 loppupuolella tehdyn muistiinpanosovelluksen yksinkertaistetun <a href=\"/osa5#redux-muistiinpanot\">redux-version</a> laajentamista.</p>\n<p>Sovelluksen tämänhetkinen koodi on <a href=\"https://github.com/FullStack-HY/redux-notes/tree/part5-6\">githubissa</a> tagissa <em>part5-6</em>.</p>\n<p>Tehdään koodiin muutamia rakenteellisia muutoksia. Siirretään reducerin määrittelevä tiedosto <em>noteReducer.js</em> hakemistoon <em>src/reducers</em>.</p>\n<p>Sovelluskehitystä helpottaaksemme laajennetaan reduceria siten, että storelle määritellään alkutila, jossa on pari muistiinpanoa:</p>\n<pre><code class=\"language-js\">const initialState = [\n  {\n    content: 'reduxin storen toiminnan määrittelee reduceri',\n    important: true,\n    id: 1,\n  },\n  {\n    content: 'storen tilassa voi olla mielivaltaista dataa',\n    important: false,\n    id: 2,\n  },\n];\nconst noteReducer = (state = initialState, action) => {\n  // ...\n};\n\nexport default noteReducer;\n</code></pre>\n<p>Siirretään <a href=\"https://redux.js.org/advanced/async-actions#synchronous-action-creators\">action creatorit</a>, eli sopivia <a href=\"https://redux.js.org/basics/actions\">action</a>-olioita generoivat apufunktiot reducerin kanssa samaan moduuliin:</p>\n<pre><code class=\"language-js\">const initialState = [\n  {\n    content: 'reduxin storen toiminnan määrittelee reduceri',\n    important: true,\n    id: 1,\n  },\n  {\n    content: 'storen tilassa voi olla mielivaltaista dataa',\n    important: false,\n    id: 2,\n  },\n];\n\nconst noteReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case 'NEW_NOTE':\n      return [...state, action.data];\n    case 'TOGGLE_IMPORTANCE':\n      const id = action.data.id;\n      const noteToChange = state.find(n => n.id === id);\n      const changedNote = {\n        ...noteToChange,\n        important: !noteToChange.important,\n      };\n      return state.map(note => (note.id !== id ? note : changedNote));\n    default:\n      return state;\n  }\n};\n\nconst generateId = () => Number((Math.random() * 1000000).toFixed(0));\n\nexport const noteCreation = content => {\n  return {\n    type: 'NEW_NOTE',\n    data: {\n      content,\n      important: false,\n      id: generateId(),\n    },\n  };\n};\n\nexport const importanceToggling = id => {\n  return {\n    type: 'TOGGLE_IMPORTANCE',\n    data: { id },\n  };\n};\n\nexport default noteReducer;\n</code></pre>\n<p>Moduulissa on nyt useita <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export\">export</a>-komentoja.</p>\n<p>Reducer-funktio palautetaan edelleen komennolla <em>export default</em>. Tämän ansiosta reducer importataan (tiedostossa <em>index.js</em>) tuttuun tapaan:</p>\n<pre><code class=\"language-js\">import noteReducer from './reducers/noteReducer';\n</code></pre>\n<p>Moduulilla voi olla vain <em>yksi default export</em>, mutta useita \"normaaleja\" exporteja, kuten <em>Action creator</em> -funktiot esimerkissämme</p>\n<pre><code class=\"language-js\">export const noteCreation = content => {\n  // ...\n};\n\nexport const importanceToggling = id => {\n  // ...\n};\n</code></pre>\n<p>Normaalisti exportattujen funktioiden käyttöönotto tapahtuu aaltosulkusyntaksilla:</p>\n<pre><code class=\"language-js\">import { noteCreation } from './../reducers/noteReducer';\n</code></pre>\n<p>Sovelluksen tämänhetkinen koodi on <a href=\"https://github.com/FullStack-HY/redux-notes/tree/part6-1\">githubissa</a> tagissä <em>part6-1</em>.</p>\n<h2>ESlint</h2>\n<p>Konfiguroimme osassa 3 koodin tyylistä huolehtivan <a href=\"/osa3#lint\">ESlintin</a> backendiin. Otetaan nyt ESlint käyttöön myös frontendissa.</p>\n<p>Create-react-app on asentanut projektille eslintin valmiiksi, joten ei tarvita muuta kun sopiva konfiguraatio tiedoston <em>.eslintrc.js</em>.</p>\n<p>Tiedoston voi generoida komennolla</p>\n<pre><code class=\"language-bash\">npx eslint --init\n</code></pre>\n<p>ja vastailemalla sopivasti kysymyksiin:</p>\n<picture><img src=\"/static/354495f1cf3ab7a581a690e6c465f45f/14be6/1a.png\" srcset=\"/static/354495f1cf3ab7a581a690e6c465f45f/4cce7/1a.png 200w,\n/static/354495f1cf3ab7a581a690e6c465f45f/bae5f/1a.png 400w,\n/static/354495f1cf3ab7a581a690e6c465f45f/14be6/1a.png 800w,\n/static/354495f1cf3ab7a581a690e6c465f45f/11572/1a.png 1116w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Jotta pääsemme eroon testeissä olevista turhista huomautuksista asennetaan <a href=\"https://www.npmjs.com/package/eslint-plugin-jest\">eslint-jest-plugin</a></p>\n<pre><code class=\"language-bash\">npm add --save-dev eslint-plugin-jest\n</code></pre>\n<p>ja otetaan se käyttöön manuaalin opastamalla tavalla.</p>\n<p>Jos vastailit initialisoinnissa kysymyksiin kuvan osoittamalla tavalla, asentuu projektiin <a href=\"https://github.com/yannickcr/eslint-plugin-react\">eslint-plugin-react</a>. Laajennetaan konfiguraatiota pluginin <a href=\"https://github.com/yannickcr/eslint-plugin-react#configuration\">manuaalin</a> ohjeen mukaan.</p>\n<p>Joudumme asentamaan myös <a href=\"https://github.com/babel/babel-eslint\">babel-eslint</a>-pluginin, jotta ESlint osaisi tulkita koodissa käyttämäämme <em>class property</em> -syntaksia. Pluginin asennus tapahtuu komennolla</p>\n<pre><code class=\"language-bash\">npm install babel-eslint --save-dev\n</code></pre>\n<p>ja se tulee muistaa ottaa käyttöön konfiguraatiossa.</p>\n<p>Seuraavassa lopullinen konfiguraatio, mihin on lisätty muutama muukin osassa 3 käyttöönotettu sääntö:</p>\n<pre><code class=\"language-bash\">module.exports = {\n    \"env\": {\n        \"browser\": true,\n        \"es6\": true,\n        \"jest/globals\": true\n    },\n    \"extends\": [\n        \"eslint:recommended\",\n        \"plugin:react/recommended\"\n    ],\n    \"parser\": \"babel-eslint\",\n    \"parserOptions\": {\n        \"ecmaFeatures\": {\n            \"jsx\": true\n        },\n        \"ecmaVersion\": 2018,\n        \"sourceType\": \"module\"\n    },\n    \"plugins\": [\n        \"react\", \"jest\"\n    ],\n    \"rules\": {\n        \"indent\": [\n            \"error\",\n            2\n        ],\n        \"linebreak-style\": [\n            \"error\",\n            \"unix\"\n        ],\n        \"quotes\": [\n            \"error\",\n            \"single\"\n        ],\n        \"semi\": [\n            \"error\",\n            \"never\"\n        ],\n        \"eqeqeq\": \"error\",\n        \"no-trailing-spaces\": \"error\",\n        \"object-curly-spacing\": [\n            \"error\", \"always\"\n        ],\n        \"arrow-spacing\": [\n            \"error\", { \"before\": true, \"after\": true }\n        ],\n        \"no-console\": 0,\n        \"react/prop-types\": 0\n    }\n};\n</code></pre>\n<h2>Monimutkaisempi tila storessa</h2>\n<p>Toteutetaan sovellukseen näytettävien muistiinpanojen filtteröinti, jonka avulla näytettäviä muistiinpanoja voidaan rajata. Filtterin toteutus tapahtuu <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/radio\">radiobuttoneiden</a> avulla:</p>\n<picture><img src=\"/static/e3c779c1ee086430ef1ca18b298a87f1/14be6/1.png\" srcset=\"/static/e3c779c1ee086430ef1ca18b298a87f1/4cce7/1.png 200w,\n/static/e3c779c1ee086430ef1ca18b298a87f1/bae5f/1.png 400w,\n/static/e3c779c1ee086430ef1ca18b298a87f1/14be6/1.png 800w,\n/static/e3c779c1ee086430ef1ca18b298a87f1/1b35a/1.png 1200w,\n/static/e3c779c1ee086430ef1ca18b298a87f1/2c91e/1.png 1548w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Aloitetaan todella suoraviivaisella toteutuksella:</p>\n<pre><code class=\"language-react\">class App extends React.Component {\n  filterSelected = (value) => () => {\n    console.log(value)\n  }\n  render() {\n    return (\n      &#x3C;div>\n        &#x3C;NoteForm />\n        &#x3C;div>\n          kaikki    &#x3C;input type=\"radio\" name=\"filter\"\n                      onChange={this.filterSelected('ALL')}/>\n          tärkeät   &#x3C;input type=\"radio\" name=\"filter\"\n                      onChange={this.filterSelected('IMPORTANT')}/>\n          eitärkeät &#x3C;input type=\"radio\" name=\"filter\"\n                      onChange={this.filterSelected('NONIMPORTANT')}/>\n        &#x3C;/div>\n        &#x3C;NoteList />\n      &#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<p>Koska painikkeiden attribuutin <em>name</em> arvo on kaikilla sama, muodostavat ne <em>nappiryhmän</em>, joista ainoastaan yksi voi olla kerrallaan valittuna.</p>\n<p>Napeille on määritelty muutoksenkäsittelijä, joka tällä hetkellä ainoastaan tulostaa painettua nappia vastaavan merkkijonon konsoliin.</p>\n<p>Päätämme toteuttaa filtteröinnin siten, että talletamme muistiinpanojen lisäksi sovelluksen storeen myös <em>filtterin arvon</em>. Eli muutoksen jälkeen storessa olevan tilan tulisi näyttää seuraavalta:</p>\n<pre><code class=\"language-js\">{\n  notes: [\n    { content: 'reduxin storen toiminnan määrittelee reduceri', important: true, id: 1},\n    { content: 'storen tilassa voi olla mielivaltaista dataa', important: false, id: 2}\n  ],\n  filter: 'IMPORTANT'\n}\n</code></pre>\n<p>Tällä hetkellähän tilassa on ainoastaan muistiinpanot sisältävä taulukko. Uudessa ratkaisussa tilalla on siis kaksi avainta, <em>notes</em> jonka arvona muistiinpanot ovat sekä <em>filter</em>, jonka arvona on merkkijono joka kertoo mitkä muistiinpanoista tulisi näyttää ruudulla.</p>\n<h3>Yhdistetyt reducerit</h3>\n<p>Voisimme periaatteessa muokata jo olemassaolevaa reduceria ottamaan huomioon muuttuneen tilanteen. Parempi ratkaisu on kuitenkin määritellä tässä tilanteessa uusi, filtterin arvosta huolehtiva reduceri:</p>\n<pre><code class=\"language-js\">const filterReducer = (state = 'ALL', action) => {\n  switch (action.type) {\n    case 'SET_FILTER':\n      return action.filter;\n    default:\n      return state;\n  }\n};\n</code></pre>\n<p>Filtterin arvon asettavat actionit ovat siis muotoa</p>\n<pre><code class=\"language-js\">{\n  type: 'SET_FILTER',\n  filter: 'IMPORTANT'\n}\n</code></pre>\n<p>Määritellään samalla myös sopiva <em>action creator</em> -funktio. Sijoitetaan koodi moduuliin <em>src/reducers/filterReducer.js</em>:</p>\n<pre><code class=\"language-js\">const filterReducer = (state = 'ALL', action) => {\n  // ...\n};\n\nexport const filterChange = filter => {\n  return {\n    type: 'SET_FILTER',\n    filter,\n  };\n};\n\nexport default filterReducer;\n</code></pre>\n<p>Saamme nyt muodostettua varsinaisen reducerin yhdistämällä kaksi olemassaolevaa reduceria funktion <a href=\"https://redux.js.org/api-reference/combinereducers\">combineReducers</a> avulla.</p>\n<p>Määritellään yhdistetty reduceri tiedostossa <em>index.js</em>:</p>\n<pre><code class=\"language-react\">import React from 'react'\nimport ReactDOM from 'react-dom'\nimport { createStore, combineReducers } from 'redux'\nimport { Provider } from 'react-redux'\nimport App from './App'\nimport noteReducer from './reducers/noteReducer'\nimport filterReducer from './reducers/filterReducer'\n\nconst reducer = combineReducers({\n  notes: noteReducer,\n  filter: filterReducer\n})\n\nconst store = createStore(reducer)\n\nconsole.log(store.getState())\n\nReactDOM.render(\n  &#x3C;Provider store={store}>\n    &#x3C;div> &#x3C;/div>\n  &#x3C;/Provider>,\ndocument.getElementById('root'))\n</code></pre>\n<p>Koska sovelluksemme hajoaa tässä vaiheessa täysin, komponentin <em>App</em> sijasta renderöidään tyhjä <em>div</em>-elementti.</p>\n<p>Konsoliin tulostuu storen tila:</p>\n<picture><img src=\"/static/5051fd826fdf82f90e9326b9b2e82875/14be6/2.png\" srcset=\"/static/5051fd826fdf82f90e9326b9b2e82875/4cce7/2.png 200w,\n/static/5051fd826fdf82f90e9326b9b2e82875/bae5f/2.png 400w,\n/static/5051fd826fdf82f90e9326b9b2e82875/14be6/2.png 800w,\n/static/5051fd826fdf82f90e9326b9b2e82875/1b35a/2.png 1200w,\n/static/5051fd826fdf82f90e9326b9b2e82875/9ee03/2.png 1600w,\n/static/5051fd826fdf82f90e9326b9b2e82875/4f68a/2.png 1874w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>eli store on juuri siinä muodossa missä haluammekin sen olevan!</p>\n<p>Tarkastellaan vielä yhdistetyn reducerin luomista</p>\n<pre><code class=\"language-js\">const reducer = combineReducers({\n  notes: noteReducer,\n  filter: filterReducer,\n});\n</code></pre>\n<p>Näin tehdyn reducerin määrittelemän storen tila on olio, jossa on kaksi kenttää, <em>notes</em> ja <em>filter</em>. Tilan kentän <em>notes</em> arvon määrittelee <em>noteReducer</em>, jonka ei tarvitse välittää mitään tilan muista kentistä. Vastaavasti <em>filter</em> kentän käsittely tapahtuu <em>filterReducer</em>:in avulla.</p>\n<p>Ennen muun koodin muutoksia, kokeillaan vielä konsolista, miten actionit muuttavat yhdistetyn reducerin muodostamaa staten tilaa:</p>\n<pre><code class=\"language-js\">//...\nimport noteReducer, { noteCreation } from './reducers/noteReducer';\nimport filterReducer, { filterChange } from './reducers/filterReducer';\n\nconst reducer = combineReducers({\n  notes: noteReducer,\n  filter: filterReducer,\n});\n\nconst store = createStore(reducer);\nstore.subscribe(() => console.log(store.getState()));\nconsole.log(store.getState());\nstore.dispatch(filterChange('IMPORTANT'));\nstore.dispatch(noteCreation('combineReducers muodostaa yhdistetyn reducerin'));\n</code></pre>\n<p>Konsoliin tulostuu storen tila:</p>\n<picture><img src=\"/static/83a1b076646fee2dc3280855e651286c/14be6/3.png\" srcset=\"/static/83a1b076646fee2dc3280855e651286c/4cce7/3.png 200w,\n/static/83a1b076646fee2dc3280855e651286c/bae5f/3.png 400w,\n/static/83a1b076646fee2dc3280855e651286c/14be6/3.png 800w,\n/static/83a1b076646fee2dc3280855e651286c/1b35a/3.png 1200w,\n/static/83a1b076646fee2dc3280855e651286c/9ee03/3.png 1600w,\n/static/83a1b076646fee2dc3280855e651286c/a5108/3.png 1726w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Jo tässä vaiheessa kannattaa laittaa mieleen eräs tärkeä detalji. Jos lisäämme <em>molempien reducerien alkuun</em> konsoliin tulostuksen:</p>\n<pre><code class=\"language-js\">const filterReducer = (state = 'ALL', action) => {\n  console.log('ACTION: ', action);\n  // ...\n};\n</code></pre>\n<p>Näyttää konsolin perusteella siltä, että jokainen action kahdentuu:</p>\n<picture><img src=\"/static/430abd5399e0ac8080e0d93a83683c41/14be6/4.png\" srcset=\"/static/430abd5399e0ac8080e0d93a83683c41/4cce7/4.png 200w,\n/static/430abd5399e0ac8080e0d93a83683c41/bae5f/4.png 400w,\n/static/430abd5399e0ac8080e0d93a83683c41/14be6/4.png 800w,\n/static/430abd5399e0ac8080e0d93a83683c41/1b35a/4.png 1200w,\n/static/430abd5399e0ac8080e0d93a83683c41/248be/4.png 1578w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Onko koodissa bugi? Ei. Yhdistetty reducer toimii siten, että jokainen <em>action</em> käsitellään <em>kaikissa</em> yhdistetyn reducerin osissa. Usein tietystä actionista on kiinnostunut vain yksi reduceri, on kuitenkin tilanteita, joissa useampi reduceri muuttaa hallitsemaansa staten tilaa jonkin actionin seurauksena.</p>\n<h3>Sovelluksen viimeistely</h3>\n<p>Viimeistellään nyt sovellus käyttämään yhdistettyä reduceria, eli palautetaan tiedostossa <em>index.js</em> suoritettava renderöinti muotoon</p>\n<pre><code class=\"language-react\">ReactDOM.render(\n  &#x3C;Provider store={store}>\n    &#x3C;App />\n  &#x3C;/Provider>,\n  document.getElementById('root'))\n</code></pre>\n<p>Korjataan sitten bugi, joka johtuu siitä, että koodi olettaa storen tilan olevan mustiinpanot tallettava taulukko:</p>\n<picture><img src=\"/static/bdf7db7bc2a52ec058453dd1bf264eff/14be6/5.png\" srcset=\"/static/bdf7db7bc2a52ec058453dd1bf264eff/4cce7/5.png 200w,\n/static/bdf7db7bc2a52ec058453dd1bf264eff/bae5f/5.png 400w,\n/static/bdf7db7bc2a52ec058453dd1bf264eff/14be6/5.png 800w,\n/static/bdf7db7bc2a52ec058453dd1bf264eff/1b35a/5.png 1200w,\n/static/bdf7db7bc2a52ec058453dd1bf264eff/9ee03/5.png 1600w,\n/static/bdf7db7bc2a52ec058453dd1bf264eff/4ba44/5.png 1660w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Korjaus on helppo. Viitteen <code>this.context.store.getState()</code> sijaan kaikki muistiinpanot sisältävään taulukkoon viitataan <code>this.context.store.getState().notes</code>.</p>\n<p>Ennakoiden tulevaa eriytetään näytettävien muistiinpanojen selvittämisen huolehtiminen funktioon <em>notesToShow</em>, joka vielä tässä vaiheessa palauttaa kaikki muistiinpanot:</p>\n<pre><code class=\"language-react\">class NoteList extends React.Component {\n  // ...\n\n  render() {\n    const notesToShow = () => {\n      return this.context.store.getState().notes\n    }\n\n    return (\n      &#x3C;ul>\n        {notesToShow().map(note =>\n          &#x3C;Note\n            key={note.id}\n            note={note}\n            handleClick={this.toggleImportance(note.id)}\n          />\n        )}\n      &#x3C;/ul>\n    )\n  }\n}\n</code></pre>\n<p>Eriytetään näkyvyyden säätelyfiltteri omaksi, tiedostoon sijoitettavaksi <em>src/components/VisibilityFilter.js</em> komponentiksi:</p>\n<pre><code class=\"language-react\">import React from 'react'\nimport PropTypes from 'prop-types'\nimport { filterChange } from '../reducers/filterReducer'\n\nclass VisibilityFilter extends React.Component {\n  componentDidMount() {\n    const { store } = this.context\n    this.unsubscribe = store.subscribe(() =>\n      this.forceUpdate()\n    )\n  }\n\n  componentWillUnmount() {\n    this.unsubscribe()\n  }\n\n  filterClicked = (value) => () => {\n    this.context.store.dispatch(filterChange(value))\n  }\n\n  render() {\n    return (\n      &#x3C;div>\n        kaikki    &#x3C;input type=\"radio\" name=\"filter\" onChange={this.filterClicked('ALL')} />\n        tärkeät   &#x3C;input type=\"radio\" name=\"filter\" onChange={this.filterClicked('IMPORTANT')} />\n        eitärkeät &#x3C;input type=\"radio\" name=\"filter\" onChange={this.filterClicked('NONIMPORTANT')} />\n      &#x3C;/div>\n    )\n  }\n}\n\nVisibilityFilter.contextTypes = {\n  store: PropTypes.object\n}\n\nexport default VisibilityFilter\n</code></pre>\n<p>Toteutus on suoraviivainen, radiobuttonin klikkaaminen muuttaa storen kentän <em>filter</em> tilaa.</p>\n<p>Muutetaan vielä komponentin <em>NoteList</em> metodi <em>notesToShow</em> ottamaan huomioon filtteri</p>\n<pre><code class=\"language-js\">const notesToShow = () => {\n  const { notes, filter } = this.context.store.getState();\n  if (filter === 'ALL') {\n    return notes;\n  }\n\n  return filter === 'IMPORTANT'\n    ? notes.filter(note => note.important)\n    : notes.filter(note => !note.important);\n};\n</code></pre>\n<p>Huomaa miten storen tilan kentät on otettu tuttuun tapaan destrukturoimalla apumuuttujiin</p>\n<pre><code class=\"language-js\">const { notes, filter } = this.context.store.getState();\n</code></pre>\n<p>siis on sama kuin kirjoittaisimme</p>\n<pre><code class=\"language-js\">const notes = this.context.store.getState().notes;\nconst filter = this.context.store.getState().filter;\n</code></pre>\n<p>Sovelluksen tämänhetkinen koodi on <a href=\"https://github.com/FullStack-HY/redux-notes/tree/part6-2\">githubissa</a> tagissä <em>part6-2</em>.</p>\n<p>Sovelluksessa on vielä pieni kauneusvirhe, vaikka oletusarvosesti filtterin arvo on <em>ALL</em>, eli näytetään kaikki muistiinpanot, ei vastaava radiobutton ole valittuna. Ongelma on luonnollisestikin mahdollista korjata, mutta koska kyseessä on ikävä, mutta harmiton feature, jätämme korjauksen myöhemmäksi.</p>\n<h2>Tehtäviä</h2>\n<p>Tee nyt tehtävät <a href=\"/teht%C3%A4v%C3%A4t/#osa-6\">6.1-6.5</a></p>\n<h2>Connect</h2>\n<p>Kaikissa Redux-storea käyttävissä komponenteissa on runsaasti samaa koodia</p>\n<pre><code class=\"language-js\">class ComponentUsingReduxStore extends React.Component {\n  componentDidMount() {\n    const { store } = this.context;\n    this.unsubscribe = store.subscribe(() => this.forceUpdate());\n  }\n\n  componentWillUnmount() {\n    this.unsubscribe();\n  }\n}\n\nComponentUsingReduxStore.contextTypes = {\n  store: PropTypes.object,\n};\n</code></pre>\n<p>Vaikka rivit on helppo copy-pasteta aina uusiin komponentteihin, ei tämä ole tarkoituksenmukaista. Osan 5 luvussa <a href=\"/osa5#staten-v%C3%A4litt%C3%A4minen-propseissa-ja-contextissa\">staten välittäminen propseissa ja contextissa</a> myös varoiteltiin luottamasta liikaa Reactin Context API:iin, se on kokeellinen ja saattaa poistua tulevissa versioissa. Contextia on siis ainakin tässä vaiheessa käytettävä varovasti.</p>\n<p><a href=\"https://github.com/reactjs/react-redux\">React Redux</a> -kirjaston määrittelemä funktio <a href=\"https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options\">connect</a> on paras ratkaisu siihen, miten Redux-store saadaan välitettyä React-componenteille.</p>\n<p>Connect voi olla aluksi haastava sisäistää, mutta hieman vaivaa kannattaa ehdottomasti nähdä. Tutustutaan nyt connectin käyttöön. Asensimme jo edellisessä osassa kirjaston, joten voimme aloittaa sen käytön suoraan.</p>\n<p>Tutkitaan ensin komponenttia <em>NoteList</em>. Funktiota <em>connect</em> käyttämällä \"normaaleista\" React-komponenteista saadaan muodostettua komponentteja, joiden <em>propseihin</em> on \"mäpätty\" eli yhdistetty haluttuja osia storen määrittelemästä tilasta.</p>\n<p>Muodostetaan ensin komponentista <em>NoteList</em> connectin avulla <em>yhdistetty komponentti</em>:</p>\n<pre><code class=\"language-js\">// ...\nimport { connect } from 'react-redux';\n\nclass NoteList extends React.Component {\n  // ...\n}\n\nconst ConnectedNoteList = connect()(NoteList);\n\nexport default ConnectedNoteList;\n</code></pre>\n<p>Moduuli eksporttaa nyt alkuperäisen komponentin sijaan <em>yhdistetyn komponentin</em>, joka toimii toistaiseksi täsmälleen alkuperäisen komponentin kaltaisesti.</p>\n<p>Komponentti tarvitsee storesta sekä muistiinpanojen listan, että filtterin arvon. Funktion <em>connect</em> ensimmäisenä parametrina voidaan määritellä funktio <a href=\"https://github.com/reactjs/react-redux/blob/master/docs/api.md#arguments\">mapStateToProps</a>, joka liittää joitakin storen tilan perusteella määriteltyjä asioita connectilla muodostetun <em>yhdistetyn komponentin</em> propseiksi.</p>\n<p>Jos määritellään:</p>\n<pre><code class=\"language-js\">const mapStateToProps = state => {\n  return {\n    notes: state.notes,\n    filter: state.filter,\n  };\n};\n\nconst ConnectedNoteList = connect(mapStateToProps)(NoteList);\n\nexport default ConnectedNoteList;\n</code></pre>\n<p>on komponentin <em>NoteList</em> sisällä mahdollista viitata storen tilaan, esim. muistiinpanoihin suoraan propsin kautta <em>props.notes</em> sen sijaan, että käytettäisiin suoraan contextia muodossa <em>this.context.store.getState().notes</em>. Vastaavasti <em>props.filter</em> viittaa storessa olevaan filter-kentän tilaan.</p>\n<p>Metodin <em>render</em> sisältö pelkistyy seuraavasti</p>\n<pre><code class=\"language-js\">class NoteList extends React.Component {\n  render() {\n    const notesToShow = () => {\n      const { notes, filter } = this.props;\n      if (filter === 'ALL') {\n        return notes;\n      }\n\n      return filter === 'IMPORTANT'\n        ? notes.filter(note => note.important)\n        : notes.filter(note => !note.important);\n    };\n\n    // ...\n  }\n}\n</code></pre>\n<p>Connect-komennolla, ja <em>mapStateToProps</em>-määrittelyllä aikaan saatua tilannetta voidaan visualisoida seuraavasti:</p>\n<picture><img src=\"/static/9b0db201aaba8e035a782f2f07364ab2/14be6/5b.png\" srcset=\"/static/9b0db201aaba8e035a782f2f07364ab2/4cce7/5b.png 200w,\n/static/9b0db201aaba8e035a782f2f07364ab2/bae5f/5b.png 400w,\n/static/9b0db201aaba8e035a782f2f07364ab2/14be6/5b.png 800w,\n/static/9b0db201aaba8e035a782f2f07364ab2/1b35a/5b.png 1200w,\n/static/9b0db201aaba8e035a782f2f07364ab2/2e309/5b.png 1382w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>eli komponentin <em>NoteList</em> sisältä on propsien <em>props.notes</em> ja <em>props.filter</em> kautta \"suora pääsy\" tarkastelemaan Redux storen sisällä olevaa tilaa.</p>\n<p><em>NoteList</em> viittaa edelleen suoraan kontekstin kautta storen metodiin <em>dispatch</em>, jota se tarvitsee action creatorin <em>importanceToggling</em> avulla tehdyn actionin dispatchaamiseen:</p>\n<pre><code class=\"language-js\">toggleImportance = (id) => () => {\n  this.context.store.dispatch(\n    importanceToggling(id)\n  )\n</code></pre>\n<p>Connect-funktion toisena parametrina voidaan määritellä <a href=\"https://github.com/reactjs/react-redux/blob/master/docs/api.md#arguments\">mapDispatchToProps</a> eli joukko <em>action creator</em> -funktioita, jotka välitetään yhdistetylle komponentille propseina. Laajennetaan connectausta seuraavasti</p>\n<pre><code class=\"language-js\">const mapStateToProps = state => {\n  return {\n    notes: state.notes,\n    filter: state.filter,\n  };\n};\n\nconst mapDispatchToProps = {\n  importanceToggling,\n};\n\nconst ConnectedNoteList = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(NoteList);\n\nexport default ConnectedNoteList;\n</code></pre>\n<p>Nyt komponentti voi dispatchata suoraan action creatorin <em>importanceToggling</em> määrittelemän actionin kutsumalla propsien kautta saamaansa funktiota koodissa:</p>\n<pre><code class=\"language-js\">class NoteList extends React.Component {\n  toggleImportance = id => () => {\n    this.props.importanceToggling(id);\n  };\n\n  // ...\n}\n</code></pre>\n<p>Storen <em>dispatch</em>-funktiota ei enää tarvitse kutsua, sillä <em>connect</em> on muokannut action creatorin <em>importanceToggling</em> sellaiseen muotoon, joka sisältää dispatchauksen.</p>\n<p><em>mapDispatchToProps</em> lienee aluksi hieman haastava ymmärtää, etenkin sen kohta käsiteltävä <a href=\"/osa6/#mapdispatchtopropsin-vaihtoehtoinen-k%C3%A4ytt%C3%B6tapa\">vaihtoehtoinen käyttötapa</a>.</p>\n<p>Connectin aikaansaamaa tilannetta voidaan havainnollistaa seuraavasti:</p>\n<picture><img src=\"/static/f41667cdd6a8f0dfb230ba0207d60a20/14be6/5c.png\" srcset=\"/static/f41667cdd6a8f0dfb230ba0207d60a20/4cce7/5c.png 200w,\n/static/f41667cdd6a8f0dfb230ba0207d60a20/bae5f/5c.png 400w,\n/static/f41667cdd6a8f0dfb230ba0207d60a20/14be6/5c.png 800w,\n/static/f41667cdd6a8f0dfb230ba0207d60a20/1b35a/5c.png 1200w,\n/static/f41667cdd6a8f0dfb230ba0207d60a20/78a53/5c.png 1564w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>eli sen lisäksi että <em>NoteList</em> pääsee storen tilaan propsien <em>props.notes</em> ja <em>props.filter</em> kautta, se viittaa <em>props.importanceToggling</em>:lla funktioon, jonka avulla storeen saadaan dispatchattua <em>TOGGLE</em>IMPORTANCE_-tyyppisiä actioneja.</p>\n<p>Koska komponentti saa storeen liittyvät asiat propseina, voidaan koodista poistaa metodit <em>componentDidMount</em> ja <em>componentWillUnMount</em> jotka huolehtivat komponentin uudelleenrenderöitymisestä storen tilan muuttuessa. Connect tekee tämän puolestamme.</p>\n<p>Komponentti <em>NoteList</em> ei tarvitse storea enää mihinkään, se saa kaiken tarvitsemansa propseina <em>connect</em>-funktion ansiosta. Komponentti ei käytä enää suoraan contextia, joten koodi yksinkertaistuu seuraavaan muotoon:</p>\n<pre><code class=\"language-react\">import React from 'react'\nimport { connect } from 'react-redux'\nimport { importanceToggling } from './../reducers/noteReducer'\nimport Note from './Note'\n\nclass NoteList extends React.Component {\n  render() {\n    const notesToShow = () => {\n      const { notes, filter } = this.props\n      if (filter === 'ALL') {\n        return notes\n      }\n\n      return filter === 'IMPORTANT'\n        ? notes.filter(note => note.important)\n        : notes.filter(note => !note.important)\n    }\n\n    return (\n      &#x3C;ul>\n        {notesToShow().map(note =>\n          &#x3C;Note\n            key={note.id}\n            note={note}\n            handleClick={() => this.props.importanceToggling(note.id)}\n          />\n        )}\n      &#x3C;/ul>\n    )\n  }\n}\n\nconst mapStateToProps = (state) => {\n  return {\n    notes: state.notes,\n    filter: state.filter\n  }\n}\n\nconst ConnectedNoteList = connect(\n  mapStateToProps,\n  { importanceToggling }\n)(NoteList)\n\nexport default ConnectedNoteList\n</code></pre>\n<p>Koodi sisältää pari muutakin oikaisua, mm. apumetodista <em>toggleImportance</em> on hankkiuduttu eroon.\nItseasiassa komponentti on nyt niin yksinkertainen että se voitaisiin määritellä funktionaalisena komponenttina. Emme kuitenkaan tee muutosta nyt.</p>\n<p>Otetaan <em>connect</em> käyttöön myös uuden muistiinpanon luomisessa:</p>\n<pre><code class=\"language-react\">import React from 'react'\nimport { noteCreation } from './../reducers/noteReducer'\nimport { connect } from 'react-redux'\n\nclass NoteForm extends React.Component {\n\n  addNote = (event) => {\n    event.preventDefault()\n    this.props.noteCreation(event.target.note.value)\n    event.target.note.value = ''\n  }\n\n  render() {\n    return (\n      &#x3C;form onSubmit={this.addNote}>\n        &#x3C;input name=\"note\" />\n        &#x3C;button>lisää&#x3C;/button>\n      &#x3C;/form>\n    )\n  }\n}\n\nexport default connect(\n  null,\n  { noteCreation }\n)(NoteForm)\n</code></pre>\n<p>Koska komponentti ei tarvitse storen tilasta mitään, on funktion <em>connect</em> ensimmäinen parametri <em>null</em>.</p>\n<p>Sovelluksen tämänhetkinen koodi on <a href=\"https://github.com/FullStack-HY/redux-notes/tree/part6-3\">githubissa</a> tagissä <em>part6-3</em>.</p>\n<h3>Provider</h3>\n<p>Funktion <em>connect</em> käytön edellytyksenä on se, että sovellus on määritelty React redux kirjaston tarjoaman <a href=\"https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store\">Provider</a>-komponentin lapseksi ja että sovelluksen käyttämä store on annettu Provider-komponentin attribuutiksi <em>store</em>:</p>\n<pre><code class=\"language-react\">import React from 'react'\nimport ReactDOM from 'react-dom'\nimport { createStore, combineReducers } from 'redux'\nimport { Provider } from 'react-redux'\nimport App from './App'\nimport noteReducer from './reducers/noteReducer'\nimport filterReducer from './reducers/filterReducer'\n\nconst reducer = combineReducers({\n  notes: noteReducer,\n  filter: filterReducer\n})\n\nconst store = createStore(reducer)\n\nReactDOM.render(\n  &#x3C;Provider store={store}>\n    &#x3C;App />\n  &#x3C;/Provider>,\n  document.getElementById('root'))\n</code></pre>\n<p>Lisäsimme jo edellisen osan lopussa sovellukseen <em>Providerin</em>, joten <em>connect</em> oli tällä kertaa suoraan käytettävissä.</p>\n<h3>Huomio propsina välitettyyn action creatoriin viittaamisesta</h3>\n<p>Tarkastellaan vielä erästä mielenkiintoista seikkaa komponentista <em>NoteForm</em>:</p>\n<pre><code class=\"language-react\">import React from 'react'\nimport { noteCreation } from './../reducers/noteReducer'\nimport { connect } from 'react-redux'\n\nclass NoteForm extends React.Component {\n\n  addNote = (event) => {\n    event.preventDefault()\n    this.props.noteCreation(event.target.note.value)\n    event.target.note.value = ''\n  }\n\n  render() {\n    // ...\n  }\n}\n\nexport default connect(\n  null,\n  { noteCreation }\n)(NoteForm)\n</code></pre>\n<p>Aloittelevalle connectin käyttäjälle aiheuttaa joskus ihmetystä se, että action creatorista <em>noteCreation</em> on komponentin sisällä käytettävissä <em>kaksi eri versiota</em>.</p>\n<p>Funktioon tulee viitata propsien kautta, eli <em>this.props.noteCreation</em>, tällöin kyseessä on <em>connectin</em> muotoilema, <em>dispatchauksen sisältävä</em> versio funktiosta.</p>\n<p>Moduulissa olevan import-lauseen</p>\n<pre><code class=\"language-js\">import { noteCreation } from './../reducers/noteReducer';\n</code></pre>\n<p>ansiosta komponentin sisältä on mahdollista viitata funktioon myös suoraan, eli <em>noteCreation</em>. Näin ei kuitenkaan tule tehdä, sillä silloin on kyseessä alkuperäinen action creator joka <em>ei sisällä dispatchausta</em>.</p>\n<p>Jos tulostamme funktiot koodin sisällä (emme olekaan vielä käyttäneet kurssilla tätä erittäin hyödyllistä debug-kikkaa)</p>\n<pre><code class=\"language-react\">render() {\n  console.log(noteCreation)\n  console.log(this.props.noteCreation)\n  return (\n    &#x3C;form onSubmit={this.addNote}>\n      &#x3C;input name=\"note\" />\n      &#x3C;button>lisää&#x3C;/button>\n    &#x3C;/form>\n  )\n}\n</code></pre>\n<p>näemme eron:</p>\n<picture><img src=\"/static/eb383dd9fbafd64a8231aae424434fee/14be6/5d.png\" srcset=\"/static/eb383dd9fbafd64a8231aae424434fee/4cce7/5d.png 200w,\n/static/eb383dd9fbafd64a8231aae424434fee/bae5f/5d.png 400w,\n/static/eb383dd9fbafd64a8231aae424434fee/14be6/5d.png 800w,\n/static/eb383dd9fbafd64a8231aae424434fee/1b35a/5d.png 1200w,\n/static/eb383dd9fbafd64a8231aae424434fee/92884/5d.png 1378w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Ensimmäinen funktioista siis on normaali <em>action creator</em>, toinen taas connectin muotoilema funktio, joka sisältää storen metodin dispatch-kutsun.</p>\n<p>Connect on erittäin kätevä työkalu, mutta abstraktiutensa takia kenties käsitteellisesti haastavin kurssin tähänastisista asioista.</p>\n<p>Viimeistään nyt kannattaa katsoa kokonaisuudessaan Egghead.io:ta Reduxin kehittäjän Dan Abramovin loistava tuoriaali <a href=\"https://egghead.io/courses/getting-started-with-redux\">Getting started with Redux</a>. Neljässä viimeisessä videossa käsitellään <em>connect</em>-metodia.</p>\n<p>Siinä vaiheessa kun videot on tehty, connectin käyttö oli asteen verran nykyistä hankalampaa, sillä esimerkeissä käyttämämme tapa määritellä connectin toinen parametri <em>mapDispatchToProps</em> suoraan <em>action creator</em> -funktioiden avulla ei ollut vielä mahdollinen. Katsotaan seuraavassa luvussa lyhyesti vaihtoehtoista, \"hankalampaa\" tapaa, sitä näkee usein vanhemmassa React-koodissa, joten sen tunteminen on oleellista.</p>\n<h3>mapDispatchToPropsin vaihtoehtoinen käyttötapa</h3>\n<p>Määrittelimme siis connectin komponentille <em>NoteForm</em> antamat actioneja dispatchaavan funktion seuraavasti:</p>\n<pre><code class=\"language-js\">class NoteForm extends React.Component {\n  // ...\n}\n\nexport default connect(\n  null,\n  { noteCreation }\n)(NoteForm);\n</code></pre>\n<p>Eli määrittelyn ansiosta komponentti dispatchaa uuden muistiinpanon lisäyksen suorittavan actionin suoraan komennolla <code>this.props.noteCreation('uusi muistiinpano')</code>.</p>\n<p>Parametrin <em>mapDispatchToProps</em> kenttinä ei voi antaa mitä tahansa funktiota, vaan funktion on oltava <em>action creator</em>, eli Redux-actionin palauttava funktio.</p>\n<p>Kannattaa huomata, että parametri <em>mapDispatchToProps</em> on nyt <em>olio</em>, sillä määrittely</p>\n<pre><code class=\"language-js\">{\n  noteCreation;\n}\n</code></pre>\n<p>on lyhempi tapa määritellä olioliteraali</p>\n<pre><code class=\"language-js\">{\n  noteCreation: noteCreation;\n}\n</code></pre>\n<p>eli olio, jonka ainoan kentän <em>noteCreation</em> arvona on funktio <em>noteCreation</em>.</p>\n<p>Voimme määritellä saman myös \"pitemmän kaavan\" kautta, antamalla <em>connectin</em> toisena parametrina seuraavanlaisen <em>funktion</em>:</p>\n<pre><code class=\"language-js\">class NoteForm extends React.Component {\n  // ...\n}\n\nconst mapDispatchToProps = dispatch => {\n  return {\n    createTodo: value => {\n      dispatch(noteCreation(value));\n    },\n  };\n};\n\nexport default connect(\n  null,\n  mapDispatchToProps\n)(NoteForm);\n</code></pre>\n<p>Tässä vaihtoehtoisessa tavassa <em>mapDispatchToProps</em> on funktio, jota <em>connect</em> kutsuu antaen sille parametriksi storen <em>dispatch</em>-funktion. Funktion paluuarvona on olio, joka määrittelee joukon funktioita, jotka annetaan connectoitavalle komponentille propsiksi. Esimerkkimme määrittelee propsin <em>createTodo</em> olevan funktion</p>\n<pre><code class=\"language-js\">value => {\n  dispatch(noteCreation(value));\n};\n</code></pre>\n<p>eli action creatorilla luodun actionin dispatchaus.</p>\n<p>Komponentti siis viittaa funktioon propsin <em>this.props.createTodo</em> kautta:</p>\n<pre><code class=\"language-react\">class NoteForm extends React.Component {\n\n  addNote = (event) => {\n    event.preventDefault()\n    this.props.createTodo(event.target.note.value)\n    event.target.note.value = ''\n  }\n\n  render() {\n    return (\n      &#x3C;form onSubmit={this.addNote}>\n        &#x3C;input name=\"note\" />\n        &#x3C;button>lisää&#x3C;/button>\n      &#x3C;/form>\n    )\n  }\n}\n</code></pre>\n<p>Konsepti on hiukan monimutkainen ja sen selittäminen sanallisesti on haastavaa. Kannattaa katsoa huolellisesti Dan Abramovin videot ja koittaa miettiä mistä on kyse.</p>\n<p>Useimmissa tapauksissa riittää <em>mapDispatchToProps</em>:in yksinkertaisempi muoto. On kuitenkin tilanteita, joissa monimutkaisempi muoto on tarpeen, esim. jos määriteltäessä propseiksi mäpättyjä <em>dispatchattavia actioneja</em> on <a href=\"https://github.com/gaearon/redux-devtools/issues/250#issuecomment-186429931\">viitattava komponentin omiin propseihin</a>.</p>\n<h2>Presentational/Container revisited</h2>\n<p>Komponentti <em>NoteList</em> käyttää apumetodia <em>notesToShow</em>, joka päättelee filtterin perusteella näytettävien muistiinpanojen listan:</p>\n<pre><code class=\"language-js\">const notesToShow = () => {\n  const { notes, filter } = this.props;\n  if (filter === 'ALL') {\n    return notes;\n  }\n\n  return filter === 'IMPORTANT'\n    ? notes.filter(note => note.important)\n    : notes.filter(note => !note.important);\n};\n</code></pre>\n<p>Komponentin on tarpeetonta sisältää kaikkea tätä logiikkaa. Eriytetään se komponentin ulkopuolelle <em>connect</em>-metodin parametrin <em>mapStateToProps</em> yhteyteen. Muutetaan komponentti samalla funktionaaliseksi:</p>\n<pre><code class=\"language-react\">import React from 'react'\nimport { connect } from 'react-redux'\nimport { importanceToggling } from './../reducers/noteReducer'\nimport Note from './Note'\n\nconst NoteList = (props) => (\n  &#x3C;ul>\n    {props.visibleNotes.map(note =>\n      &#x3C;Note\n        key={note.id}\n        note={note}\n        handleClick={() => props.importanceToggling(note.id)}\n      />\n    )}\n  &#x3C;/ul>\n)\n\nconst notesToShow = (notes, filter) => {\n  if (filter === 'ALL') {\n    return notes\n  }\n  return filter === 'IMPORTANT'\n    ? notes.filter(note => note.important)\n    : notes.filter(note => !note.important)\n}\n\nconst mapStateToProps = (state) => {\n  return {\n    visibleNotes: notesToShow(state.notes, state.filter)\n  }\n}\n\nexport default connect(\n  mapStateToProps,\n  { importanceToggling }\n)(NoteList)\n</code></pre>\n<p><em>mapStateToProps</em> ei siis tällä kertaa mäppää propsiksi suoraan storessa olevaa asiaa, vaan storen tilasta funktion <em>notesToShow</em> avulla muodostetun sopivasti filtteröidyn datan.</p>\n<p>Uudistettu <em>NoteList</em> keskittyy lähes ainoastaan muistiinpanojen renderöimiseen, se on hyvin lähellä sitä minkä sanotaan olevan <a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\">presentational</a>-komponentti, joita Dan Abramovin <a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\">sanoin</a> kuvailee seuraavasti:</p>\n<ul>\n<li>Are concerned with how things look.</li>\n<li>May contain both presentational and container components inside, and usually have some DOM markup and styles of their own.</li>\n<li>Often allow containment via this.props.children.</li>\n<li>Have no dependencies on the rest of the app, such Redux actions or stores.</li>\n<li>Don’t specify how the data is loaded or mutated.</li>\n<li>Receive data and callbacks exclusively via props.</li>\n<li>Rarely have their own state (when they do, it’s UI state rather than data).</li>\n<li>Are written as functional components unless they need state, lifecycle hooks, or performance optimizations.</li>\n</ul>\n<p>Connect-metodin avulla muodostettu <em>yhdistetty komponentti</em></p>\n<pre><code class=\"language-js\">const notesToShow = (notes, filter) => {\n  if (filter === 'ALL') {\n    return notes;\n  }\n  return filter === 'IMPORTANT'\n    ? notes.filter(note => note.important)\n    : notes.filter(note => !note.important);\n};\n\nconst mapStateToProps = state => {\n  return {\n    visibleNotes: notesToShow(state.notes, state.filter),\n  };\n};\n\nconnect(\n  mapStateToProps,\n  { importanceToggling }\n)(NoteList);\n</code></pre>\n<p>taas on selkeästi <em>container</em>-komponentti, joita Dan Abramov <a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\">luonnehtii</a> seuraavasti:</p>\n<ul>\n<li>Are concerned with how things work.</li>\n<li>May contain both presentational and container components inside but usually don’t have any DOM markup of their own except for some wrapping divs, and never have any styles.</li>\n<li>Provide the data and behavior to presentational or other container components.</li>\n<li>Call Redux actions and provide these as callbacks to the presentational components.</li>\n<li>Are often stateful, as they tend to serve as data sources.</li>\n<li>Are usually generated using higher order components such as connect from React Redux, rather than written by hand.</li>\n</ul>\n<p>Komponenttien presentational vs. container -jaottelu on eräs hyväksi havaittu tapa strukturoida React-sovelluksia. Jako voi olla toimiva tai sitten ei, kaikki riippuu kontekstista.</p>\n<p>Abramov mainitsee jaon <a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\">eduiksi</a> muunmuassa seuraavat</p>\n<ul>\n<li>Better separation of concerns. You understand your app and your UI better by writing components this way.</li>\n<li>Better reusability. You can use the same presentational component with completely different state sources, and turn those into separate container components that can be further reused.</li>\n<li>Presentational components are essentially your app’s “palette”. You can put them on a single page and let the designer tweak all their variations without touching the app’s logic. You can run screenshot regression tests on that page.</li>\n</ul>\n<p>Abramov mainitsee termin <a href=\"https://reactjs.org/docs/higher-order-components.html\">high order component</a>. Esim. <em>NoteList</em> on normaali komponentti, React-reduxin <em>connect</em> metodi taas on <em>high order komponentti</em>, eli käytännössä funktio, joka haluaa parametrikseen komponentin muuttuakseen \"normaaliksi\" komponentiksi.</p>\n<p>High order componentit eli HOC:t ovatkin yleinen tapa määritellä geneeristä toiminnallisuutta, joka sitten erikoistetaan esim. renderöitymisen määrittelyn suhteen parametrina annettavan komponentin avulla. Kyseessä on funktionaalisen ohjelmoinnin etäisesti olio-ohjelmoinnin perintää muistuttava käsite.</p>\n<p>HOC:it ovat oikeastaan käsitteen <a href=\"https://en.wikipedia.org/wiki/Higher-order_function\">High Order Function</a> (HOF) yleistys. HOF:eja ovat sellaiset funkiot, jotka joko ottavat parametrikseen funktioita tai palauttavat funkioita. Olemme oikeastaan käyttäneet HOF:eja läpi kurssin, esim. lähes kaikki taulukoiden käsittelyyn tarkoitetut metodit, kuten <em>map, filter ja find</em> ovat HOF:eja, samoin jo monta kertaa käyttämämme funktioita palauttavat (eli kahden nuolen) funktiot, esim.</p>\n<pre><code class=\"language-js\">filterClicked = value => () => {\n  this.props.filterChange(value);\n};\n</code></pre>\n<p>Sovelluksen tämänhetkinen koodi on <a href=\"https://github.com/FullStack-HY/redux-notes/tree/part6-4\">githubissa</a> tagissa <em>part6-4</em>.</p>\n<p>Mukana on myös edellisestä unohtunut <em>VisibilityFilter</em>-komponentin <em>connect</em>-funktiota käyttävä versio, jota on myös paranneltu siten, että nappi <em>kaikki</em> on oletusarvoisesti valittuna. Koodissa on pieni ikävä copypaste mutta kelvatkoon.</p>\n<h2>Tehtäviä</h2>\n<p>Tee nyt tehtävät <a href=\"/teht%C3%A4v%C3%A4t#connect\">6.6-6.9</a></p>\n<h2>Redux-sovelluksen kommunikointi palvelimen kanssa</h2>\n<p>Laajennetaan sovellusta siten, että muistiinpanot talletetaan backendiin. Käytetään osasta 2 tuttua <a href=\"/osa2#datan-haku-palvelimelta\">json-serveriä</a>.</p>\n<p>Tallennetaan projektin juuren tiedostoon <em>db.json</em> tietokannan alkutila:</p>\n<pre><code class=\"language-json\">{\n  \"notes\": [\n    {\n      \"content\": \"reduxin storen toiminnan määrittelee reduceri\",\n      \"important\": true,\n      \"id\": 1\n    },\n    {\n      \"content\": \"storen tilassa voi olla mielivaltaista dataa\",\n      \"important\": false,\n      \"id\": 2\n    }\n  ]\n}\n</code></pre>\n<p>Asennetaan projektiin json-server</p>\n<pre><code class=\"language-bash\">npm install json-server --save\n</code></pre>\n<p>ja lisätään tiedoston <em>package.json</em> osaan <em>scripts</em> rivi</p>\n<pre><code class=\"language-bash\">\"scripts\": {\n  \"server\": \"json-server -p3001 db.json\",\n  // ...\n}\n</code></pre>\n<p>Käynnistetään json-server komennolla <em>npm run server</em>.</p>\n<p>Tehdään sitten tuttuun tapaan <em>axiosia</em> hyödyntävä backendistä dataa hakeva metodi tiedostoon <em>services/notes.js</em></p>\n<pre><code class=\"language-js\">import axios from 'axios';\n\nconst getAll = async () => {\n  const response = await axios.get('http://localhost:3001/notes');\n  return response.data;\n};\n\nexport default { getAll };\n</code></pre>\n<p>Asennetaan myös axios projektiin</p>\n<pre><code class=\"language-bash\">npm install axios --save\n</code></pre>\n<p>Muutetaan <em>nodeReducer</em>:issa tapahtuva muistiinpanojen tilan alustusta, siten että oletusarvoisesti mustiinpanoja ei ole:</p>\n<pre><code class=\"language-js\">const noteReducer = (state = [], action) => {\n  // ...\n};\n</code></pre>\n<p>Nopea tapa saada storen tila alustettua palvelimella olevan datan perusteella on hakea muistiinpanot tiedostossa <em>index.js</em> ja dispatchata niille yksitellen action <em>NEW</em>NOTE_:</p>\n<pre><code class=\"language-js\">// ...\nimport noteService from './services/notes';\n\nconst reducer = combineReducers({\n  notes: noteReducer,\n  filter: filterReducer,\n});\n\nconst store = createStore(reducer);\n\nnoteService.getAll().then(notes =>\n  notes.forEach(note => {\n    store.dispatch({ type: 'NEW_NOTE', data: note });\n  })\n);\n\n// ...\n</code></pre>\n<p>Lisätään reduceriin tuki actionille <em>INIT</em>NOTES<em>, jonka avulla alustus voidaan tehdä dispatchaamalla yksittäinen action. Luodaan myös sitä varten oma action creator -funktio _noteInitialization</em>:</p>\n<pre><code class=\"language-js\">// ...\nconst noteReducer = (state = [], action) => {\n  console.log('ACTION:', action);\n  switch (action.type) {\n    case 'NEW_NOTE':\n      return [...state, action.data];\n    case 'INIT_NOTES':\n      return action.data;\n    // ...\n  }\n};\n\nexport const noteInitialization = data => {\n  return {\n    type: 'INIT_NOTES',\n    data,\n  };\n};\n\n// ...\n</code></pre>\n<p><em>index.js</em> yksinkertaistuu:</p>\n<pre><code class=\"language-js\">import noteReducer, { noteInitialization } from './reducers/noteReducer';\n// ...\n\nnoteService.getAll().then(notes => store.dispatch(noteInitialization(notes)));\n</code></pre>\n<blockquote>\n<p><strong>HUOM:</strong> miksi emme käyttäneet koodissa promisejen ja <em>then</em>-metodilla rekisteröidyn tapahtumankäsittelijän sijaan awaitia?</p>\n<p>await toimii ainoastaan <em>async</em>-funktioiden sisällä, ja <em>index.js</em>:ssä oleva koodi ei ole funktiossa, joten päädyimme tilanteen yksinkertaisuuden takia tällä kertaa jättämään <em>async</em>:in käyttämättä.</p>\n</blockquote>\n<p>Päätetään kuitenkin siirtää muistiinpanojen alustus <em>App</em>-komponentin metodiin <em><a href=\"https://reactjs.org/docs/react-component.html#componentdidmount\">componentDidMount</a></em>, se on luonteva paikka alustuksille, sillä metodi suoritetaan heti sovelluksemme ensimmäisen renderöinnin jälkeen.</p>\n<p>Jotta saamme action creatorin <em>noteInitialization</em> käyttöön komponentissa <em>App</em> tarvitsemme jälleen <em>connect</em>-metodin apua:</p>\n<pre><code class=\"language-react\">import React from 'react'\nimport NoteForm from './components/NoteForm.js'\nimport NoteList from './components/NoteList.js'\nimport VisibilityFilter from './components/VisibilityFilter'\nimport { connect } from 'react-redux'\nimport { noteInitialization } from './reducers/noteReducer'\nimport noteService from './services/notes'\n\nclass App extends React.Component {\n  componentDidMount = async () => {\n    const notes = await noteService.getAll()\n    this.props.noteInitialization(notes)\n  }\n\n  render() {\n    return (\n      &#x3C;div>\n        &#x3C;NoteForm />\n        &#x3C;VisibilityFilter />\n        &#x3C;NoteList />\n      &#x3C;/div>\n    )\n  }\n}\n\nexport default connect(\n  null,\n  { noteInitialization }\n)(App)\n</code></pre>\n<p>Näin funktio <em>noteInitialization</em> tulee komponentin <em>App</em> propsiksi <em>this.props.noteInitialization</em> ja sen kutsumiseen ei tarvita <em>dispatch</em>-metodia koska <em>connect</em> hoitaa asian puolestamme.</p>\n<p>Pääsimme nyt myös käyttämään aina mukavaa async/awaitia. Palvelimen kanssa kommunikointi tapahtuu joka tapauksessa funktiossa, joten sen määrittely asyncina on vaivatonta:</p>\n<pre><code class=\"language-js\">componentDidMount = async () => {\n  const notes = await noteService.getAll();\n  this.props.noteInitialization(notes);\n};\n</code></pre>\n<p>Voimme toimia samoin myös uuden muistiinpanon luomisen suhteen. Laajennetaan palvelimen kanssa kommunikoivaa koodia:</p>\n<pre><code class=\"language-js\">const url = 'http://localhost:3001/notes';\n\nconst getAll = async () => {\n  const response = await axios.get(url);\n  return response.data;\n};\n\nconst createNew = async content => {\n  const response = await axios.post(url, { content, important: false });\n  return response.data;\n};\n\nexport default {\n  getAll,\n  createNew,\n};\n</code></pre>\n<p>Komponentin <em>NoteForm</em> metodi <em>addNote</em> muuttuu hiukan:</p>\n<pre><code class=\"language-react\">import React from 'react'\nimport { noteCreation } from './../reducers/noteReducer'\nimport { connect } from 'react-redux'\nimport noteService from '../services/notes'\n\nclass NoteForm extends React.Component {\n\n  addNote = async (event) => {\n    event.preventDefault()\n    const content = event.target.note.value\n    event.target.note.value = ''\n    const newNote = await noteService.createNew(content)\n    this.props.noteCreation(newNote)\n  }\n\n  render() {\n    //...\n  }\n}\n\nexport default connect(\n  null,\n  {noteCreation}\n)(NoteForm)\n</code></pre>\n<p>Koska backend generoi muistiinpanoille id:t, muutetaan action creator <em>noteCreation</em> muotoon</p>\n<pre><code class=\"language-js\">export const noteCreation = data => {\n  return {\n    type: 'NEW_NOTE',\n    data,\n  };\n};\n</code></pre>\n<p>Muistiinpanojen tärkeyden muuttaminen olisi mahdollista toteuttaa samalla periaatteella, eli tehdä palvelimelle ensin asynkroninen metodikutsu ja sen jälkeen dispatchata sopiva action.</p>\n<p>Sovelluksen tämänhetkinen koodi on <a href=\"https://github.com/FullStack-HY/redux-notes/tree/part6-5\">githubissa</a> tagissä <em>part6-5</em>.</p>\n<h2>Tehtäviä</h2>\n<p>Tee nyt tehtävät <a href=\"/teht%C3%A4v%C3%A4t#redux-ja-backend\">6.10-6.12</a></p>\n<h3>Asynkroniset actionit ja redux thunk</h3>\n<p>Lähestymistapamme on ok, mutta siinä mielessä ikävä, että palvelimen kanssa kommunikointi tapahtuu komponenttien metodeissa. Olisi parempi, jos kommunikointi voitaisiin abstrahoida komponenteilta siten, että niiden ei tarvitsisi kuin kutsua sopivaa <em>action creatoria</em>, esim. <em>App</em> alustaisi sovelluksen tilan seuraavasti:</p>\n<pre><code class=\"language-js\">class App extends React.Component {\n  componentDidMount() {\n    this.props.initializeNotes();\n  }\n  // ...\n}\n</code></pre>\n<p>ja <em>NoteForm</em> loisi uuden muistiinpanon seuraavasti:</p>\n<pre><code class=\"language-js\">class NoteForm extends React.Component {\n  addNote = async event => {\n    event.preventDefault();\n    const content = event.target.note.value;\n    event.target.note.value = '';\n    this.props.createNote(content);\n  };\n}\n</code></pre>\n<p>Molemmat komponentit käyttäisivät ainoastaan propsina saamaansa funktiota, välittämättä siitä että taustalla tapahtuu todellisuudessa palvelimen kanssa tapahtuvaa kommunikointia.</p>\n<p>Asennetaan nyt <a href=\"https://github.com/gaearon/redux-thunk\">redux-thunk</a>-kirjasto, joka mahdollistaa <em>asynkronisten actionien</em> luomisen. Asennus tapahtuu komennolla:</p>\n<pre><code class=\"language-bash\">npm install --save redux-thunk\n</code></pre>\n<p>redux-thunk-kirjasto on ns. <em>redux-middleware</em> joka täytyy ottaa käyttöön storen alustuksen yhteydessä. Eriytetään samalla storen määrittely omaan tiedostoon <em>store.js</em>:</p>\n<pre><code class=\"language-js\">import { createStore, combineReducers, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\n\nimport noteReducer from './reducers/noteReducer';\nimport filterReducer from './reducers/filterReducer';\n\nconst reducer = combineReducers({\n  notes: noteReducer,\n  filter: filterReducer,\n});\n\nconst store = createStore(reducer, applyMiddleware(thunk));\n\nexport default store;\n</code></pre>\n<p>Tiedosto <em>src/index.js</em> on muutoksen jälkeen seuraava</p>\n<pre><code class=\"language-react\">import React from 'react'\nimport ReactDOM from 'react-dom'\nimport { Provider } from 'react-redux'\nimport App from './App'\nimport store from './store'\n\nReactDOM.render(\n  &#x3C;Provider store={store}>\n    &#x3C;App />\n  &#x3C;/Provider>,\n  document.getElementById('root')\n)\n</code></pre>\n<p>redux-thunkin ansiosta on mahdollista määritellä <em>action creatoreja</em> siten, että ne palauttavat funktion, jonka parametrina on redux-storen <em>dispatch</em>-metodi. Tämän ansiosta on mahdollista tehdä asynkronisia action creatoreja, jotka ensin odottavat jonkin toimenpiteen valmistumista ja vasta sen jälkeen dispatchaavat varsinaisen actionin.</p>\n<p>Voimme nyt määritellä muistiinpanojen alkutilan palvelimelta hakevan action creatorin <em>initializeNotes</em> seuraavasti:</p>\n<pre><code class=\"language-js\">export const initializeNotes = () => {\n  return async dispatch => {\n    const notes = await noteService.getAll();\n    dispatch({\n      type: 'INIT_NOTES',\n      data: notes,\n    });\n  };\n};\n</code></pre>\n<p>Sisemmässä funktiossaan, eli <em>asynkronisessa actionissa</em> operaatio hakee ensin palvelimelta kaikki muistiinpanot ja sen jälkeen <em>dispatchaa</em> muistiinpanot storeen lisäävän actionin.</p>\n<p>Komponentti <em>App</em> voidaan nyt määritellä seuraavasti:</p>\n<pre><code class=\"language-react\">class App extends React.Component {\n  componentDidMount () {\n    this.props.initializeNotes()\n  }\n\n  render() {\n    return (\n      &#x3C;div>\n        &#x3C;NoteForm />\n        &#x3C;NoteList />\n        &#x3C;VisibilityFilter />\n      &#x3C;/div>\n    )\n  }\n}\n\nexport default connect(\n  null, { initializeNotes }\n)(App)\n</code></pre>\n<p>Ratkaisu on elegantti, muistiinpanojen alustuslogiikka on eriytetty kokonaan React-komponenttien ulkopuolelle.</p>\n<p>Uuden muistiinpanon lisäävä action creator <em>createNew</em> on seuraavassa</p>\n<pre><code class=\"language-js\">export const createNew = content => {\n  return async dispatch => {\n    const newNote = await noteService.createNew(content);\n    dispatch({\n      type: 'NEW_NOTE',\n      data: newNote,\n    });\n  };\n};\n</code></pre>\n<p>Periaate on jälleen sama, ensin suoritetaan asynkroninen operaatio, ja sen valmistuttua <em>dispatchataan</em> storen tilaa muuttava action.</p>\n<p>Lomake muuttuu seuraavasti:</p>\n<pre><code class=\"language-react\">class NoteForm extends React.Component {\n\n  addNote = async (event) => {\n    event.preventDefault()\n    const content = event.target.note.value\n    event.target.note.value = ''\n    this.props.createNew(content)\n  }\n\n  render() {\n    return (\n      &#x3C;form onSubmit={this.addNote}>\n        &#x3C;input name='note' />\n        &#x3C;button>lisää&#x3C;/button>\n      &#x3C;/form>\n    )\n  }\n}\n\nexport default connect(\n  null, { createNew }\n)(NoteForm)\n</code></pre>\n<p>Sovelluksen tämänhetkinen koodi on <a href=\"https://github.com/FullStack-HY/redux-notes/tree/part6-6\">githubissa</a> tagissä <em>part6-6</em>.</p>\n<h3>Redux DevTools</h3>\n<p>Chromeen on asennettavissa <a href=\"https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd\">Redux DevTools</a>, jonka avulla Redux-storen tilaa ja sitä muuttavia actioneja on mahdollisuus seurata selaimen konsolista.</p>\n<p>Selaimen lisäosan lisäksi debugatessa tarvitaan kirjastoa <a href=\"https://www.npmjs.com/package/redux-devtools-extension\">redux-devtools-extension</a>. Asennetaan se komennolla</p>\n<pre><code class=\"language-js\">npm install --save redux-devtools-extension\n</code></pre>\n<p>Storen luomistapaa täytyy hieman muuttaa, että kirjasto saadaan käyttöön:</p>\n<pre><code class=\"language-react\">// ...\nimport { createStore, combineReducers, applyMiddleware } from 'redux'\nimport thunk from 'redux-thunk'\nimport { composeWithDevTools } from 'redux-devtools-extension'\n\nimport noteReducer from './reducers/noteReducer'\nimport filterReducer from './reducers/filterReducer'\n\nconst reducer = combineReducers({\n  notes: noteReducer,\n  filter: filterReducer\n})\n\nconst store = createStore(\n  reducer,\n  composeWithDevTools(\n    applyMiddleware(thunk)\n  )\n)\n\nexport default store\n</code></pre>\n<p>Kun nyt avaat konsolin, välilehti <em>redux</em> näyttää seuraavalta:</p>\n<picture><img src=\"/static/4df255f283ff5181ab9a3039b5ca7cf6/14be6/5e.png\" srcset=\"/static/4df255f283ff5181ab9a3039b5ca7cf6/4cce7/5e.png 200w,\n/static/4df255f283ff5181ab9a3039b5ca7cf6/bae5f/5e.png 400w,\n/static/4df255f283ff5181ab9a3039b5ca7cf6/14be6/5e.png 800w,\n/static/4df255f283ff5181ab9a3039b5ca7cf6/1b35a/5e.png 1200w,\n/static/4df255f283ff5181ab9a3039b5ca7cf6/9ee03/5e.png 1600w,\n/static/4df255f283ff5181ab9a3039b5ca7cf6/b4549/5e.png 1896w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Konsolin avulla on myös mahdollista dispatchata actioneja storeen</p>\n<picture><img src=\"/static/7ee4e1c35e7391f5f880c7f88307d935/14be6/5f.png\" srcset=\"/static/7ee4e1c35e7391f5f880c7f88307d935/4cce7/5f.png 200w,\n/static/7ee4e1c35e7391f5f880c7f88307d935/bae5f/5f.png 400w,\n/static/7ee4e1c35e7391f5f880c7f88307d935/14be6/5f.png 800w,\n/static/7ee4e1c35e7391f5f880c7f88307d935/1b35a/5f.png 1200w,\n/static/7ee4e1c35e7391f5f880c7f88307d935/9ee03/5f.png 1600w,\n/static/7ee4e1c35e7391f5f880c7f88307d935/e829b/5f.png 1730w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Storen tietyn hetkisen tilan lisäksi on myös mahdollista tarkastella, mikä on kunkin actionin tilalle aiheuttama muutos:</p>\n<picture><img src=\"/static/408ae9b7ac135ad5e5259b2bbd7c94a6/14be6/5g.png\" srcset=\"/static/408ae9b7ac135ad5e5259b2bbd7c94a6/4cce7/5g.png 200w,\n/static/408ae9b7ac135ad5e5259b2bbd7c94a6/bae5f/5g.png 400w,\n/static/408ae9b7ac135ad5e5259b2bbd7c94a6/14be6/5g.png 800w,\n/static/408ae9b7ac135ad5e5259b2bbd7c94a6/1b35a/5g.png 1200w,\n/static/408ae9b7ac135ad5e5259b2bbd7c94a6/9ee03/5g.png 1600w,\n/static/408ae9b7ac135ad5e5259b2bbd7c94a6/e6773/5g.png 1850w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<h2>tehtäviä</h2>\n<p>Tee nyt tehtävät <a href=\"/teht%C3%A4v%C3%A4t#thunk\">6.13-6.15</a></p>\n<h2>React router</h2>\n<p>Palataan jälleen Reduxittoman Reactin pariin.</p>\n<p>On erittäin tyypillistä, että web-sovelluksissa on navigaatiopalkki, jonka avulla on mahdollista vaihtaa sovelluksen näkymää. Muistiinpanosovelluksemme voisi sisältää pääsivun:</p>\n<picture><img src=\"/static/9dede0061c8eac733e37e2e60d2717b6/14be6/6.png\" srcset=\"/static/9dede0061c8eac733e37e2e60d2717b6/4cce7/6.png 200w,\n/static/9dede0061c8eac733e37e2e60d2717b6/bae5f/6.png 400w,\n/static/9dede0061c8eac733e37e2e60d2717b6/14be6/6.png 800w,\n/static/9dede0061c8eac733e37e2e60d2717b6/1b35a/6.png 1200w,\n/static/9dede0061c8eac733e37e2e60d2717b6/7db0f/6.png 1240w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>ja omat sivunsa muistiinpanojen ja käyttäjien tietojen näyttämiseen:</p>\n<picture><img src=\"/static/5b335e01f8915d3c3cab42be7f78460c/14be6/7.png\" srcset=\"/static/5b335e01f8915d3c3cab42be7f78460c/4cce7/7.png 200w,\n/static/5b335e01f8915d3c3cab42be7f78460c/bae5f/7.png 400w,\n/static/5b335e01f8915d3c3cab42be7f78460c/14be6/7.png 800w,\n/static/5b335e01f8915d3c3cab42be7f78460c/1b35a/7.png 1200w,\n/static/5b335e01f8915d3c3cab42be7f78460c/7db0f/7.png 1240w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p><a href=\"/osa0#perinteinen-web-sovellus\">Vanhan koulukunnan websovelluksessa</a> sovelluksen näyttämän sivun vaihto tapahtui siten että selain teki palvelimelle uuden HTTP GET -pyynnön ja renderöi sitten palvelimen palauttaman näkymää vastaavan HTML-koodin.</p>\n<p>Single page appeissa taas ollaan todellisuudessa koko ajan samalla sivulla, ja selaimessa suoritettava Javascript-koodi luo illuusion eri \"sivuista\". Jos näkymää vaihdettaessa tehdään HTTP-kutsuja, niiden avulla haetaan ainoastaan JSON-muotoista dataa jota uuden näkymän näyttäminen ehkä edellyttää.</p>\n<p>Navigaatiopalkki ja useita näkymiä sisältävä sovellus on erittäin helppo toteuttaa Reactilla.</p>\n<p>Seuraavassa on eräs tapa:</p>\n<pre><code class=\"language-react\">const Home = () => (\n  &#x3C;div> &#x3C;h2>TKTL notes app&#x3C;/h2> &#x3C;/div>\n)\n\nconst Notes = () => (\n  &#x3C;div> &#x3C;h2>Notes&#x3C;/h2> &#x3C;/div>\n)\n\nconst Users = () => (\n  &#x3C;div> &#x3C;h2>Users&#x3C;/h2> &#x3C;/div>\n)\n\nclass App extends React.Component {\n  constructor() {\n    super()\n    this.state = {\n      page: 'home'\n    }\n  }\n\n  toPage = (page) => (event) => {\n    event.preventDefault()\n    this.setState({ page })\n  }\n\n  render() {\n    const content = () => {\n      if (this.state.page === 'home') {\n        return &#x3C;Home />\n      } else if (this.state.page === 'notes') {\n        return &#x3C;Notes />\n      } else if (this.state.page === 'users') {\n        return &#x3C;Users />\n      }\n    }\n\n    return (\n      &#x3C;div>\n        &#x3C;div>\n          &#x3C;a href=\"\" onClick={ this.toPage('home') }>home&#x3C;/a> &#x26;nbsp;\n          &#x3C;a href=\"\" onClick={ this.toPage('notes') }>notes&#x3C;/a> &#x26;nbsp;\n          &#x3C;a href=\"\" onClick={ this.toPage('users') }>users&#x3C;/a>\n        &#x3C;/div>\n\n        {content()}\n      &#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<p>Eli jokainen näkymä on toteutettu omana komponenttinaan ja sovelluksen tilassa pidetään tieto siitä, minkä näkymää vastaava komponentti menupalkin alla näytetään.</p>\n<p><strong>Huom:</strong> navigointivalikossa oleva <em>&#x26;nbsp;</em> tarkoittaa <em>a</em>-tagien väliin sjijoitettavaa välilyöntiä. CSS:n käyttö olisi luonnollisesti parempi tapa sivun ulkoasun muotoilulle mutta nyt tyydymme quick'n'dirty-ratkaisuun.</p>\n<p>Menetelmä ei kuitenkaan ole optimaalinen. Kuten kuvista näkyy, sivuston osoite pysyy samana vaikka välillä ollaankin eri näkymässä. Jokaisella näkymällä tulisi kuitenkin olla oma osoitteensa, jotta esim. bookmarkien tekeminen olisi mahdollista. Sovelluksessamme ei myöskään selaimen <em>back</em>-painike toimi loogisesti, eli <em>back</em> ei vie edelliseksi katsottuun sovelluksen näkymään vaan jonnekin ihan muualle. Jos sovellus kasvaisi suuremmaksi ja sinne haluttaisiin esim. jokaiselle käyttäjälle sekä muistiinpanolle oma yksittäinen näkymänsä, itse koodattu <em>reititys</em> eli sivuston navigaationhallinta menisi turhan monimutkaiseksi.</p>\n<p>Reactissa on onneksi valmis komponentti <a href=\"https://github.com/ReactTraining/react-router\">React router</a> joka tarjoaa erinomaisen ratkaisun React-sovelluksen navigaation hallintaan.</p>\n<p>Muutetaan ylläoleva sovellus käyttämään React routeria. Asennetaan React router komennolla</p>\n<pre><code class=\"language-bash\">npm install --save react-router-dom\n</code></pre>\n<p>React routerin tarjoama reititys saadaan käyttöön muuttamalla sovellusta seuraavasti:</p>\n<pre><code class=\"language-react\">import { BrowserRouter as Router, Route, Link } from 'react-router-dom'\n\nclass App extends React.Component {\n\n  render() {\n    return (\n      &#x3C;div>\n        &#x3C;Router>\n          &#x3C;div>\n            &#x3C;div>\n              &#x3C;Link to=\"/\">home&#x3C;/Link> &#x26;nbsp;\n              &#x3C;Link to=\"/notes\">notes&#x3C;/Link> &#x26;nbsp;\n              &#x3C;Link to=\"/users\">users&#x3C;/Link>\n            &#x3C;/div>\n            &#x3C;Route exact path=\"/\" render={() => &#x3C;Home />} />\n            &#x3C;Route path=\"/notes\" render={() => &#x3C;Notes />} />\n            &#x3C;Route path=\"/users\" render={() => &#x3C;Users />} />\n          &#x3C;/div>\n        &#x3C;/Router>\n      &#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<p>Reititys, eli komponenttien ehdollinen, selaimen <em>urliin perustuva</em> renderöinti otetaan käyttöön sijoittamalla komponentteja <em>Router</em>-komponentin lapsiksi, eli <em>Router</em>-tagien sisälle.</p>\n<p>Huomaa, että vaikka komponenttiin viitataan nimellä <em>Router</em> kyseessä on <a href=\"https://reacttraining.com/react-router/web/api/BrowserRouter\">BrowserRouter</a>, sillä\nimporttaus tapahtuu siten, että importattava olio uudelleennimetään:</p>\n<pre><code class=\"language-js\">import { BrowserRouter as Router ... } from 'react-router-dom'\n</code></pre>\n<p>Manuaalin mukaan</p>\n<blockquote>\n<p><em>BrowserRouter</em> is a <em>Router</em> that uses the HTML5 history API (pushState, replaceState and the popstate event) to keep your UI in sync with the URL.</p>\n</blockquote>\n<p>Normaalisti selain lataa uuden sivun osoiterivillä olevan urlin muuttuessa. <a href=\"https://css-tricks.com/using-the-html5-history-api/\">HTML5 history API</a>:n avulla <em>BrowserRouter</em> kuitenkin mahdollistaa sen, että selaimen osoiterivillä olevaa urlia voidaan käyttää React-sovelluksen sisäiseen \"reitittämiseen\", eli vaikka osoiterivillä oleva url muuttuu, sivun sisältöä manipuloidaan ainoastaan Javascriptillä ja selain ei lataa uutta sisältöä palvelimelta. Selaimen toiminta back- ja forward-toimintojen ja bookmarkien tekemisen suhteen on kuitenkin loogista, eli toimii kuten perinteisillä web-sivuilla.</p>\n<p>Routerin sisälle määritellään selaimen osoiteriviä muokkaavia <em>linkkejä</em> komponentin <a href=\"https://reacttraining.com/react-router/web/api/Link\">Link</a> avulla. Esim.</p>\n<pre><code class=\"language-bash\">&#x3C;Link to=\"/notes\">notes&#x3C;/Link>\n</code></pre>\n<p>luo sovellukseen linkin, jonka teksti on <em>notes</em> ja jonka klikkaaminen vaihtaa selaimen osoiteriville urliksi <em>/notes</em>.</p>\n<p>Selaimen urliin perustuen renderöitävät komponentit määritellään komponentin <a href=\"https://reacttraining.com/react-router/web/api/Route\">Route</a> avulla. Esim.</p>\n<pre><code class=\"language-bash\">&#x3C;Route path=\"/notes\" render={() => &#x3C;Notes />} />\n</code></pre>\n<p>määrittelee, että jos selaimen osoiteena on <em>/notes</em>, renderöidään komponentti <em>Notes</em>.</p>\n<p>Sovelluksen juuren, eli osoitteen <em>/</em> määritellään renderöivän komponentti <em>Home</em>:</p>\n<pre><code class=\"language-bash\">&#x3C;Route exact path=\"/\" render={() => &#x3C;Home />} />\n</code></pre>\n<p>joudumme käyttämään routen <em>path</em> attribuutin edessä määrettä <em>exact</em>, muuten <em>Home</em> renderöityy kaikilla muillakin poluilla, sillä juuri <em>/</em> on kaikkien muiden polkujen <em>alkuosa</em>.</p>\n<h3>parametroitu route</h3>\n<p>Tarkastellaan sitten hieman modifioitua versiota edellisestä esimerkistä. Esimerkin koodi kokonaisuudessaan on <a href=\"https://github.com/FullStack-HY/FullStack-Hy.github.io/wiki/router-esimerkki\">täällä</a>.</p>\n<p>Sovellus sisältää nyt viisi eri näkymää, joiden näkyvyyttä kontrolloidaan routerin avulla. Edellisestä esimerkistä tuttujen komponenttien <em>Home</em>, <em>Notes</em> ja <em>Users</em> lisäksi mukana on kirjautumisnäkymää vastaava <em>Login</em> ja yksittäisen muistiinpanon näkymää vastaava <em>Note</em>.</p>\n<p><em>Home</em> ja <em>Users</em> ovat kuten aiemmassa esimerkissä. <em>Notes</em> on hieman monimutkaisempi, se renderöi propseina saamansa muistiinpanojen listan siten, että jokaisen muistiinpanon nimi on klikattavissa</p>\n<picture><img src=\"/static/c734eb7d3963d927a2849f6d2967e9e1/14be6/8.png\" srcset=\"/static/c734eb7d3963d927a2849f6d2967e9e1/4cce7/8.png 200w,\n/static/c734eb7d3963d927a2849f6d2967e9e1/bae5f/8.png 400w,\n/static/c734eb7d3963d927a2849f6d2967e9e1/14be6/8.png 800w,\n/static/c734eb7d3963d927a2849f6d2967e9e1/1b35a/8.png 1200w,\n/static/c734eb7d3963d927a2849f6d2967e9e1/b03d6/8.png 1330w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Nimen klikattavuus on toteutettu komponentilla <em>Link</em> ja esim. muistiinpanon, jonka id on 3 nimen klikkaaminen aiheuttaa selaimen osoitteen arvon päivittymisen muotoon <em>notes/3</em>:</p>\n<pre><code class=\"language-react\">const Notes = ({notes}) => (\n  &#x3C;div>\n    &#x3C;h2>Notes&#x3C;/h2>\n    &#x3C;ul>\n      {notes.map(note=>\n        &#x3C;li key={note.id}>\n          &#x3C;Link to={`/notes/${note.id}`}>{note.content}&#x3C;/Link>\n        &#x3C;/li>\n      )}\n    &#x3C;/ul>\n  &#x3C;/div>\n)\n</code></pre>\n<p>Kun selain siirtyy muistiinpanon yksilöivään osoitteeseen, esim. <em>notes/3</em>, renderöidään komponentti <em>Note</em>:</p>\n<pre><code class=\"language-react\">const Note = ({note}) => {\n  return(\n  &#x3C;div>\n    &#x3C;h2>{note.content}&#x3C;/h2>\n    &#x3C;div>{note.user}&#x3C;/div>\n    &#x3C;div>&#x3C;strong>{note.important ? 'tärkeä' : ''}&#x3C;/strong>&#x3C;/div>\n  &#x3C;/div>\n)}\n</code></pre>\n<p>Tämä tapahtuu laajentamalla komponentissa <em>App</em> olevaa reititystä seuraavasti:</p>\n<pre><code class=\"language-bash\">&#x3C;div>\n  &#x3C;Router>\n    &#x3C;div>\n      &#x3C;div>\n        &#x3C;Link to=\"/\">home&#x3C;/Link> &#x26;nbsp;\n        &#x3C;Link to=\"/notes\">notes&#x3C;/Link> &#x26;nbsp;\n        &#x3C;Link to=\"/users\">users&#x3C;/Link> &#x26;nbsp;\n      &#x3C;/div>\n\n      &#x3C;Route exact path=\"/\" render={() => &#x3C;Home />} />\n      &#x3C;Route exact path=\"/notes\" render={() =>\n        &#x3C;Notes notes={this.state.notes} />}\n      />\n      &#x3C;Route exact path=\"/notes/:id\" render={({match}) =>\n        &#x3C;Note note={noteById(match.params.id)} />}\n      />\n    &#x3C;/div>\n  &#x3C;/Router>\n&#x3C;/div>\n</code></pre>\n<p>Kaikki muistiinpanon renderöivään routeen on lisätty määre <em>exact path=\"/notes\"</em> sillä muuten se renderöityisi myös <em>/notes/3</em>-muotoisten polkujen yhteydessä.</p>\n<p>Yksittäisen muistiinpanon näkymän renderöivä route määritellään \"expressin tyyliin\" merkkaamalla reitin parametrina oleva osa merkinnällä <em>:id</em></p>\n<pre><code class=\"language-react\">&#x3C;Route exact path=\"/notes/:id\" />\n</code></pre>\n<p>Renderöityvän komponentin määrittävä <em>render</em>-attribuutti pääsee käsiksi id:hen parametrinsa <a href=\"https://reacttraining.com/react-router/web/api/match\">match</a> avulla seuraavasti:</p>\n<pre><code class=\"language-react\">render={({match}) => &#x3C;Note note={noteById(match.params.id)} />}\n</code></pre>\n<p>Muuttujassa <em>match.params.id</em> olevaa id:tä vastaava muistiinpano selvitetään apufunktion <em>noteById</em> avulla</p>\n<pre><code class=\"language-react\">const noteById = (id) =>\n  this.state.notes.find(note => note.id === Number(id))\n</code></pre>\n<p>renderöityvä <em>Note</em>-komponentti saa siis propsina urlin yksilöivää osaa vastaavan muistiinpanon.</p>\n<h3>history</h3>\n<p>Sovellukseen on myös toteutettu erittäin yksinkertainen kirjautumistoiminto. Jos sovellukseen ollaan kirjautuneena, talletetaan tieto kirjautuneesta käyttäjästä komponentin <em>App</em> tilaan <em>this.state.user</em>.</p>\n<p>Mahdollisuus <em>Login</em>-näkymään navigointiin renderöidään menuun ehdollisesti</p>\n<pre><code class=\"language-bash\">&#x3C;Router>\n  &#x3C;div>\n    &#x3C;div>\n      &#x3C;Link to=\"/\">home&#x3C;/Link> &#x26;nbsp;\n      &#x3C;Link to=\"/notes\">notes&#x3C;/Link> &#x26;nbsp;\n      &#x3C;Link to=\"/users\">users&#x3C;/Link> &#x26;nbsp;\n      {this.state.user\n        ? &#x3C;em>{this.state.user} logged in&#x3C;/em>\n        : &#x3C;Link to=\"/login\">login&#x3C;/Link>\n      }\n    &#x3C;/div>\n  ...\n  &#x3C;/div>\n&#x3C;/Router>\n</code></pre>\n<p>eli jos käyttäjä on kirjaantunut, renderöidäänkin linkin <em>Login</em> sijaan kirjautuneen käyttäjän käyttäjätunnus:</p>\n<picture><img src=\"/static/9d8e5389508c4a3415ca5140d00ad25b/14be6/9.png\" srcset=\"/static/9d8e5389508c4a3415ca5140d00ad25b/4cce7/9.png 200w,\n/static/9d8e5389508c4a3415ca5140d00ad25b/bae5f/9.png 400w,\n/static/9d8e5389508c4a3415ca5140d00ad25b/14be6/9.png 800w,\n/static/9d8e5389508c4a3415ca5140d00ad25b/1b35a/9.png 1200w,\n/static/9d8e5389508c4a3415ca5140d00ad25b/b7120/9.png 1566w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Kirjautumisen toteuttamiseen liittyy eräs mielenkiintoinen seikka. Kirjaantumislomakkeelle mennään selaimen osoitteen ollessa <em>/login</em>. Toiminnallisuuden määrittelevä Route on seuraavassa</p>\n<pre><code class=\"language-bash\">&#x3C;Route path=\"/login\" render={({history}) =>\n  &#x3C;Login history={history} onLogin={this.login} />}\n/>\n</code></pre>\n<p>Routen render-attribuutissa määritelty metodi ottaa nyt vastaan olion <a href=\"https://reacttraining.com/react-router/web/api/history\">history</a>, joka tarjoaa mm. mahdollisuuden manipuloida selaimen osoiterivin arvoa ohjelmallisesti.</p>\n<p>Renderöitävälle <em>Login</em>-näkymälle annetaan parametriksi <em>history</em>-olio ja kirjautumisen komponentin <em>App</em> tilaan synkronoiva funktio <em>this.login</em>:</p>\n<pre><code class=\"language-bash\">&#x3C;Login history={history} onLogin={this.login}/>}\n</code></pre>\n<p>Komponentin koodi seuraavassa</p>\n<pre><code class=\"language-react\">const Login = ({onLogin, history}) => {\n  const onSubmit = (event) => {\n    event.preventDefault()\n    onLogin(event.target.username.value)\n    history.push('/')\n  }\n  return (\n    &#x3C;div>\n      &#x3C;h2>login&#x3C;/h2>\n      &#x3C;form onSubmit={onSubmit}>\n        &#x3C;div>\n          username: &#x3C;input />\n        &#x3C;/div>\n        &#x3C;div>\n          password: &#x3C;input type=\"password\" />\n        &#x3C;/div>\n        &#x3C;button type=\"submit\">login&#x3C;/button>\n      &#x3C;/form>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Kirjautumisen yhteydessä funktiossa <em>onSubmit</em> kutsutaan <a href=\"https://reacttraining.com/react-router/web/api/history\">history</a>-olion metodia <em>push</em>. Käytetty komento <code>history.push('/')</code> saa aikaan sen, että selaimen osoiteriville tulee osoitteeksi <em>/</em> ja sovellus renderöi osoitetta vastaavan komponentin <em>Home</em>.</p>\n<h3>redirect</h3>\n<p>Näkymän <em>Users</em> routeen liittyy vielä eräs mielenkiintoinen detalji:</p>\n<pre><code class=\"language-bash\">&#x3C;Route path=\"/users\" render={() =>\n  this.state.user\n    ? &#x3C;Users />\n    : &#x3C;Redirect to=\"/login\" />\n  }/>\n</code></pre>\n<p>Jos käyttäjä ei ole kirjautuneena, ei renderöidäkään näkymää <em>Users</em> vaan sen sijaan <em>uudelleenohjataan</em> käyttäjä <em>Redirect</em>-komponentin avulla kirjautumisnäkymään</p>\n<pre><code class=\"language-react\">&#x3C;Redirect to=\"/login\" />\n</code></pre>\n<p>Todellisessa sovelluksessa olisi kenties parempi olla kokonaan näyttämättä navigaatiovalikossa kirjautumista edellyttäviä näkymiä jos käyttäjä ei ole kirjautunut sovellukseen.</p>\n<p>Seuraavassa vielä komponentin <em>App</em> koodi kokonaisuudessaan:</p>\n<pre><code class=\"language-react\">class App extends React.Component {\n  constructor() {\n    super()\n    this.state = {\n      notes: [\n        {\n          id: 1,\n          content: 'HTML on helppoa',\n          important: true,\n          user: 'Matti Luukkainen'\n        },\n        // ...\n      ],\n      user: null\n    }\n  }\n\n  login = (user) => {\n    this.setState({user})\n  }\n\n  render() {\n    const noteById = (id) =>\n      this.state.notes.find(note => note.id === Number(id))\n\n    return (\n      &#x3C;div>\n        &#x3C;Router>\n          &#x3C;div>\n            &#x3C;div>\n              &#x3C;Link to=\"/\">home&#x3C;/Link> &#x26;nbsp;\n              &#x3C;Link to=\"/notes\">notes&#x3C;/Link> &#x26;nbsp;\n              &#x3C;Link to=\"/users\">users&#x3C;/Link> &#x26;nbsp;\n              {this.state.user\n                ? &#x3C;em>{this.state.user} logged in&#x3C;/em>\n                : &#x3C;Link to=\"/login\">login&#x3C;/Link>\n              }\n            &#x3C;/div>\n\n            &#x3C;Route exact path=\"/\" render={() => &#x3C;Home />} />\n            &#x3C;Route exact path=\"/notes\" render={() => &#x3C;Notes notes={this.state.notes}/>} />\n            &#x3C;Route exact path=\"/notes/:id\" render={({match}) =>\n              &#x3C;Note note={noteById(match.params.id)} />}\n            />\n            &#x3C;Route path=\"/users\" render={() =>\n              this.state.user\n                ? &#x3C;Users />\n                : &#x3C;Redirect to=\"/login\" />\n              }/>\n            &#x3C;Route path=\"/login\" render={({history}) =>\n              &#x3C;Login history={history} onLogin={this.login} />}\n            />\n          &#x3C;/div>\n        &#x3C;/Router>\n        &#x3C;div>\n          &#x3C;em>Note app, Department of Computer Science 2018&#x3C;/em>\n        &#x3C;/div>\n      &#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<p>Render-metodissa määritellään myös kokonaan <em>Router</em>:in ulkopuolella oleva nykyisille web-sovelluksille tyypillinen <em>footer</em>-elementti, eli sivuston pohjalla oleva osa, joka on näkyvillä riippumatta siitä mikä komponentti sovelluksen reititetyssä osassa näytetään.</p>\n<p><strong>Huom:</strong> edellä olevassa esimerkissä käytetään React Routerin versiota 4.2.6. Jos ja kun etsit esimerkkejä internetistä, kannattaa varmistaa, että niissä käytetään Routerista vähintään versiota 4.0. Nelosversio ei ole ollenkaan alaspäinyhteensopiva kolmosen kanssa, eli vanhaa React Routeria käyttävä koodi on täysin käyttökelvotonta Routerin versiota 4 käytettäessä.</p>\n<h2>tehtäviä</h2>\n<p>Tee nyt tehtävät <a href=\"/teht%C3%A4v%C3%A4t#router\">6.16-6.18</a></p>\n<h2>Inline-tyylit</h2>\n<p>Osan 2 <a href=\"/osa2#tyylien-lis%C3%A4%C3%A4minen\">lopussa</a> lisäsimme React-sovellukseen tyylejä vanhan koulukunnan tapaan yhden koko sovelluksen tyylit määrittelevän CSS-tiedoston avulla.</p>\n<p>Olemme jo muutamaan kertaan määritelleet komponenteille <a href=\"https://react-cn.github.io/react/tips/inline-styles.html\">inline</a>-tyylejä, eli määritelleet CSS:ää suoraan komponentin muun koodin seassa.</p>\n<p>Edellisessä osassa piilotimme inline-tyylin avulla napin ruudusta tietyissä tapauksissa:</p>\n<pre><code class=\"language-react\">const hideWhenVisible = { display: this.state.visible ? 'none' : '' }\n\n&#x3C;div style={hideWhenVisible}>\n  &#x3C;button onClick={this.toggleVisibility}>{this.props.buttonLabel}&#x3C;/button>\n&#x3C;/div>\n</code></pre>\n<p>eli jos <em>this.state.visible</em> oli arvoltaan tosi, liitetään <em>div</em>-komponenttiin sen näkymättömäksi asettava tyyli</p>\n<pre><code class=\"language-CSS\">{ display: 'none' }\n</code></pre>\n<p>Periaate inline-tyylien määrittelyssä on siis erittäin yksinkertainen. Mihin tahansa React-komponenttiin tai elementtiin voi liittää attribuutin <em>style</em>, jolle annetaan arvoksi Javascript-oliona määritelty joukko <em>CSS</em>-sääntöjä.</p>\n<p>CSS-säännöt määritellään hieman eri tavalla kuin normaaleissa CSS-tiedostoissa. Jos haluamme asettaa jollekin elementille vihreän, kursivoidun ja 16 pikselin korkuisen fontin, eli CSS-syntaksilla ilmaistuna</p>\n<pre><code class=\"language-CSS\">{\n  color: green;\n  font-style: italic;\n  font-size: 16px;\n}\n</code></pre>\n<p>tulee tämä muotilla Reactin inline-tyylin määrittelevänä oliona seuraavasti</p>\n<pre><code class=\"language-js\">const footerStyle = {\n  color: 'green',\n  fontStyle: 'italic',\n  fontSize: 16,\n};\n</code></pre>\n<p>Jokainen CSS-sääntö on olion kenttä, joten ne erotetaan Javascript-syntaksin mukaan pilkuilla. Pikseleinä ilmaistut numeroarvot voidaan määritellä kokonaislukuina. Merkittävin ero normaaliin CSS:ään on väliviivan sisältämien CSS-ominaisuuksien kirjoittaminen <em>camelCase</em>-muodossa.</p>\n<p>Voimme muotoilla edellisen luvun footer-elementin olion <em>footerStyle</em> avulla seuraavasti:</p>\n<pre><code class=\"language-bash\">&#x3C;div style={footerStyle}>\n  &#x3C;br />\n  &#x3C;em>Note app, Department of Computer Science 2018&#x3C;/em>\n&#x3C;/div>\n</code></pre>\n<p>Inline-tyyleillä on tiettyjä rajoituksia, esim. ns. <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes\">pseudo-selektoreja</a> ei ole mahdollisuutta käyttää (ainakaan helposti).</p>\n<p>Inline-tyylit ja muutamat seuraavassa osassa katsomamme tavat lisätä tyylejä Reactiin ovat periaatteessa täysin vastoin vanhoja hyviä periaatteita, joiden mukaan Web-sovellusten ulkoasujen määrittely eli CSS tulee erottaa sisällön (HTML) ja toiminnallisuuden (Javascript) määrittelystä. Vanha koulukunta pyrkiikin siihen että sovelluksen CSS, HTML ja Javascript on kaikki kirjoitettu omiin tiedostoihinsa.</p>\n<p>Itseasiassa Reactin filosofia on täysin päinvastainen. Koska CSS:n, HTML:n ja Javascriptin erottelu eri tiedostoihin ei ole kuitenkaan osoittautunut erityisen skaalautuvaksi ratkaisuksi suurissa järjestelmissä, on Reactissa periaatteena tehdä erottelu (eli jakaa sovelluksen koodi eri tiedostoihin) noudattaen <em>sovelluksen loogisia toiminnallisia kokonaisuuksia</em>.</p>\n<p>Toiminnallisen kokonaisuuden strukturointiyksikkö on React-komponentti, joka määrittelee niin sisällön rakenteen kuvaavan HTML:n, toiminnan määrittelevät Javascript-funktiot kuin komponentin tyylinkin yhdessä paikassa, siten että komponenteista tulee mahdollisimman riippumattomia ja yleiskäyttöisiä.</p>\n<h2>tehtäviä</h2>\n<p>Tee nyt tehtävät <a href=\"/teht%C3%A4v%C3%A4t#inline-tyylit\">6.19 ja 6.20</a></p>\n<h2>Valmiit käyttöliittymätyylikirjastot</h2>\n<p>Eräs lähestymistapa sovelluksen tyylien määrittelyyn on valmiin \"UI frameworkin\", eli suomeksi ehkä käyttöliittymätyylikirjaston käyttö.</p>\n<p>Ensimmäinen laajaa kuuluisuutta saanut UI framework oli Twitterin kehittämä <a href=\"https://getbootstrap.com/\">Bootstrap</a>, joka lienee edelleen UI frameworkeista eniten käytetty. Viime aikoina UI frameworkeja on noussut kuin sieniä sateella. Valikoima on niin iso, ettei tässä kannata edes yrittää tehdä tyhjentävää listaa.</p>\n<p>Monet UI-frameworkit sisältävät web-sovellusten käyttöön valmiiksi määriteltyjä teemoja sekä \"komponentteja\", kuten painikkeita, menuja, taulukkoja. Termi komponentti on edellä kirjotettu hipsuissa sillä kyse ei ole samasta asiasta kuin React-komponentti. Useimmiten UI-frameworkeja käytetään sisällyttämällä sovellukseen frameworkin määrittelemät CSS-tyylitiedostot sekä Javascript-koodi.</p>\n<p>Monesta UI-frameworkista on tehty React-ystävällisiä versiota, joissa UI-frameworkin avulla määritellyistä \"komponenteista\" on tehty React-komponentteja. Esim. Bootstrapista on olemassa parikin React-versiota <a href=\"http://reactstrap.github.io/\">reactstrap</a> ja <a href=\"https://react-bootstrap.github.io/\">react-bootstrap</a>.</p>\n<p>Katsotaan seuraavaksi kahta UI-framworkia bootstrapia ja <a href=\"https://semantic-ui.com/\">semantic ui</a>:ta.\nLisätään molempien avulla samantapaiset tyylit luvun <a href=\"/osa6/#react-router\">React-router</a> sovellukseen.</p>\n<h3>react bootstrap</h3>\n<p>Aloitetaan bootstrapista, käytetään kirjastoa <a href=\"https://react-bootstrap.github.io/\">react-bootstrap</a>.</p>\n<p>Asennetaan kirjasto suorittamalla komento</p>\n<pre><code class=\"language-bash\">npm install --save react-bootstrap\n</code></pre>\n<p>Lisätään sitten sovelluksen <em>public/index.html</em> tiedoston <em>head</em>-tagin sisään bootstrapin css-määrittelyt lataava rivi:</p>\n<pre><code class=\"language-html\">&#x3C;head>\n  &#x3C;link\n    rel=\"stylesheet\"\n    href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\"\n    integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\"\n    crossorigin=\"anonymous\"\n  />\n  // ...\n&#x3C;/head>\n</code></pre>\n<p>Kun sovellus ladataan uudelleen, näyttää se jo aavistuksen tyylikkäämmältä:</p>\n<picture><img src=\"/static/b914b0fefd57ab72760d4c8a8e32445b/14be6/10.png\" srcset=\"/static/b914b0fefd57ab72760d4c8a8e32445b/4cce7/10.png 200w,\n/static/b914b0fefd57ab72760d4c8a8e32445b/bae5f/10.png 400w,\n/static/b914b0fefd57ab72760d4c8a8e32445b/14be6/10.png 800w,\n/static/b914b0fefd57ab72760d4c8a8e32445b/1b35a/10.png 1200w,\n/static/b914b0fefd57ab72760d4c8a8e32445b/cbaf6/10.png 1404w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Bootstrapissa koko sivun sisältö renderöidään yleensä <a href=\"https://getbootstrap.com/docs/4.0/layout/overview/#containers\">container</a>:ina, eli käytännössä koko sovelluksen ympäröivä <em>div</em>-elementti merkitään luokalla <em>container</em>:</p>\n<pre><code class=\"language-react\">// ...\n\nclass App extends React.Component {\n  // ...\n  render() {\n    return (\n      &#x3C;div className=\"container\">\n        // ...\n      &#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<p>Sovelluksen ulkoasu muuttuu siten, että sisältö ei ole enää yhtä kiinni selaimen reunoissa:</p>\n<picture><img src=\"/static/c7e8beb2f708315545d1560cf80f6c8a/14be6/11.png\" srcset=\"/static/c7e8beb2f708315545d1560cf80f6c8a/4cce7/11.png 200w,\n/static/c7e8beb2f708315545d1560cf80f6c8a/bae5f/11.png 400w,\n/static/c7e8beb2f708315545d1560cf80f6c8a/14be6/11.png 800w,\n/static/c7e8beb2f708315545d1560cf80f6c8a/1b35a/11.png 1200w,\n/static/c7e8beb2f708315545d1560cf80f6c8a/8c3ef/11.png 1518w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Muutetaan seuraavaksi komponenttia <em>Notes</em> siten, että se renderöi muistiinpanojen listan <a href=\"https://getbootstrap.com/docs/4.0/content/tables/\">taulukkona</a>. React bootstrap tarjoaa valmiin komponentin <a href=\"https://react-bootstrap.github.io/components/table/\">Table</a>, joten CSS-luokan käyttöön ei ole tarvetta.</p>\n<pre><code class=\"language-react\">const Notes = ({notes}) => (\n  &#x3C;div>\n    &#x3C;h2>Notes&#x3C;/h2>\n    &#x3C;Table striped>\n      &#x3C;tbody>\n        {notes.map(note=>\n          &#x3C;tr key={note.id}>\n            &#x3C;td>\n              &#x3C;Link to={`/notes/${note.id}`}>{note.content}&#x3C;/Link>\n            &#x3C;/td>\n            &#x3C;td>\n              {note.user}\n            &#x3C;/td>\n          &#x3C;/tr>\n        )}\n      &#x3C;/tbody>\n    &#x3C;/Table>\n  &#x3C;/div>\n)\n</code></pre>\n<p>Ulkoasu on varsin tyylikäs:</p>\n<picture><img src=\"/static/d5175aa09c6e0f57668bc371c0525185/14be6/12.png\" srcset=\"/static/d5175aa09c6e0f57668bc371c0525185/4cce7/12.png 200w,\n/static/d5175aa09c6e0f57668bc371c0525185/bae5f/12.png 400w,\n/static/d5175aa09c6e0f57668bc371c0525185/14be6/12.png 800w,\n/static/d5175aa09c6e0f57668bc371c0525185/1b35a/12.png 1200w,\n/static/d5175aa09c6e0f57668bc371c0525185/b2a8e/12.png 1522w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Huomaa, että koodissa käytettävät React bootstrapin komponentit täytyy importata, eli koodiin on lisättävä:</p>\n<pre><code class=\"language-js\">import { Table } from 'react-bootstrap';\n</code></pre>\n<h4>Lomake</h4>\n<p>Parannellaan seuraavaksi näkymän <em>Login</em> kirjautumislomaketta Bootstrapin <a href=\"https://getbootstrap.com/docs/4.0/components/forms/\">lomakkeiden</a> avulla.</p>\n<p>React bootstrap tarjoaa valmiit <a href=\"https://react-bootstrap.github.io/components/forms/\">komponentit</a> myös lomakkeiden muodostamiseen (dokumentaatio tosin ei ole paras mahdollinen):</p>\n<pre><code class=\"language-react\">const Login = ({onLogin, history}) => {\n  // ...\n  return (\n    &#x3C;div>\n      &#x3C;h2>login&#x3C;/h2>\n      &#x3C;form onSubmit={onSubmit}>\n        &#x3C;FormGroup>\n          &#x3C;ControlLabel>username:&#x3C;/ControlLabel>\n          &#x3C;FormControl\n            type=\"text\"\n            name=\"username\"\n          />\n          &#x3C;ControlLabel>password:&#x3C;/ControlLabel>\n          &#x3C;FormControl\n            type=\"password\"\n          />\n          &#x3C;Button bsStyle=\"success\" type=\"submit\">login&#x3C;/Button>\n        &#x3C;/FormGroup>\n      &#x3C;/form>\n    &#x3C;/div>\n)}\n</code></pre>\n<p>Importoitavien komponenttien määrä kasvaa:</p>\n<pre><code class=\"language-js\">import {\n  Table,\n  FormGroup,\n  FormControl,\n  ControlLabel,\n  Button,\n} from 'react-bootstrap';\n</code></pre>\n<p>Lomake näyttää parantelun jälkeen seuraavalta:</p>\n<picture><img src=\"/static/1cc551bb5de16a29ae9571e49bdd5a68/14be6/12b.png\" srcset=\"/static/1cc551bb5de16a29ae9571e49bdd5a68/4cce7/12b.png 200w,\n/static/1cc551bb5de16a29ae9571e49bdd5a68/bae5f/12b.png 400w,\n/static/1cc551bb5de16a29ae9571e49bdd5a68/14be6/12b.png 800w,\n/static/1cc551bb5de16a29ae9571e49bdd5a68/1b35a/12b.png 1200w,\n/static/1cc551bb5de16a29ae9571e49bdd5a68/8b923/12b.png 1572w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<h4>Notifikaatio</h4>\n<p>Toteutetaan sovellukseen kirjautumisen jälkeinen <em>notifikaatio</em>:</p>\n<picture><img src=\"/static/600dba48f9410ec48a8df6ec00dfd37f/14be6/13.png\" srcset=\"/static/600dba48f9410ec48a8df6ec00dfd37f/4cce7/13.png 200w,\n/static/600dba48f9410ec48a8df6ec00dfd37f/bae5f/13.png 400w,\n/static/600dba48f9410ec48a8df6ec00dfd37f/14be6/13.png 800w,\n/static/600dba48f9410ec48a8df6ec00dfd37f/1b35a/13.png 1200w,\n/static/600dba48f9410ec48a8df6ec00dfd37f/9ee03/13.png 1600w,\n/static/600dba48f9410ec48a8df6ec00dfd37f/a6552/13.png 1778w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Asetetaan notifikaatio kirjautumisen yhteydessä komponentin <em>App</em> tilan kenttään <em>message</em>:</p>\n<pre><code class=\"language-js\">login = user => {\n  this.setState({ user, message: `welcome ${user}` });\n  setTimeout(() => {\n    this.setState({ message: null });\n  }, 10000);\n};\n</code></pre>\n<p>ja renderöidään viesti Bootstrapin <a href=\"https://getbootstrap.com/docs/4.0/components/alerts/\">Alert</a>-komponentin avulla. React bootstrap tarjoaa tähän jälleen valmiin <a href=\"https://react-bootstrap.github.io/components/alerts/\">React-komponentin</a>:</p>\n<pre><code class=\"language-react\">{(this.state.message &#x26;&#x26;\n  &#x3C;Alert color=\"success\">\n    {this.state.message}\n  &#x3C;/Alert>\n)}\n</code></pre>\n<h4>Navigaatiorakenne</h4>\n<p>Muutetaan vielä lopuksi sovelluksen navigaatiomenu käyttämään Bootstrapin <a href=\"https://getbootstrap.com/docs/4.0/components/navbar/\">Navbaria</a>. Tähänkin React bootstrap tarjoaa <a href=\"https://react-bootstrap.github.io/components/navbar/#navbars-mobile-friendly\">valmiit komponentit</a>, dokumentaatio on hieman kryptistä, mutta trial and error johtaa lopulta toimivaan ratkaisuun:</p>\n<pre><code class=\"language-bash\">&#x3C;Navbar inverse collapseOnSelect>\n  &#x3C;Navbar.Header>\n    &#x3C;Navbar.Brand>\n      Anecdote app\n    &#x3C;/Navbar.Brand>\n    &#x3C;Navbar.Toggle />\n  &#x3C;/Navbar.Header>\n  &#x3C;Navbar.Collapse>\n    &#x3C;Nav>\n      &#x3C;NavItem href=\"#\">\n        &#x3C;Link to=\"/\">home&#x3C;/Link>\n      &#x3C;/NavItem>\n      &#x3C;NavItem href=\"#\">\n        &#x3C;Link to=\"/notes\">notes&#x3C;/Link>\n      &#x3C;/NavItem>\n      &#x3C;NavItem href=\"#\">\n        &#x3C;Link to=\"/users\">users&#x3C;/Link>\n      &#x3C;/NavItem>\n      &#x3C;NavItem>\n        {this.state.user\n          ? &#x3C;em>{this.state.user} logged in&#x3C;/em>\n          : &#x3C;Link to=\"/login\">login&#x3C;/Link>\n        }\n      &#x3C;/NavItem>\n    &#x3C;/Nav>\n  &#x3C;/Navbar.Collapse>\n&#x3C;/Navbar>\n</code></pre>\n<p>Ulkoasu on varsin tyylikäs</p>\n<picture><img src=\"/static/696d1b1584cfe3f1d804e451f94b2071/14be6/14.png\" srcset=\"/static/696d1b1584cfe3f1d804e451f94b2071/4cce7/14.png 200w,\n/static/696d1b1584cfe3f1d804e451f94b2071/bae5f/14.png 400w,\n/static/696d1b1584cfe3f1d804e451f94b2071/14be6/14.png 800w,\n/static/696d1b1584cfe3f1d804e451f94b2071/1b35a/14.png 1200w,\n/static/696d1b1584cfe3f1d804e451f94b2071/9ee03/14.png 1600w,\n/static/696d1b1584cfe3f1d804e451f94b2071/9a091/14.png 1756w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Jos selaimen kokoa kaventaa, huomaamme että menu \"kollapsoituu\" ja sen saa näkyville vain klikkaamalla:</p>\n<picture><img src=\"/static/75e9480851bbe5c84f1483da328e72af/14be6/15.png\" srcset=\"/static/75e9480851bbe5c84f1483da328e72af/4cce7/15.png 200w,\n/static/75e9480851bbe5c84f1483da328e72af/bae5f/15.png 400w,\n/static/75e9480851bbe5c84f1483da328e72af/14be6/15.png 800w,\n/static/75e9480851bbe5c84f1483da328e72af/1b35a/15.png 1200w,\n/static/75e9480851bbe5c84f1483da328e72af/f5052/15.png 1476w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Bootstrap ja valtaosa tarjolla olevista UI-frameworkeista tuottavat <a href=\"https://en.wikipedia.org/wiki/Responsive_web_design\">responsiivisia</a> näkymiä, eli sellaisia jotka renderöityvät vähintään kohtuullisesti monen kokoisilla näytöillä.</p>\n<p>Chromen konsolin avulla on mahdollista simuloida sovelluksen käyttöä erilaisilla mobiilipäätteillä</p>\n<picture><img src=\"/static/1af080ec23cf2268f7ffd62979bb2996/14be6/16.png\" srcset=\"/static/1af080ec23cf2268f7ffd62979bb2996/4cce7/16.png 200w,\n/static/1af080ec23cf2268f7ffd62979bb2996/bae5f/16.png 400w,\n/static/1af080ec23cf2268f7ffd62979bb2996/14be6/16.png 800w,\n/static/1af080ec23cf2268f7ffd62979bb2996/1b35a/16.png 1200w,\n/static/1af080ec23cf2268f7ffd62979bb2996/9ee03/16.png 1600w,\n/static/1af080ec23cf2268f7ffd62979bb2996/72014/16.png 1690w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Sovellus toimii hyvin, mutta konsoliin vilkaisu paljastaa erään ikävän detaljin:</p>\n<picture><img src=\"/static/a780f2c5c127b477b0266ad4fc2f0cd0/14be6/17.png\" srcset=\"/static/a780f2c5c127b477b0266ad4fc2f0cd0/4cce7/17.png 200w,\n/static/a780f2c5c127b477b0266ad4fc2f0cd0/bae5f/17.png 400w,\n/static/a780f2c5c127b477b0266ad4fc2f0cd0/14be6/17.png 800w,\n/static/a780f2c5c127b477b0266ad4fc2f0cd0/1b35a/17.png 1200w,\n/static/a780f2c5c127b477b0266ad4fc2f0cd0/9ee03/17.png 1600w,\n/static/a780f2c5c127b477b0266ad4fc2f0cd0/a0ecf/17.png 1654w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Syy valituksiin on navigaatiorakenteessa</p>\n<pre><code class=\"language-bash\">&#x3C;NavItem href=\"#\">\n  &#x3C;Link to=\"/\">home&#x3C;/Link>\n&#x3C;/NavItem>\n</code></pre>\n<p>Nämä sisäkkäiset komponentit sisältävät molemmat <em>a</em>-tagin ja React hermostuu tästä.</p>\n<p>Ongelma on ikävä ja sen kiertäminen on toki mahdollista, katso esim.\n<a href=\"https://serverless-stack.com/chapters/adding-links-in-the-navbar.html\">https://serverless-stack.com/chapters/adding-links-in-the-navbar.html</a></p>\n<p>Esimerkin sovelluksen koodi kokonaisuudessaan <a href=\"https://github.com/FullStack-HY/FullStack-Hy.github.io/wiki/bootstrap\">täällä</a>.</p>\n<h3>Semantic UI</h3>\n<p>Olen käyttänyt bootstrapia vuosia, mutta siirryin hiljattain <a href=\"https://semantic-ui.com/\">Semantic UI</a>:n käyttäjäksi. Kurssin tehtävien <a href=\"https://studies.cs.helsinki.fi/fs-stats\">palautusovellus</a> on tehty Semanticilla ja kokemukset ovat olleet rohkaisevia, erityisesti semanticin <a href=\"https://react.semantic-ui.com\">React-tuki</a> on ensiluokkainen ja dokumentaatiokin huomattavasti parempi kuin bootstrapissa.</p>\n<p>Lisätään nyt <a href=\"/osa6/#react-router\">React-router</a>-sovellukselle edellisen luvun tapaan tyylit semanticilla.</p>\n<p>Aloitetaan asentamalla <a href=\"https://react.semantic-ui.com\">semantic-ui-react</a>-kirjasto:</p>\n<pre><code class=\"language-bash\">npm install --save semantic-ui-react\n</code></pre>\n<p>Lisätään sitten sovelluksen tiedostoon <em>public/index.html</em> head-tagin sisään semanticin css-määrittelyt lataava rivi (joka löytyy <a href=\"https://react.semantic-ui.com/usage#content-delivery-network-cdn\">tästä</a>):</p>\n<pre><code class=\"language-html\">&#x3C;head>\n  &#x3C;link rel=\"stylesheet\" href=\"//cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.2.12/semantic.min.css\">&#x3C;/link>\n  // ...\n&#x3C;/head>\n</code></pre>\n<p>Sijoitetaan koko sovelluksen renderöimä sisältö Semanticin komponentin <a href=\"https://react.semantic-ui.com/elements/container\">Container</a> sisälle.</p>\n<p>Semanticin dokumentaatio sisältää jokaisesta komponentista useita esimerkkikoodinpätkiä, joiden avulla komponenttien käytön periaatteet on helppo omaksua:</p>\n<picture><img src=\"/static/b9e6e01b48699a864c31b3a70af7ce71/14be6/18.png\" srcset=\"/static/b9e6e01b48699a864c31b3a70af7ce71/4cce7/18.png 200w,\n/static/b9e6e01b48699a864c31b3a70af7ce71/bae5f/18.png 400w,\n/static/b9e6e01b48699a864c31b3a70af7ce71/14be6/18.png 800w,\n/static/b9e6e01b48699a864c31b3a70af7ce71/1b35a/18.png 1200w,\n/static/b9e6e01b48699a864c31b3a70af7ce71/9ee03/18.png 1600w,\n/static/b9e6e01b48699a864c31b3a70af7ce71/c09de/18.png 1740w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Muutetaan komponentin App uloin <em>div</em>-elementti <em>Containeriksi</em>:</p>\n<pre><code class=\"language-bash\">import { Container } from 'semantic-ui-react'\n\n// ...\n\nclass App extends React.Component {\n  // ...\n  render() {\n    return (\n      &#x3C;Container>\n        // ...\n      &#x3C;/Container>\n    )\n  }\n}\n</code></pre>\n<p>Sivun sisältö ei ole enää reunoissa kiinni:</p>\n<picture><img src=\"/static/8e375f968b5bc220820e8151bce8fa4d/14be6/19.png\" srcset=\"/static/8e375f968b5bc220820e8151bce8fa4d/4cce7/19.png 200w,\n/static/8e375f968b5bc220820e8151bce8fa4d/bae5f/19.png 400w,\n/static/8e375f968b5bc220820e8151bce8fa4d/14be6/19.png 800w,\n/static/8e375f968b5bc220820e8151bce8fa4d/1b35a/19.png 1200w,\n/static/8e375f968b5bc220820e8151bce8fa4d/9ee03/19.png 1600w,\n/static/8e375f968b5bc220820e8151bce8fa4d/06ff7/19.png 1630w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Edellisen luvun tapaan, renderöidään muistiinpanot taulukkona, komponentin <a href=\"https://react.semantic-ui.com/collections/table\">Table</a> avulla. Koodi näyttää seuraavalta</p>\n<pre><code class=\"language-react\">import { Table } from 'semantic-ui-react'\n\nconst Notes = ({ notes }) => (\n  &#x3C;div>\n    &#x3C;h2>Notes&#x3C;/h2>\n    &#x3C;Table striped celled>\n      &#x3C;Table.Body>\n        {notes.map(note =>\n          &#x3C;Table.Row key={note.id}>\n            &#x3C;Table.Cell>\n              &#x3C;Link to={`/notes/${note.id}`}>{note.content}&#x3C;/Link>\n            &#x3C;/Table.Cell>\n            &#x3C;Table.Cell>\n              {note.user}\n            &#x3C;/Table.Cell>\n          &#x3C;/Table.Row>\n        )}\n      &#x3C;/Table.Body>\n    &#x3C;/Table>\n  &#x3C;/div>\n)\n</code></pre>\n<p>Muistiinpanojen lista näyttää seuraavalta:</p>\n<picture><img src=\"/static/d0606c506c403790adfc0de9f42a67ec/14be6/20.png\" srcset=\"/static/d0606c506c403790adfc0de9f42a67ec/4cce7/20.png 200w,\n/static/d0606c506c403790adfc0de9f42a67ec/bae5f/20.png 400w,\n/static/d0606c506c403790adfc0de9f42a67ec/14be6/20.png 800w,\n/static/d0606c506c403790adfc0de9f42a67ec/1b35a/20.png 1200w,\n/static/d0606c506c403790adfc0de9f42a67ec/9ee03/20.png 1600w,\n/static/d0606c506c403790adfc0de9f42a67ec/0c0a3/20.png 1624w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<h4>Lomake</h4>\n<p>Otetaan kirjautumissivulla käyttöön Semanticin <a href=\"https://react.semantic-ui.com/collections/form\">Form</a>-komponentti:</p>\n<pre><code>import { Form, Button } from 'semantic-ui-react'\n\nconst Login = ({ onLogin, history }) => {\n  const onSubmit = (event) => {\n    // ...\n  }\n  return (\n    &#x3C;div>\n      &#x3C;h2>login&#x3C;/h2>\n      &#x3C;Form onSubmit={onSubmit}>\n        &#x3C;Form.Field>\n          &#x3C;label>username&#x3C;/label>\n          &#x3C;input name='username' />\n        &#x3C;/Form.Field>\n        &#x3C;Form.Field>\n          &#x3C;label>password&#x3C;/label>\n          &#x3C;input type='password' />\n        &#x3C;/Form.Field>\n        &#x3C;Button type='submit'>login&#x3C;/Button>\n      &#x3C;/Form>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Ulkoasu näyttää seuraavalta:</p>\n<picture><img src=\"/static/d48b0e0c1325bf6e19c3ddc6e70419d0/14be6/21.png\" srcset=\"/static/d48b0e0c1325bf6e19c3ddc6e70419d0/4cce7/21.png 200w,\n/static/d48b0e0c1325bf6e19c3ddc6e70419d0/bae5f/21.png 400w,\n/static/d48b0e0c1325bf6e19c3ddc6e70419d0/14be6/21.png 800w,\n/static/d48b0e0c1325bf6e19c3ddc6e70419d0/1b35a/21.png 1200w,\n/static/d48b0e0c1325bf6e19c3ddc6e70419d0/b4b8e/21.png 1380w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<h4>Notifikaatio</h4>\n<p>Edellisen luvun tapaan, toteutetaan sovellukseen kirjautumisen jälkeinen <em>notifikaatio</em>:</p>\n<picture><img src=\"/static/7ee600a5c64170469543b2a9d7fc7e5d/14be6/22.png\" srcset=\"/static/7ee600a5c64170469543b2a9d7fc7e5d/4cce7/22.png 200w,\n/static/7ee600a5c64170469543b2a9d7fc7e5d/bae5f/22.png 400w,\n/static/7ee600a5c64170469543b2a9d7fc7e5d/14be6/22.png 800w,\n/static/7ee600a5c64170469543b2a9d7fc7e5d/1b35a/22.png 1200w,\n/static/7ee600a5c64170469543b2a9d7fc7e5d/f5052/22.png 1476w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Kuten edellisessä luvussa, asetetaan notifikaatio kirjautumisen yhteydessä komponentin <em>App</em> tilan kenttään <em>message</em>:</p>\n<pre><code class=\"language-js\">login = user => {\n  this.setState({ user, message: `welcome ${user}` });\n  setTimeout(() => {\n    this.setState({ message: null });\n  }, 10000);\n};\n</code></pre>\n<p>ja renderöidään viesti käyttäen komponenttia <a href=\"https://react.semantic-ui.com/collections/message\">Message</a>:</p>\n<pre><code class=\"language-react\">{(this.state.message &#x26;&#x26;\n  &#x3C;Message success>\n    {this.state.message}\n  &#x3C;/Message>\n)}\n</code></pre>\n<h4>Navigaatiorakenne</h4>\n<p>Navigaatiorakenne toteutetaan komponentin <a href=\"https://react.semantic-ui.com/collections/menu\">Menu</a> avulla:</p>\n<pre><code class=\"language-bash\">&#x3C;Menu inverted>\n  &#x3C;Menu.Item link>\n    &#x3C;Link to=\"/\">home&#x3C;/Link>\n  &#x3C;/Menu.Item>\n  &#x3C;Menu.Item link>\n    &#x3C;Link to=\"/notes\">notes&#x3C;/Link>\n  &#x3C;/Menu.Item>\n  &#x3C;Menu.Item link>\n    &#x3C;Link to=\"/users\">users&#x3C;/Link>\n  &#x3C;/Menu.Item>\n  &#x3C;Menu.Item link>\n    {this.state.user\n      ? &#x3C;em>{this.state.user} logged in&#x3C;/em>\n      : &#x3C;Link to=\"/login\">login&#x3C;/Link>\n    }\n  &#x3C;/Menu.Item>\n&#x3C;/Menu>\n</code></pre>\n<p>Lopputulos näyttää seuraavalta:</p>\n<picture><img src=\"/static/4d9567f0b1d250dacb099d30d764db21/14be6/23.png\" srcset=\"/static/4d9567f0b1d250dacb099d30d764db21/4cce7/23.png 200w,\n/static/4d9567f0b1d250dacb099d30d764db21/bae5f/23.png 400w,\n/static/4d9567f0b1d250dacb099d30d764db21/14be6/23.png 800w,\n/static/4d9567f0b1d250dacb099d30d764db21/1b35a/23.png 1200w,\n/static/4d9567f0b1d250dacb099d30d764db21/9ee03/23.png 1600w,\n/static/4d9567f0b1d250dacb099d30d764db21/beddc/23.png 1610w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Bootstrapin yhteydessä esiintynyttä sisäkkäisen <em>a</em>-tagien ongelmaa ei semanticin kanssa ole.</p>\n<p>Esimerkin sovelluksen koodi kokonaisuudessaan <a href=\"https://github.com/FullStack-HY/FullStack-Hy.github.io/wiki/semantic-ui\">täällä</a>.</p>\n<h3>Loppuhuomioita</h3>\n<p>Ero react-bootstrapin ja semantic-ui-reactin välillä ei ole suuri. On makuasia kummalla tuotettu ulkoasu on tyylikkäämpi. Oma vuosia kestäneen bootstrapin käytön jälkeinen siirtymiseni semanticiin johtuu semanticin saumattomammasta React-tuesta, laajemmasta valmiiden komponenttien valikoimasta ja paremmasta sekä selkeämmästä dokumentaatiosta. Semantic UI projektin kehitystyön jatkuvuuden suhteen on kuitenkin viime aikoina ollut ilmoilla muutamia <a href=\"https://github.com/Semantic-Org/Semantic-UI/issues/6109\">kysymysmerkkejä</a>, ja tilannetta kannattaakin seurata.</p>\n<p>Esimerkissä käytettiin UI-frameworkeja niiden React-integraatiot tarjoavien kirjastojen kautta.</p>\n<p>Sen sijaan että käytimme kirjastoa <a href=\"https://react-bootstrap.github.io/\">React bootstrap</a>, olisimme voineet aivan yhtä hyvin käyttää Bootstrapia suoraan, liittämällä HTML-elementteihin CSS-luokkia. Eli sen sijaan että määrittelimme esim. taulukon komponentin <em>Table</em> avulla</p>\n<pre><code class=\"language-bash\">&#x3C;Table striped>\n  // ...\n&#x3C;/Table>\n</code></pre>\n<p>olisimme voineet käyttää normaalia HTML:n taulukkoa <em>table</em> ja CSS-luokkaa</p>\n<pre><code class=\"language-bash\">&#x3C;table className=\"table striped\">\n  // ...\n&#x3C;/table>\n</code></pre>\n<p>Taulukon määrittelyssä React bootstrapin tuoma etu ei ole suuri.</p>\n<p>Tiiviimmän ja ehkä paremmin luettavissa olevan kirjoitusasun lisäksi toinen etu React-kirjastoina olevissa UI-frameworkeissa on se, että kirjastojen mahdollisesti käyttämä Javascript-koodi on sisällytetty React-komponentteihin. Esim. osa Bootstrapin komponenteista edellyttää toimiakseen muutamaakin ikävää <a href=\"https://getbootstrap.com/docs/4.0/getting-started/introduction/#js\">Javascript-riippuvuutta</a> joita emme mielellään halua React-sovelluksiin sisällyttää.</p>\n<p>React-kirjastoina tarjottavien UI-frameworkkien ikävä puoli verrattuna frameworkin \"suoraan käyttöön\" on React-kirjastojen API:n mahdollinen epästabiilius ja osittain huono dokumentaatio. Tosin <a href=\"https://react.semantic-ui.com\">react-semanticin</a> suhteen tilanne on paljon parempi kuin monien muiden UI-frameworkien sillä kyseessä on virallinen React-integraatio.</p>\n<p>Kokonaan toinen kysymys on se kannattaako UI-frameworkkeja ylipäätän käyttää. Kukin muodostakoon oman mielipiteensä, mutta CSS:ää taitamattomalle ja puutteellisilla design-taidoilla varustetulle ne ovat varsin käyttökelpoisia työkaluja.</p>\n<h3>Muita UI-frameworkeja</h3>\n<p>Luetellaan tässä kaikesta huolimatta muitakin UI-frameworkeja. Jos oma suosikkisi ei ole mukana, tee pull request</p>\n<ul>\n<li><a href=\"http://www.material-ui.com/\">http://www.material-ui.com/</a></li>\n<li><a href=\"https://bulma.io/\">https://bulma.io/</a></li>\n<li><a href=\"https://ant.design/\">https://ant.design/</a></li>\n<li><a href=\"https://foundation.zurb.com/\">https://foundation.zurb.com/</a></li>\n</ul>\n<p>Alun perin tässä osassa oli tarkoitus käyttää <a href=\"http://www.material-ui.com/\">Material UI</a>:ta, mutta kirjasto on juuri nyt kiivaan kehityksen alla ennen version 1.0 julkaisemista ja osa dokumentaation esimerkeistä ei toiminut uusimmalla versiolla. Voikin olla viisainta odotella Materialin kanssa versiota 1.0.</p>\n<h2>Tehtäviä</h2>\n<p>Tee nyt tehtävät <a href=\"/teht%C3%A4v%C3%A4t#ui-framework\">6.21-6.23</a></p>\n</div>","frontmatter":{"title":"osa 6","subTitle":"React+Redux","path":"/osa6/react-redux","mainImage":{"publicURL":"/static/osa6-8353c4cfa64d8ce630be96682a9ae6a4.png"},"partColor":"violet","part":6,"letter":"b"}}},"pageContext":{}}