{"data":{"markdownRemark":{"html":"<div class=\"content\">\n<h3>Monimutkaisempi tila</h3>\n<p>Edellisessä esimerkissä sovelluksen tila oli yksinkertainen, se koostui ainoastaan yhdestä kokonaisluvusta. Entä jos sovellus tarvitsee monimutkaisemman tilan?</p>\n<p>Helpoin ja useimmiten paras tapa on luoda sovellukselle useita erillisiä tiloja tai tilan \"osia\" kutsumalla funktiota <em>useState</em> useampaan kertaan.</p>\n<p>Seuraavassa sovellukselle luodaan kaksi alkuarvon 0 saavaa tilaa <em>left</em> ja <em>right</em>:</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  const [left, setLeft] = useState(0)\n  const [right, setRight] = useState(0)\n\n  return (\n    &#x3C;div>\n      &#x3C;div>\n        {left}\n        &#x3C;button onClick={() => setLeft(left + 1)}>vasen&#x3C;/button>\n        &#x3C;button onClick={() => setRight(right + 1)}>oikea&#x3C;/button>\n        {right}\n      &#x3C;/div>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Komponentti saa käyttöönsä tilan alustuksen yhteydessä funktiot <em>setLeft</em> ja <em>setRight</em> joiden avulla se voi päivittää tilaa.</p>\n<p>Komponentin tila tai yksittäinen tilan pala voi olla minkä tahansa muotoinen. Voisimme toteuttaa saman toiminnallisuuden tallentamalla näppäimenpainallukset yhteen olioon</p>\n<pre><code class=\"language-react\">{\n  left: 0,\n  right: 0\n}\n</code></pre>\n<p>sovellus muuttuisi seuraavasti:</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  const [clicks, setClicks] = useState({\n    left: 0, right: 0\n  })\n\n  return (\n    &#x3C;div>\n      &#x3C;div>\n        {clicks.left}\n        &#x3C;button onClick={() => setClicks({ left: clicks.left + 1, right: clicks.right })}>vasen&#x3C;/button>\n        &#x3C;button onClick={() => setClicks({ left: clicks.left, right: clicks.right + 1 })}>oikea&#x3C;/button>\n        {clicks.right}\n      &#x3C;/div>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Nyt komponentilla on siis ainoastaan yksi tila. Näppäinten painallusten yhteydessä on nyt huolehdittava koko tilan muutoksesta. </p>\n<p>Tapahtumankäsittelijä vaikuttaa hieman sotkuiselta. Kun vasenta nappia painetaan, suoritetaan seuraava funktio:</p>\n<pre><code class=\"language-js\">() => setClicks({ \n  left: clicks.left + 1,\n  right: clicks.right\n})\n</code></pre>\n<p>uudeksi tilaksi siis aseteaan seuraava olio</p>\n<pre><code class=\"language-js\">{ \n  left: clicks.left + 1,\n  right: clicks.right\n}\n</code></pre>\n<p>eli kentän <em>left</em> arvo on sama kuin alkuperäisen tilan kentän <em>left + 1</em> ja kentän <em>right</em> arvo on sama kuin alkuperäisen tilan kenttä <em>right</em>.</p>\n<p>Kaikien tilan pitäminen yhdessä oliossa on tämän sovelluksen kannalta huono ratkaisu, etuja siinä ei juuri ole, mutta sovellus monimutkaisuu merkittävästi. Onkin ehdottomasti parempi ratkaisu tallettaa nappien klikkaukset erillisiin tilan paloihin. </p>\n<h3>Taulukon käsittelyä</h3>\n<p>Tehdään sovellukseen vielä laajennus, lisätään sovelluken tilaan taulukko <em>allClicks</em> joka muistaa kaikki näppäimenpainallukset.</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  const [left, setLeft] = useState(0)\n  const [right, setRight] = useState(0)\n  const [allClicks, setAll] = useState([])\n\n  const handleLeftClick = () => {\n    setAll(allClicks.concat('L'))\n    setLeft(left + 1)\n  }\n\n  const handleRightClick = () => {\n    setAll(allClicks.concat('R'))\n    setRight(right + 1)\n  }\n\n  return (\n    &#x3C;div>\n      &#x3C;div>\n        {left}\n        &#x3C;button onClick={handleLeftClick}>vasen&#x3C;/button>\n        &#x3C;button onClick={handleRightClick}>oikea&#x3C;/button>\n        {right}\n        &#x3C;p>{allClicks.join(' ')}&#x3C;/p>\n      &#x3C;/div>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Kaikki klikkaukset siis talletetaan omaan tilan palaansa <em>allClicks</em> joka alustetaan tyhjäksi taulukoksi</p>\n<pre><code class=\"language-js\">const [allClicks, setAll] = useState([])\n</code></pre>\n<p>Kun esim. nappia <em>vasen</em> painetaan, lisätään tilan taulukkoon <em>kaikki</em> kirjain <em>L</em>:</p>\n<pre><code class=\"language-js\">const handleLeftClick = () => {\n  setAll(allClicks.concat('L'))\n  setLeft(left + 1)\n}\n</code></pre>\n<p>Tilan osa <em>allClicks</em> saa nyt arvokseen entisen taulukon, mihin on liitetty <em>L</em> metodilla <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat\">concat</a>, joka toimii siten, että se ei muuta olemassaolevaa taulukkoa vaan luo <em>uuden taulukon</em>, mihin uusi alkio on lisätty.</p>\n<p>Kuten jo aiemmin mainittiin, Javascriptissa on myös mahdollista lisätä taulukkoon metodilla <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push\">push</a> ja sovellus näyttäisi tässä tilanteessa toimivan myös jos lisäys hoidettaisiin siten että <em>allClicks</em>-tilaa muuteaan pushaamalla siihen alkio ja sitten päivitetään tila:</p>\n<pre><code class=\"language-js\">const handleLeftClick = () => {\n  allClicks.push('L')\n  setAll(allClick)\n  setLeft(left + 1)\n}\n</code></pre>\n<p>Älä kuitenkaan tee näin. React-komponentin tilaa, eli muuttujaa eli esim muuttujaa <em>allClicks</em> ei saa muuttaa, vaikka se näyttääkin toimivan joissaikin tilanteissa, voi seurauksena olla hankalasti havaittavia ongelmia.</p>\n<p>Katsotaan vielä tarkemmin, miten kaikkien painallusten historia renderöidään ruudulle:</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  // ...\n\n  return (\n    &#x3C;div>\n      &#x3C;div>\n        {left}\n        &#x3C;button onClick={handleLeftClick}>vasen&#x3C;/button>\n        &#x3C;button onClick={handleRightClick}>oikea&#x3C;/button>\n        {right}\n        &#x3C;p>{allClicks.join(' ')}&#x3C;/p>\n      &#x3C;/div>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Taulukolle <em>allClicks</em> kutsutaan metodia <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join\">join</a>, joka muodostaa taulukosta merkkijono, joka sisältää taulukon alkiot erotettuina välilyönnillä.</p>\n<h3>Ehdollinen renderöinti</h3>\n<p>Muutetaan sovellusta siten, että näppäilyhistorian renderöinnistä vastaa komponentti <em>History</em>:</p>\n<pre><code class=\"language-react\">const History = (props) => {\n  if (props.allClicks.length === 0) {\n    return (\n      &#x3C;div>\n        &#x3C;em>sovellusta käytetään nappeja painelemalla&#x3C;/em>\n      &#x3C;/div>\n    )\n  }\n\n  return (\n    &#x3C;div>\n        näppäilyhistoria: {props.allClicks.join(' ')}\n    &#x3C;/div>\n  )\n}\n\nconst App = (props) => {\n  // ...\n\n  return (\n    &#x3C;div>\n      &#x3C;div>\n        {left}\n        &#x3C;button onClick={handleLeftClick}>vasen&#x3C;/button>\n        &#x3C;button onClick={handleRightClick}>oikea&#x3C;/button>\n        {right}\n        &#x3C;History allClicks={allClicks} />\n      &#x3C;/div>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Nyt komponentin toiminta riippuu siitä, onko näppäimiä jo painettu. Jos ei, eli taulukko <code>allClicks</code> on tyhjä, renderöi komponentti \"käyttöohjeen\" sisältävän divin.</p>\n<pre><code class=\"language-html\">&#x3C;div>&#x3C;em>sovellusta käytetään nappeja painelemalla&#x3C;/em>&#x3C;/div>\n</code></pre>\n<p>ja muussa tapauksessa näppäilyhistorian:</p>\n<pre><code class=\"language-html\">&#x3C;div>näppäilyhistoria: {this.state.kaikki.join(' ')}&#x3C;/div>\n</code></pre>\n<p>Komponentin <em>History</em> ulkoasun muodostamat React-elementit siis ovat erilaisia riippuen sovelluksen tilasta, eli komponentissa on <em>ehdollista renderöintiä</em>.</p>\n<p>Reactissa on monia muitakin tapoja <a href=\"https://reactjs.org/docs/conditional-rendering.html\">ehdolliseen renderöintiin</a>. Katsotaan niitä tarkemmin <a href=\"/osa2\">seuraavassa osassa</a>.</p>\n<p>Muutetaan vielä sovellusta siten, että se käyttää aiemmin määrittelemäämme komponenttia <em>Button</em> painikkeiden muodostamiseen:</p>\n<pre><code class=\"language-react\">const History = (props) => {\n  if (props.allClicks.length === 0) {\n    return (\n      &#x3C;div>\n        &#x3C;em>sovellusta käytetään nappeja painelemalla&#x3C;/em>\n      &#x3C;/div>\n    )\n  }\n\n  return (\n    &#x3C;div>\n        näppäilyhistoria: {props.allClicks.join(' ')}\n    &#x3C;/div>\n  )\n}\n\nconst Button = ({ handleClick, text }) => (\n  &#x3C;button onClick={handleClick}>\n    {text}\n  &#x3C;/button>\n)\n\nconst App = (props) => {\n  const [left, setLeft] = useState(0)\n  const [right, setRight] = useState(0)\n  const [allClicks, setAll] = useState([])\n\n  const handleLeftClick = () => {\n    setAll(allClicks.concat('L'))\n    setLeft(left + 1)\n  }\n\n  const handleRightClick = () => {\n    setAll(allClicks.concat('R'))\n    setRight(right + 1)\n  }\n\n  return (\n    &#x3C;div>\n      &#x3C;div>\n        {left}\n        &#x3C;Button handleClick={handleLeftClick} text='vasen' />\n        &#x3C;Button handleClick={handleLeftClick} text='oikea' />\n        {right}\n        &#x3C;History allClicks={allClicks} />\n      &#x3C;/div>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<h3>Vanha React</h3>\n<p>Tällä kurssilla käyttämämme tapa React-komponenttien tilan määrittelyyn, eli <a href=\"https://reactjs.org/docs/hooks-state.html\">state hook</a> on siis uutta Reactia ja käytettävissä tällä hetkellä ainoastaan versiossa <a href=\"https://www.npmjs.com/package/react/v/16.7.0-alpha.2\">0.16.17.0-alpha.2</a>. Ennen hookeja Javascript-funktioina määriteltyihin React-komponentteihin ei ollut mahdollista saada tilaa ollenkaan, tilaa edellyttävät komponentit oli pakko määritellä <a href=\"https://reactjs.org/docs/react-component.html\">Class</a>-komponentteina Javascriptin luokkasyntaksia hyödyntäen. </p>\n<p>Olemme tällä kurssilla tehneet hieman radikaalinkin ratkaisun käyttää pelkästääm hookeja ja näin ollen opetella heti alusta asti ohjelmoimaan \"huomisen\" Reactia. Luokkasyntaksin hallitseminen on kuitenkin sikäli tärkeää, että vaikka funktiona määriteltävät komponentit ovat Reactin tulevaisuus, on maailmassa miljardeja rivejä vanhaa Reactia jota kenties sinäkin joudut jonain päivänä ylläpitämään. Dokumentaation ja internetistä löytyvien esimerkkien suhteen tilanne on sama, törmäät class-komponentteihin välittömästi.</p>\n<p>Tutustummekin riittävällä tasolla class-komponentteihin hieman myöhemmin kurssilla.</p>\n<h2>React-sovellusten debuggaus</h2>\n<p>Ohjelmistokehittäjän elämä koostuu pääosin debuggaamisesta (ja olemassaolevan koodin lukemisesta). Silloin tällöin syntyy toki muutama rivi uuttakin koodia, mutta suuri osa ajasta ihmetellään miksi joku on rikki tai miksi joku asia ylipäätään toimii. Hyvät debuggauskäytänteet ja työkalut ovatkin todella tärkeitä.</p>\n<p>Onneksi React on debuggauksen suhteen jopa harvinaisen kehittäjäystävällinen kirjasto.</p>\n<p>Muistutetaan vielä tärkeimmästä web-sovelluskehitykseen liittyvästä asiasta:</p>\n<div class=\"important\">\n  <h3>Web-sovelluskehityksen sääntö numero yksi</h3>\n  <div>Pidä selaimen developer-konsoli koko ajan auki.</div>\n  <br />\n  <div>Välilehdistä tulee olla auki nimenomaan <em>Console</em> jollei ole erityistä syytä käyttää jotain muuta välilehteä.\n  </div>\n</div>\n<p>Pidä myös koodi ja web-sivu <strong>koko ajan</strong> molemmat yhtä aikaa näkyvillä.</p>\n<p>Jos ja kun koodi ei käänny, eli selaimessa alkaa näkyä punaista</p>\n<picture><img src=\"/static/48e6ebd7c7bb8f4ebdbdd5ef6dc0a648/14be6/6a.png\" srcset=\"/static/48e6ebd7c7bb8f4ebdbdd5ef6dc0a648/4cce7/6a.png 200w,\n/static/48e6ebd7c7bb8f4ebdbdd5ef6dc0a648/bae5f/6a.png 400w,\n/static/48e6ebd7c7bb8f4ebdbdd5ef6dc0a648/14be6/6a.png 800w,\n/static/48e6ebd7c7bb8f4ebdbdd5ef6dc0a648/1b35a/6a.png 1200w,\n/static/48e6ebd7c7bb8f4ebdbdd5ef6dc0a648/9ee03/6a.png 1600w,\n/static/48e6ebd7c7bb8f4ebdbdd5ef6dc0a648/5e165/6a.png 1754w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>älä kirjota enää lisää koodia vaan selvitä ongelma <strong>välittömästi</strong>. Koodauksen historia ei tunne tilannetta, missä kääntymätön koodi alkaisi ihmeenomaisesti toimimaan kirjoittamalla suurta määrää lisää koodia, en usko että sellaista ihmettä nähdään tälläkään kurssilla.</p>\n<p>Vanha kunnon printtaukseen perustuva debuggaus kannattaa aina. Eli jos esim. komponentissa</p>\n<pre><code class=\"language-react\">const Button = ({ handleClick, text }) => (\n  &#x3C;button onClick={handleClick}>\n    {text}\n  &#x3C;/button>\n)\n</code></pre>\n<p>olisi jotain ongelmia, kannattaa komponentista alkaa printtailla konsoliin. Pystyäksemme printtaamaan, tulee funktio muuttaa pitempään muotoon ja propsit kannattaa kenties vastaanottaa ilman destrukturointia:</p>\n<pre><code class=\"language-react\">const Button = (props) => {\n  console.log(props)\n  const { handleClick, text } = props\n  return (\n    &#x3C;button onClick={handleClick}>\n      {text}\n    &#x3C;/button>\n  )\n}\n</code></pre>\n<p>näin selviää heti onko esim. joku propsia vastaava attribuutti nimetty väärin komponenttia käytettäessä.</p>\n<p><strong>HUOM</strong> kun käytät komentoa <em>console.log</em> debuggaukseen, älä yhdistele asioita \"javamaisesti\" plussalla, eli sen sijaan että kirjoittaisit</p>\n<pre><code class=\"language-js\">console.log('propsin arvo on' + props);\n</code></pre>\n<p>erottele tulostettavat asiat pilkulla:</p>\n<pre><code class=\"language-js\">console.log('propsin arvo on', props);\n</code></pre>\n<p>Jos yhdistät merkkijonoon olion, tuloksena on suhteellisen hyödytön tulostusmuoto</p>\n<pre><code class=\"language-bash\">propsin arvo on [Object object]\n</code></pre>\n<p>kun taas pilkulla tulostettavat asiat erotellessa saat developer-konsoliin olion, jonka sisältöä on mahdollista tarkastella.</p>\n<p>Koodin suorituksen voi pysäyttää chromen developer konsolin debuggeriin kirjoittamalla mihin tahansa kohtaa koodia komennon <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger\">debugger</a>.</p>\n<p>Koodi pysähtyy kun suoritus etenee sellaiseen pisteeseen, että komento <em>debugger</em> suoritetaan:</p>\n<picture><img src=\"/static/4a4bced189180676ff4019f459be833e/14be6/7a.png\" srcset=\"/static/4a4bced189180676ff4019f459be833e/4cce7/7a.png 200w,\n/static/4a4bced189180676ff4019f459be833e/bae5f/7a.png 400w,\n/static/4a4bced189180676ff4019f459be833e/14be6/7a.png 800w,\n/static/4a4bced189180676ff4019f459be833e/1b35a/7a.png 1200w,\n/static/4a4bced189180676ff4019f459be833e/9ee03/7a.png 1600w,\n/static/4a4bced189180676ff4019f459be833e/6e13f/7a.png 1810w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Menemällä välilehdelle <em>Console</em> on helppo tutkia muuttujien tilaa:</p>\n<picture><img src=\"/static/5ba1388f4d17134dcfc62fbeb2251421/14be6/8a.png\" srcset=\"/static/5ba1388f4d17134dcfc62fbeb2251421/4cce7/8a.png 200w,\n/static/5ba1388f4d17134dcfc62fbeb2251421/bae5f/8a.png 400w,\n/static/5ba1388f4d17134dcfc62fbeb2251421/14be6/8a.png 800w,\n/static/5ba1388f4d17134dcfc62fbeb2251421/1b35a/8a.png 1200w,\n/static/5ba1388f4d17134dcfc62fbeb2251421/237c2/8a.png 1432w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Kun bugi selviää, voi komennon <em>debugger</em> poistaa ja uudelleenladata sivun.</p>\n<p>Debuggerissa on mahdollista suorittaa koodia tarvittaessa rivi riviltä <em>Source</em> välilehden oikealta laidalta.</p>\n<p>Debuggeriin pääsee myös ilman komentoa <em>debugger</em> lisäämällä <em>Source</em>-välilehdellä sopiviin kohtiin koodia <em>breakpointeja</em>. Komponentin muuttujien arvojen tarkkailu on mahdollista  <em>Scope</em>-osassa:</p>\n<picture><img src=\"/static/c8c143bb940ecd99aea4dc4a1c0239f2/14be6/9a.png\" srcset=\"/static/c8c143bb940ecd99aea4dc4a1c0239f2/4cce7/9a.png 200w,\n/static/c8c143bb940ecd99aea4dc4a1c0239f2/bae5f/9a.png 400w,\n/static/c8c143bb940ecd99aea4dc4a1c0239f2/14be6/9a.png 800w,\n/static/c8c143bb940ecd99aea4dc4a1c0239f2/1b35a/9a.png 1200w,\n/static/c8c143bb940ecd99aea4dc4a1c0239f2/9ee03/9a.png 1600w,\n/static/c8c143bb940ecd99aea4dc4a1c0239f2/c7474/9a.png 1816w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Chromeen kannattaa ehdottomasti asentaa <a href=\"https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi\">React developer tools</a> -lisäosa, joka tuo konsoliin uuden tabin <em>React</em>:</p>\n<picture><img src=\"/static/cb6f9bd1fd7aa157b6c85b200623463a/14be6/10a.png\" srcset=\"/static/cb6f9bd1fd7aa157b6c85b200623463a/4cce7/10a.png 200w,\n/static/cb6f9bd1fd7aa157b6c85b200623463a/bae5f/10a.png 400w,\n/static/cb6f9bd1fd7aa157b6c85b200623463a/14be6/10a.png 800w,\n/static/cb6f9bd1fd7aa157b6c85b200623463a/1b35a/10a.png 1200w,\n/static/cb6f9bd1fd7aa157b6c85b200623463a/9ee03/10a.png 1600w,\n/static/cb6f9bd1fd7aa157b6c85b200623463a/a5108/10a.png 1726w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Uuden konsolitabin avulla voidaan tarkkailla sovelluksen React-elementtejä ja niiden tilaa ja propseja. </p>\n<p>React developer tools ei osaa toistaiseksi näyttää hookeilla muodostettua tilaa parhaalla mahdollisella tavalla.</p>\n<picture><img src=\"/static/69961e59e32d3560672c315c1745779c/14be6/11a.png\" srcset=\"/static/69961e59e32d3560672c315c1745779c/4cce7/11a.png 200w,\n/static/69961e59e32d3560672c315c1745779c/bae5f/11a.png 400w,\n/static/69961e59e32d3560672c315c1745779c/14be6/11a.png 800w,\n/static/69961e59e32d3560672c315c1745779c/1b35a/11a.png 1200w,\n/static/69961e59e32d3560672c315c1745779c/9ee03/11a.png 1600w,\n/static/69961e59e32d3560672c315c1745779c/dcc43/11a.png 1744w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Komponentin tila määriteltiin seuraavasti:</p>\n<pre><code class=\"language-js\">const [left, setLeft] = useState(0)\nconst [right, setRight] = useState(0)\nconst [allClicks, setAll] = useState([])\n</code></pre>\n<p>Konsolin ylimpänä oleva <em>baseState</em> kertoo ensimmäisen <em>useState</em>-kutsun määrittelevän tilan, eli muuttujan <em>left</em> arvon, seuraava <em>baseState</em> kertoo muuttujan <em>right</em> arvon ja taulukon <em>allClicks</em> arvo on alimpana. </p>\n<h2>Hookien säännöt</h2>\n<p>Jotta hookeilla muodostettu sovelluksen tila toimisi oikein, on hookeja käytettävä tiettyjä <a href=\"https://reactjs.org/docs/hooks-rules.html\">rajoituksia</a> noudattaen.</p>\n<p>Funktiota <em>useState</em> (eikä seuraavassa osassa esiteltävää funktiota <em>useEffect</em>) saa kutsua loopissa, ehtolausekkeiden sisältä tai muista kun komponentin määrittelevästä funktioista. Tämä takaa sen, että hookeja kutsutaan aina samassa järjestyksessä, jos näin ei ole, sovellus toimii miten sattuu.</p>\n<p>Hookeja siis kuuluu kutsua ainoastaan React-komponentin määrittelevän funktion rungosta:</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  // nämä ovat ok\n  const [age, setAge] = useState(0)\n  const [name, setName] = useState('Juha Tauriainen')\n\n  if ( age > 10 ) {\n    // ei näin!\n    const [foobar, setFoobar] = useState(null)\n  }\n\n  for ( let i = 0; i &#x3C; age; i++ ) {\n    // eikä näin!\n    const [rightWay, setRightWay] = useState(false)\n  }\n\n  const notGood = () => {\n    // eikä myöskään näin\n    const [x, setX] = useState(-1000)\n  }\n\n  return (\n    //...\n  ) \n} \n</code></pre>\n<h2>Tapahtumankäsittely revisited</h2>\n<p>Edellisen vuoden kurssin perusteella tapahtumankäsittely on osoittautunut monelle haastavaksi.</p>\n<p>Tarkastellaan asiaa vielä uudelleen.</p>\n<p>Oletetaan, että käytössä on äärimmäisen yksinkertainen sovellus:</p>\n<pre><code class=\"language-bash\">const App = (props) => {\n  const [value, setValue] = useState(10)\n\n  return (\n    &#x3C;div>\n      {value}\n      &#x3C;button>nollaa&#x3C;/button>\n    &#x3C;/div>\n  )\n}\n\nReactDOM.render(&#x3C;App />, document.getElementById('root'))\n</code></pre>\n<p>Haluamme, että napin avulla tilan talettava muuttuja <em>value</em> saadaan nollattua.</p>\n<p>Jotta saamme napin reagoimaan, on sille lisättävä <em>tapahtumankäsittelijä</em>.</p>\n<p>Tapahtumankäsittelijän tulee aina olla <em>funktio</em>. Jos tapahtumankäisttelijän paikalle yritetään laittaa jotain muuta, ei nappi toimi.</p>\n<p>Jos esim. antaisimme tapahtumankäsittelijäksi merkkijonon:</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={'roskaa'}>nappi&#x3C;/button>\n</code></pre>\n<p>React varoittaa asiasta konsolissa</p>\n<pre><code class=\"language-bash\">index.js:2178 Warning: Expected `onClick` listener to be a function, instead got a value of `string` type.\n    in button (at index.js:20)\n    in div (at index.js:18)\n    in App (at index.js:27)\n</code></pre>\n<p>eli esim. seuraavanlainen yritys olisi tuhoon tuomittu</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={value + 1}>nappi&#x3C;/button>\n</code></pre>\n<p>nyt tapahtumankäsittelijäksi on yritetty laittaa <em>value + 1</em> mikä tarkoittaa laskuoperaation tulosta. React varoittaa tästäkin konsolissa</p>\n<pre><code class=\"language-bash\">index.js:2178 Warning: Expected `onClick` listener to be a function, instead got a value of `number` type.\n</code></pre>\n<p>Myöskään seuraava ei toimi</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={value = 0}>nappi&#x3C;/button>\n</code></pre>\n<p>taaskaan tapahtumankäsittelijänä ei ole funktio vaan sijoitusoperaatio. Konsoliin tulee valitus. Tämä tapa on myös toisella tavalla väärin. Tilan muuttaminen ei onnistu suoraan tilan arvon tallentavaa muuttujaa muuttamalla.</p>\n<p>Entä seuraava:</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={console.log('nappia painettu')}>nappi&#x3C;/button>\n</code></pre>\n<p>konsoliin tulostuu kertaalleen <em>nappia painettu</em>, mutta nappia painellessa ei tapahdu mitään. Miksi tämä ei toimi vaikka tapahtumankäsittelijänä on nyt funktio <em>console.log</em>?</p>\n<p>Ongelma on nyt siinä, että tapahtumankäsittelijänä on funktion kutsu, eli varsinaiseksi tapahtumankäsittelijäksi tulee funktion kutsun paluuarvo, joka on tässä tapauksessa <em>undefined</em>.</p>\n<p>Funktiokutsu <em>console.log('nappia painettu')</em> suoritetaan siinä vaiheessa kun komponentti renderöidään, ja tämän takia konsoliin tulee tulostus kertalleen.</p>\n<p>Myös seuraava yritys on virheellinen</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={setValue(0)}>nappi&#x3C;/button>\n</code></pre>\n<p>jälleen olemme yrittäneet laittaa tapahtumankäsittelijäksi funktiokutsun. Ei toimi. Tämä yritys aiheuttaa myös toisen ongelman. Kun komponenttia renderöidään, suoritetaan tapahtumankäsittelijänä oleva funktiokutsu <em>setValue(0)</em> joka taas saa aikaan komponentin uudelleenrenderöinnin. Ja uudelleenrenderöinnin yhteydessä funktiota kutsutaan uudelleen käynnistäen jälleen uusi uudelleenrenderöinti, ja joudutaan päättymättömään rekursioon.</p>\n<p>Jos haluamme suorittaa tietyn funktiokutsun tapahtuvan nappia painettaessa, toimii seuraava</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={() => console.log('nappia painettu')}>nappi&#x3C;/button>\n</code></pre>\n<p>Nyt tapahtumankäsittelijä on nuolisyntaksilla määritelty funktio <em>() => console.log('nappia painettu')</em>. Kun komponentti renderöidään, ei suoriteta mitään, ainoastaan talletetaan funktioviite tapahtumankäsittelijäksi. Itse funktion suoritus tapahtuu vasta napin painallusten yhteydessä.</p>\n<p>Saamme myös nollauksen toimimaan samalla tekniikalla</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={() => setValue(0)}>nappi&#x3C;/button>\n</code></pre>\n<p>eli nyt tapahtumankäsittelijä on funktio <em>() => setValue(0)</em>.</p>\n<p>Tapahtumakäsittelijäfunktioiden määrittely suoraan napin määrittelyn yhteydessä ei välttämättä ole paras mahdollinen idea.</p>\n<p>Usein tapahtumankäsittelijä määritelläänkin jossain muualla. Seuraavassa määritellään funktio metodin render alussa ja sijoitetaan se muuttujaan <em>handleClick</em>:</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  const [value, setValue] = useState(10)\n\n  const handleClick = () => console.log('nappia painettu')\n\n  return (\n    &#x3C;div>\n      {value}\n      &#x3C;button onClick={handleClick}>nappi&#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Muuttujassa <em>handleClick</em> on nyt talletettuna viite itse funktioon. Viite annetaan napin määrittelyn yhteydessä</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={handleClick}>nappi&#x3C;/button>\n</code></pre>\n<p>Tapahtumankäsittelijäfunktio voi luonnollisesti koostua useista komennoista, tällöin käytetään nuolifunktion aaltosulullista muotoa:</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  const [value, setValue] = useState(10)\n\n  const handleClick = () => {\n    console.log('nappia painettu')\n    setValue(0)\n  }\n\n  return (\n    &#x3C;div>\n      {value}\n      &#x3C;button onClick={handleClick}>nappi&#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Mennään lopuksi funktioita palauttavaan funktioon.</p>\n<p>Muutetaan koodia seuraavasti</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  const [value, setValue] = useState(10)\n\n  const hello = () => {\n    const handler = () => console.log('hello world')\n\n    return handler\n  }\n\n  return (\n    &#x3C;div>\n      {value}\n      &#x3C;button onClick={hello()}>nappi&#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Koodi näyttää hankalalta mutta se ihme kyllä toimii.</p>\n<p>Tapahtumankäsittelijäksi on nyt \"rekisteröity\" funktiokutsu:</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={hello()}>nappi&#x3C;/button>\n</code></pre>\n<p>Aiemmin varoteltiin, että tapahtumankäsittelijä ei saa olla funktiokutsu vaan sen on oltava funktio tai viite funktioon. Miksi funktiokutsu kuitenkin toimii nyt?</p>\n<p>Kun komponenttia renderöidään suoritetaan seuraava funktio:</p>\n<pre><code class=\"language-react\">const hello = () => {\n  const handler = () => console.log('hello world')\n\n  return handler\n}\n</code></pre>\n<p>funktion <em>paluuarvona</em> on nyt toinen, muuttujaan <em>handler</em> määritelty funktio.</p>\n<p>eli kun react renderöi seuraavan rivin</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={hello()}>nappi&#x3C;/button>\n</code></pre>\n<p>sijoittaa se onClick-käsittelijäksi funktiokutsun <em>hello()</em> paluuarvon. Eli oleellisesti ottaen rivi \"muuttuu\" seuraavaksi</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={() => console.log('hello world')}>nappi&#x3C;/button>\n</code></pre>\n<p>koska funktio <em>hello</em> palautti funktion, on tapahtumankäsittelijä nyt funktio.</p>\n<p>Mitä järkeä tässä konseptissa on?</p>\n<p>Muutetaan koodia hiukan:</p>\n<pre><code class=\"language-bash\">const App = (props) => {\n  const [value, setValue] = useState(10)\n\n  const hello = (who) => {\n    const handler = () => {\n      console.log('hello', who)\n    }\n\n    return handler\n  }\n\n  return (\n    &#x3C;div>\n      {value}\n      &#x3C;button onClick={hello('world')}>nappi&#x3C;/button>\n      &#x3C;button onClick={hello('react')}>nappi&#x3C;/button>\n      &#x3C;button onClick={hello('function')}>nappi&#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Nyt meillä on kolme nappia joiden tapahtumankäsittelijät määritellään parametrin saavan funktion <em>hello</em> avulla.</p>\n<p>Ensimmäinen nappi määritellään seuraavasti</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={hello('world')}>nappi&#x3C;/button>\n</code></pre>\n<p>Tapahtumankäsittelijä siis saadaan <em>suorittamalla</em> funktiokutsu <em>hello('world')</em>. Funktiokutsu palauttaa funktion</p>\n<pre><code class=\"language-bash\">() => { \n  console.log('hello', 'world')\n}\n</code></pre>\n<p>Toinen nappi määritellään seuraavasti</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={hello('react')}>nappi&#x3C;/button>\n</code></pre>\n<p>Tapahtumankäsittelijän määrittelevä funktiokutsu <em>hello('react')</em> palauttaa</p>\n<pre><code class=\"language-bash\">() => { \n  console.log('hello', 'react')\n}\n</code></pre>\n<p>eli nappi saa oman yksilöllisen tapahtumankäsittelijänsä.</p>\n<p>Funktioita palauttavia funktioita voikin hyödyntää määrittelemään geneeristä toiminnallisuutta, jota voi tarkentaa parametrien avulla. Tapahtumankäsittelijöitä luovan funktion <em>hello</em> voikin ajatella olevan eräänlainen tehdas, jota voi pyytää valmistamaan sopivia tervehtimiseen tarkoitettuja tapahtumankäsittelijäfunktioita.</p>\n<p>Käyttämämme määrittelytapa</p>\n<pre><code class=\"language-bash\">const hello = (who) => {\n  const handler = () => { \n    console.log('hello', who)\n  }\n\n  return handler\n}\n</code></pre>\n<p>on hieman verboosi. Eliminoidaan apumuuttuja, ja määritellään palautettava funktio suoraan returnin yhteydessä:</p>\n<pre><code class=\"language-bash\">const hello = (who) => {\n  return () => { \n    console.log('hello', who)\n  }\n}\n</code></pre>\n<p>ja koska funktio <em>hello</em> sisältää ainoastaan yhden komennon, eli returnin, voidaan käyttää aaltosulutonta muotoa</p>\n<pre><code class=\"language-bash\">const hello = (who) =>\n  () => { \n    console.log('hello', who)\n  }\n</code></pre>\n<p>ja tuodaan vielä \"kaikki nuolet\" samalle riville</p>\n<pre><code class=\"language-bash\">const hello = (who) => () => { \n  console.log('hello', who)\n}\n</code></pre>\n<p>Voimme käyttää samaa kikkaa myös muodostamaan tapahtumankäsittelijöitä, jotka asettavat komponentin tilalle halutun arvon. Muutetaan koodi muotoon:</p>\n<pre><code class=\"language-bash\">render() {\n  const setToValue = (newValue) => () => {\n    setValue(newValue) \n  }\n\n  return (\n    &#x3C;div>\n      {value}\n      &#x3C;button onClick={setToValue(1000)}>tuhat&#x3C;/button>\n      &#x3C;button onClick={setToValue(0)}>nollaa&#x3C;/button>\n      &#x3C;button onClick={setToValue(value + 1)}>kasvata&#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Kun komponentti renderöidään, ja tehdään nappia tuhat</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={setToValue(1000)}>tuhat&#x3C;/button>\n</code></pre>\n<p>tulee tapahtumankäsittelijäksi funktiokutsun <em>setToValue(1000)</em> paluuarvo eli seuraava funktio</p>\n<pre><code class=\"language-bash\">() => {\n    setValue(1000) \n}\n</code></pre>\n<p>Kasvatusnapin generoima rivi on seuraava</p>\n<pre><code class=\"language-bash\">&#x3C;button onClick={setToValue(value + 1)}>kasvata&#x3C;/button>\n</code></pre>\n<p>Tapahtumankäsittelijän muodostaa funktiokutsu <em>setToValue(value + 1)</em>, joka saa parametrikseen tilan tallettavan muuttujan <em>value</em> nykyisen arvon kasvatettuna yhdellä. Jos <em>value</em> olisi 10, tulisi tapahtumankäsittelijäksi funktio</p>\n<pre><code class=\"language-bash\">() => {\n    setValue(11) \n}\n</code></pre>\n<h3>Hyödyllistä materiaalia</h3>\n<p>Internetissä on todella paljon Reactiin liittyvää materiaalia, tässä muutamia linkkejä:</p>\n<ul>\n<li>Reactin <a href=\"https://reactjs.org/docs/hello-world.html\">docs</a> kannattaa ehdottomasti käydä läpi, ei välttämättä kaikkea nyt, osa on ajankohtaista vasta kurssin myöhemmissä osissa</li>\n<li>Reactin sivuilla oleva <a href=\"https://reactjs.org/tutorial/tutorial.html\">tutoriaali</a> sen sijaan on aika huono</li>\n<li><a href=\"https://egghead.io\">Egghead.io</a>:n kursseista <a href=\"https://egghead.io/courses/start-learning-react\">Start learning React</a> on laadukas, ja hieman uudempi <a href=\"https://egghead.io/courses/the-beginner-s-guide-to-reactjs\">The Beginner's guide to React</a> on myös kohtuullisen hyvä; molemmat sisältävät myös asioita jotka tulevat tällä kurssilla vasta myöhemmissä osissa.</li>\n</ul>\n</div>\n<div class=\"tasks\">\n  <h3>Tehtäviä</h3>\n  <h4> 1.6: unicafe osa1</h4>\n<p>Monien firmojen tapaan nykyään myös <a href=\"https://www.unicafe.fi/#/9/4\">Unicafe</a> kerää asiakaspalautetta. Tee Unicafelle verkossa toimiva palautesovellus. Vastausvaihtoehtoja olkoon vain kolme: <i>hyvä</i>, <i>neutraali</i> ja <i>huono</i>.</p>\n<p>Sovelluksen tulee näyttää jokaisen palautteen lukumäärä. Sovellus voi näyttää esim. seuraavalta:</p>\n<picture><img src=\"/static/41cc3de89532b4d79fa7700e66e333fb/14be6/4c.png\" srcset=\"/static/41cc3de89532b4d79fa7700e66e333fb/4cce7/4c.png 200w,\n/static/41cc3de89532b4d79fa7700e66e333fb/bae5f/4c.png 400w,\n/static/41cc3de89532b4d79fa7700e66e333fb/14be6/4c.png 800w,\n/static/41cc3de89532b4d79fa7700e66e333fb/1b35a/4c.png 1200w,\n/static/41cc3de89532b4d79fa7700e66e333fb/0d767/4c.png 1460w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Huomaa, että sovelluksen tarvitsee toimia vain yhden selaimen käyttökerran ajan, esim. kun selain refreshataan, tilastot saavat hävitä.</p>\n<h4>1.7: unicafe osa2</h4>\n<p>Laajenna sovellusta siten, että se näyttää palautteista statistiikkaa, keskiarvon (hyvän arvo 1, neutraalin 0, huonon -1) ja sen kuinka monta prosenttia palautteista on ollut positiivisia:</p>\n<picture><img src=\"/static/8eeaee33949da20b66c30a6737f127aa/14be6/4d.png\" srcset=\"/static/8eeaee33949da20b66c30a6737f127aa/4cce7/4d.png 200w,\n/static/8eeaee33949da20b66c30a6737f127aa/bae5f/4d.png 400w,\n/static/8eeaee33949da20b66c30a6737f127aa/14be6/4d.png 800w,\n/static/8eeaee33949da20b66c30a6737f127aa/1b35a/4d.png 1200w,\n/static/8eeaee33949da20b66c30a6737f127aa/0dd5e/4d.png 1294w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<h4>1.8: unicafe osa3</h4>\n<p>Refaktoroi sovelluksesi siten, että se koostuu monista komponenteista. Pidä tila kuitenkin sovelluksen <em>juurikomponentissa</em>.</p>\n<p>Tee sovellukseen ainakin seuraavat komponentit:</p>\n<ul>\n<li><i>Button</i> vastaa yksittäistä palautteenantonappia</li>\n<li><i>Statistics</i> huolehtii tilastojen näyttämisestä</li>\n<li><i>Statistic</i> huolehtii yksittäisen tilastorivin, esim. keskiarvon näyttämisestä</li>\n</ul>\n<h4>1.9: unicafe osa4</h4>\n<p>Muuta sovellusta siten, että numeeriset tilastot näytetään ainoastaan jos palautteita on jo annettu:</p>\n<picture><img src=\"/static/ca65701774021dc5840250dfdb6778d2/14be6/5.png\" srcset=\"/static/ca65701774021dc5840250dfdb6778d2/4cce7/5.png 200w,\n/static/ca65701774021dc5840250dfdb6778d2/bae5f/5.png 400w,\n/static/ca65701774021dc5840250dfdb6778d2/14be6/5.png 800w,\n/static/ca65701774021dc5840250dfdb6778d2/1b35a/5.png 1200w,\n/static/ca65701774021dc5840250dfdb6778d2/d5d69/5.png 1424w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<h4>1.10*: unicafe osa5</h4>\n<p>Jos olet määritellyt jokaiselle napille oman tapahtumankäsittelijän, refaktoroi sovellustasi siten, että kaikki napit käyttävät samaa tapahtumankäsittelijäfunktiota samaan tapaan kuin materiaalin luvussa <a href=\"/osa1/#funktio-joka-palauttaa-funktion\">funktio joka palauttaa funktion</a>.</p>\n<p>Pari vihjettä. Ensinnäkin kannattaa muistaa, että olion kenttiin voi viitata pistenotaation lisäksi hakasulkeilla, eli:</p>\n<pre><code class=\"language-js\">const olio = {\n  a: 1,\n  b: 2,\n};\n\nolio['c'] = 3;\n\nconsole.log(olio.a); // tulostuu 1\n\nconsole.log(olio['b']); // tulostuu 2\n\nconst apu = 'c';\nconsole.log(olio[apu]); // tulostuu 3\n</code></pre>\n<p>Myös ns. <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer\">Computed property names</a> voi olla tässä tehtävässä hyödyksi.</p>\n<h4>1.11: unicafe osa6</h4>\n<p>Toteuta tilastojen näyttäminen HTML:n <a href=\"https://developer.mozilla.org/en-US/docs/Learn/HTML/Tables/Basics\">taulukkona</a> siten, että saat sovelluksesi näyttämään suunnilleen seuraavanlaiselta:</p>\n<picture><img src=\"/static/7500dfe6da204285cc1702be1538b140/14be6/6a.png\" srcset=\"/static/7500dfe6da204285cc1702be1538b140/4cce7/6a.png 200w,\n/static/7500dfe6da204285cc1702be1538b140/bae5f/6a.png 400w,\n/static/7500dfe6da204285cc1702be1538b140/14be6/6a.png 800w,\n/static/7500dfe6da204285cc1702be1538b140/1b35a/6a.png 1200w,\n/static/7500dfe6da204285cc1702be1538b140/97121/6a.png 1394w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Muista pitää konsoli koko ajan auki. Jos saat konsoliin seuraavan warningin:</p>\n<picture><img src=\"/static/cd8396f95df840c13fee0f449f049a06/14be6/7.png\" srcset=\"/static/cd8396f95df840c13fee0f449f049a06/4cce7/7.png 200w,\n/static/cd8396f95df840c13fee0f449f049a06/bae5f/7.png 400w,\n/static/cd8396f95df840c13fee0f449f049a06/14be6/7.png 800w,\n/static/cd8396f95df840c13fee0f449f049a06/1b35a/7.png 1200w,\n/static/cd8396f95df840c13fee0f449f049a06/9ee03/7.png 1600w,\n/static/cd8396f95df840c13fee0f449f049a06/a6552/7.png 1778w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>tee tarvittavat toimenpiteet jotta saat warningin katoamaan. Googlaa tarvittaessa virheilmoituksella.</p>\n<p><strong>Huolehdi nyt ja jatkossa, että konsolissa ei näy mitään warningeja!</strong></p>\n<h4>1.12*: anekdootit osa1</h4>\n<p>Ohjelmistotuotannossa tunnetaan lukematon määrä <a href=\"http://www.comp.nus.edu.sg/~damithch/pages/SE-quotes.htm\">anekdootteja</a> eli pieniä \"onelinereita\", jotka kiteyttävät alan ikuisia totuuksia.</p>\n<p>Laajenna seuraavaa sovellusta siten, että siihen tulee nappi, jota painamalla sovellus näyttää <em>satunnaisen</em> ohjelmistotuotantoon liittyvän anekdootin:</p>\n<pre><code class=\"language-react\">import React from 'react'\nimport ReactDOM from 'react-dom'\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      selected: 0\n    }\n  }\n\n  render() {\n    return (\n      &#x3C;div>\n        {this.props.anecdotes[this.state.selected]}\n      &#x3C;/div>\n    )\n  }\n}\n\nconst anecdotes = [\n  'If it hurts, do it more often',\n  'Adding manpower to a late software project makes it later!',\n  'The first 90 percent of the code accounts for the first 90 percent of the development time...The remaining 10 percent of the code accounts for the other 90 percent of the development time.',\n  'Any fool can write code that a computer can understand. Good programmers write code that humans can understand.',\n  'Premature optimization is the root of all evil.',\n  'Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.'\n]\n\nReactDOM.render(\n  &#x3C;App anecdotes={anecdotes} />,\n  document.getElementById('root')\n)\n</code></pre>\n<p>Google kertoo, miten voit generoida Javascriptilla sopivia satunnaisia lukuja. Muista, että voit testata esim. satunnaislukujen generointia konsolissa.</p>\n<p>Sovellus voi näyttää esim. seuraavalta:</p>\n<picture><img src=\"/static/a58354ed43c6ee83bab346b1ed5240a7/14be6/2.png\" srcset=\"/static/a58354ed43c6ee83bab346b1ed5240a7/4cce7/2.png 200w,\n/static/a58354ed43c6ee83bab346b1ed5240a7/bae5f/2.png 400w,\n/static/a58354ed43c6ee83bab346b1ed5240a7/14be6/2.png 800w,\n/static/a58354ed43c6ee83bab346b1ed5240a7/1b35a/2.png 1200w,\n/static/a58354ed43c6ee83bab346b1ed5240a7/e8390/2.png 1492w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<h4>1.13: anekdootit osa2</h4>\n<p>Laajenna sovellusta siten, että näytettävää anekdoottia on mahdollista äänestää:</p>\n<picture><img src=\"/static/fbb8bc0bc2a60aa9b725f45b2c2911d1/14be6/3.png\" srcset=\"/static/fbb8bc0bc2a60aa9b725f45b2c2911d1/4cce7/3.png 200w,\n/static/fbb8bc0bc2a60aa9b725f45b2c2911d1/bae5f/3.png 400w,\n/static/fbb8bc0bc2a60aa9b725f45b2c2911d1/14be6/3.png 800w,\n/static/fbb8bc0bc2a60aa9b725f45b2c2911d1/1b35a/3.png 1200w,\n/static/fbb8bc0bc2a60aa9b725f45b2c2911d1/0d767/3.png 1460w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p><strong>Huom:</strong> jos päätät tallettaa kunkin anekdootin äänet komponentin tilassa olevan olion kenttiin tai taulukkoon, saatat tarvita päivittäessäsi tilaa oikeaoppisesti olion tai taulukon <em>kopioimista</em>.</p>\n<p>Olio voidaan kopioida esim. seuraavasti:</p>\n<pre><code class=\"language-js\">const pisteet = { 0: 1, 1: 3, 2: 4, 3: 2 };\n\nconst kopio = { ...pisteet };\nkopio[2] += 1; // kasvatetaan olion kentän 2 arvoa yhdellä\n</code></pre>\n<p>ja taulukko esim. seuraavasti:</p>\n<pre><code class=\"language-js\">const pisteet = [1, 4, 6, 3];\n\nconst kopio = [...pisteet];\nkopio[2] += 1; // kasvatetaan taulukon paikan 2 arvoa yhdellä\n</code></pre>\n<h4>1.14*: anekdootit osa3</h4>\n<p>Ja sitten vielä lopullinen versio, joka näyttää eniten ääniä saaneen anekdootin:</p>\n<picture><img src=\"/static/2b1a015cd08c9b5ef3eb334813978d99/14be6/3b.png\" srcset=\"/static/2b1a015cd08c9b5ef3eb334813978d99/4cce7/3b.png 200w,\n/static/2b1a015cd08c9b5ef3eb334813978d99/bae5f/3b.png 400w,\n/static/2b1a015cd08c9b5ef3eb334813978d99/14be6/3b.png 800w,\n/static/2b1a015cd08c9b5ef3eb334813978d99/1b35a/3b.png 1200w,\n/static/2b1a015cd08c9b5ef3eb334813978d99/97121/3b.png 1394w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Jos suurimman äänimäärän saaneita anekdootteja on useita, riittää että niistä näytetään yksi.</p>\n<p>Tämä saattaa olla jo hieman haastavampi. Taulukolta löytyy monia hyviä metodeja, katso lisää <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\">Mozillan dokumentaatiosta</a>.</p>\n<p>Youtubessa on kohtuullisen hyvä <a href=\"https://www.youtube.com/watch?v=BMUiFMZr7vk&#x26;list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84\">johdatus funktionaaliseen javascript-ohjelmointiin</a>. Kolmen ensimmäisen osan katsominen riittää hyvin tässä vaiheessa.</p>\n</div>","frontmatter":{"title":"osa 1","subTitle":"Monimutkaisempi tila ja Reactin debuggaus","path":"/osa1/monimutkainen_tila","mainImage":{"publicURL":"/static/osa1-b7ac07cbe6df8ed745701fabe73af8ef.png"},"partColor":"green","part":1,"letter":"d"}}},"pageContext":{}}