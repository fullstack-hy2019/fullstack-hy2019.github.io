{"data":{"markdownRemark":{"html":"<div class=\"content\">\n<p>Ennen kun menemme uuteen asiaan, nostetaan esiin muutama edellisen osan huomiota herättänyt seikka.</p>\n<h3>console.log</h3>\n<p><strong>Mikä erottaa kokeneen ja kokemattoman Javascript-ohjelmoijan? Kokeneet käyttävät 10-100 kertaa enemmän console.logia</strong>.</p>\n<p>Paradoksaalista kyllä tämä näyttää olevan tilanne, vaikka kokematon ohjelmoija oikeastaan tarvitsisi console.logia (tai jotain muita debuggaustapoja) huomattavissa määrin kokenutta enemmän. </p>\n<p>Eli kun joku ei toimi, älä arvaile vaan logaa tai käytä jotain muita debuggauskeinoja.</p>\n<p><strong>HUOM</strong> kun käytät komentoa <em>console.log</em> debuggaukseen, älä yhdistele asioita \"javamaisesti\" plussalla, eli sen sijaan että kirjoittaisit</p>\n<pre><code class=\"language-js\">console.log('propsin arvo on' + props)\n</code></pre>\n<p>erottele tulostettavat asiat pilkulla:</p>\n<pre><code class=\"language-js\">console.log('propsin arvo on', props)\n</code></pre>\n<p>Jos yhdistät merkkijonoon olion, tuloksena on suhteellisen hyödytön tulostusmuoto</p>\n<pre><code class=\"language-js\">propsin arvo on [Object object]\n</code></pre>\n<p>kun taas pilkulla erotellessa saat tulostettavat asiat developer-konsoliin oliona, jonka sisältöä on mahdollista tarkastella.</p>\n<h3>Tapahtumankäsittely revisited</h3>\n<p>Pajan ja telegrammin havaintojen perusteella tapahtumankäsittely on osoittautunut haastavaksi.</p>\n<p>Osasan loppussa oleva kertaava osa <a href=\"/osa1#tapahtumank%C3%A4sittely-revisited\">tapahtumankäsittely revisited</a> kannattaa käydä läpi jos osaaminen on vielä häilyvällä pohjalla.</p>\n<h3>Visual Studio Coden snippetit</h3>\n<p>Visual studio codeen on helppo määritellä \"snippettejä\", eli Netbeansin \"sout\":in tapaisia oikoteitä yleisesti käytettyjen koodinpätkien generointiin. Ohje snippetien luomiseen <a href=\"https://code.visualstudio.com/docs/editor/userdefinedsnippets#_creating-your-own-snippets\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">täällä</a></p>\n<p>VS Code -plugineina löytyy myös hyödyllisiä valmiiksi määriteltyjä snippettejä, esim.\n<a href=\"https://marketplace.visualstudio.com/items?itemName=xabikos.ReactSnippets\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">tämä</a></p>\n<p>Tärkein kaikista snippeteistä on komennon <code>console.log()</code> nopeasti ruudulle tekevä snippet, esim. <code>clog</code>, jonka voi määritellä seuraavasti:</p>\n<pre><code class=\"language-js\">{\n  \"console.log\": {\n    \"prefix\": \"clog\",\n    \"body\": [\n      \"console.log('$1')\",\n    ],\n    \"description\": \"Log output to console\"\n  }\n}\n</code></pre>\n<h3>Taulukkojen käyttö Javascriptissä</h3>\n<p>Tästä osasta lähtien käytämme runsaasti Javascriptin <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">taulukkojen</a> funktionaalisia käsittelymetodeja, kuten <em>find</em>, <em>filter</em> ja <em>map</em>. Periaate niissä on täysin sama kuin Java 8:sta tutuissa streameissa, joita on käytetty jo parin vuoden ajan Tietojenkäsittelytieteen osaston Ohjelmoinnin perusteissa ja jatkokurssilla sekä Ohjelmoinnin MOOC:issa.</p>\n<p>Jos taulukon funktionaalinen käsittely tuntuu vielä vieraalta, kannattaa katsoa Youtubessa olevasta videosarjasta <em>Functional Programming in JavaScript</em> ainakin kolme ensimmäistä osaa</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=BMUiFMZr7vk&#x26;list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Higher-order functions</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=bCqtb-Z5YGQ&#x26;list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84&#x26;index=2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Map</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=Wl98eZpkp-c&#x26;t=31s\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Reduce basics</a></li>\n</ul>\n<h2>Kokoelmien renderöiminen</h2>\n<p>Tehdään nyt Reactilla <a href=\"/osa0\">osan 0</a> alussa käytettyä esimerkkisovelluksen <a href=\"https://fullstack-exampleapp.herokuapp.com/spa\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Single page app -versiota</a> vastaavan sovelluksen 'frontend' eli selainpuolen sovelluslogiikka.</p>\n<p>Aloitetaan seuraavasta:</p>\n<pre><code class=\"language-js\">import React from 'react'\nimport ReactDOM from 'react-dom'\n\nconst notes = [\n  {\n    id: 1,\n    content: 'HTML on helppoa',\n    date: '2019-01-10T17:30:31.098Z',\n    important: true\n  },\n  {\n    id: 2,\n    content: 'Selain pystyy suorittamaan vain javascriptiä',\n    date: '2019-01-10T18:39:34.091Z',\n    important: false\n  },\n  {\n    id: 3,\n    content: 'HTTP-protokollan tärkeimmät metodit ovat GET ja POST',\n    date: '2019-01-10T19:20:14.298Z',\n    important: true\n  }\n]\n\nconst App = (props) => {\n  const { notes } = props\n\n  return (\n    &#x3C;div>\n      &#x3C;h1>Muistiinpanot&#x3C;/h1>\n      &#x3C;ul>\n        &#x3C;li>{notes[0].content}&#x3C;/li>\n        &#x3C;li>{notes[1].content}&#x3C;/li>\n        &#x3C;li>{notes[2].content}&#x3C;/li>\n      &#x3C;/ul>\n    &#x3C;/div>\n  )\n}\n\nReactDOM.render(\n  &#x3C;App notes={notes} />,\n  document.getElementById('root')\n)\n</code></pre>\n<p>Jokaiseen muistiinpanoon on merkitty tekstuaalisen sisällön ja aikaleiman lisäksi myös <em>boolean</em>-arvo, joka kertoo onko muistiinpano luokiteltu tärkeäksi, sekä yksikäsitteinen tunniste <em>id</em>.</p>\n<p>Koodin toiminta perustuu siihen, että taulukossa on tasan kolme muistiinpanoa, yksittäiset muistiinpanot renderöidään 'kovakoodatusti' viittaamalla suoraan taulukossa oleviin olioihin:</p>\n<pre><code class=\"language-js\">&#x3C;li>{note[1].content}&#x3C;/li>\n</code></pre>\n<p>Tämä ei tietenkään ole järkevää. Ratkaisu voidaan yleistää generoimalla taulukon perusteella joukko React-elementtejä käyttäen <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">map</a>-funktiota:</p>\n<pre><code class=\"language-js\">notes.map(note => &#x3C;li>{note.content}&#x3C;/li>)\n</code></pre>\n<p>nyt tuloksena on taulukko, jonka sisältö on joukko <em>li</em>-elementtejä</p>\n<pre><code class=\"language-js\">[\n  '&#x3C;li>HTML on helppoa&#x3C;/li>',\n  '&#x3C;li>Selain pystyy suorittamaan vain javascriptiä&#x3C;/li>',\n  '&#x3C;li>HTTP-protokollan tärkeimmät metodit ovat GET ja POST&#x3C;/li>',\n]\n</code></pre>\n<p>jotka voidaan sijoittaa <em>ul</em>-tagien sisälle:</p>\n<pre><code class=\"language-js\">const App = (props) => {\n  const { notes } = props\n\n  return (\n    &#x3C;div>\n      &#x3C;h1>Muistiinpanot&#x3C;/h1>\n// highlight-start\n      &#x3C;ul>\n        {notes.map(note => &#x3C;li>{note.content}&#x3C;/li>)}\n      &#x3C;/ul>\n// highlight-end      \n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Koska li-tagit generoiva koodi on Javascriptia, tulee se sijoittaa JSX-templatessa aaltosulkujen sisälle kaiken muun Javascript-koodin tapaan.</p>\n<p>Usein vastaavissa tilanteissa dynaamisesti generoitava sisältö eristetään omaan metodiin, jota JSX-template kutsuu:</p>\n<pre><code class=\"language-js\">const App = (props) => {\n  const { notes } = props\n\n// highlight-start\n  const rows = () =>\n    notes.map(note => &#x3C;li>{note.content}&#x3C;/li>)\n// highlight-end\n\n  return (\n    &#x3C;div>\n      &#x3C;h1>Muistiinpanot&#x3C;/h1>\n      &#x3C;ul>\n        {rows()} // highlight-line\n      &#x3C;/ul>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<h3>Key-attribuutti</h3>\n<p>Vaikka sovellus näyttää toimivan, tulee konsoliin ikävä varoitus</p>\n<p><img src=\"../images/2/1a.png\"></p>\n<p>Kuten virheilmoituksen linkittämä <a href=\"https://reactjs.org/docs/lists-and-keys.html#keys\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">sivu</a> kertoo, tulee taulukossa olevilla, eli käytännössä <em>map</em>-metodilla muodostetuilla elementeillä olla uniikki avain, eli attribuutti nimeltään <em>key</em>.</p>\n<p>Lisätään avaimet:</p>\n<pre><code class=\"language-js\">const App = (props) => {\n  const { notes } = props\n\n  const rows = () =>\n    notes.map(note => &#x3C;li key={note.id}>{note.content}&#x3C;/li>) // highlight-line\n\n  return (\n    &#x3C;div>\n      &#x3C;h1>Muistiinpanot&#x3C;/h1>\n      &#x3C;ul>\n        {rows()}\n      &#x3C;/ul>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Virheilmoitus katoaa.</p>\n<p>React käyttää taulukossa olevien elementtien key-kenttiä päätellessään miten sen tulee päivittää komponentin generoimaa näkymää silloin kun komponentti uudelleenrenderöidään. Lisää aiheesta <a href=\"https://reactjs.org/docs/reconciliation.html#recursing-on-children\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">täällä</a>.</p>\n<h3>Map</h3>\n<p>Taulukoiden metodin <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">map</a> toiminnan sisäistäminen on jatkon kannalta äärimmäisen tärkeää.</p>\n<p>Sovellus siis sisältää taulukon <em>notes</em></p>\n<pre><code class=\"language-js\">const notes = [\n  {\n    id: 1,\n    content: 'HTML on helppoa',\n    date: '2017-12-10T17:30:31.098Z',\n    important: true,\n  },\n  {\n    id: 2,\n    content: 'Selain pystyy suorittamaan vain javascriptiä',\n    date: '2017-12-10T18:39:34.091Z',\n    important: false,\n  },\n  {\n    id: 3,\n    content: 'HTTP-protokollan tärkeimmät metodit ovat GET ja POST',\n    date: '2017-12-10T19:20:14.298Z',\n    important: true,\n  },\n]\n</code></pre>\n<p>Pysähdytään hetkeksi tarkastelemaan miten <em>map</em> toimii.</p>\n<p>Jos esim. tiedoston loppuun lisätään seuraava koodi</p>\n<pre><code class=\"language-js\">const result = notes.map(note => note.id)\nconsole.log(result)\n</code></pre>\n<p>tulostuu konsoliin <em>[1, 2, 3]</em> eli <em>map</em> muodostaa uuden taulukon, jonka jokainen alkio on saatu alkuperäisen taulukon <em>notes</em> alkioista <em>mappaamalla</em> komennon parametrina olevan funktion avulla.</p>\n<p>Funktio on</p>\n<pre><code class=\"language-js\">note => note.id\n</code></pre>\n<p>eli kompaktissa muodossa kirjoitettu nuolifunktio, joka on täydelliseltä kirjoitustavaltaan seuraava</p>\n<pre><code class=\"language-js\">(note) => {\n  return note.id\n}\n</code></pre>\n<p>eli funktio saa parametrikseen muistiinpano-olion ja <em>palauttaa</em> sen kentän <em>id</em> arvon.</p>\n<p>Muuttamalla komento muotoon</p>\n<pre><code class=\"language-js\">const result = notes.map(note => note.content)\n</code></pre>\n<p>tuloksena on taulukko, joka koostuu muistiinpanojen sisällöistä.</p>\n<p>Tämä on jo lähellä käyttämäämme React-koodia:</p>\n<pre><code class=\"language-js\">notes.map(note => &#x3C;li key={note.id}>{note.content}&#x3C;/li>)\n</code></pre>\n<p>joka muodostaa jokaista muistiinpano-olioa vastaavan <em>li</em>-tagin, jonka sisään tulee muistiinpanon sisältö.</p>\n<p>Koska metodin <em>map</em> parametrina olevan funktion</p>\n<pre><code class=\"language-js\">note => &#x3C;li key={note.id}>{note.content}&#x3C;/li>\n</code></pre>\n<p>käyttötarkoitus on näkymäelementtien muodostaminen, tulee muuttujan arvo renderöidä aaltosulkeiden sisällä. Kokeile mitä koodi tekee, jos poistat aaltosulkeet.</p>\n<p>Aaltosulkeiden käyttö tulee varmaan aiheuttamaan alussa pientä päänvaivaa, mutta totut niihin pian. Reactin antama visuaalinen feedback on välitön.</p>\n<p>Tarkastellaan vielä erästä bugien lähdettä. Lisää koodiin seuraava</p>\n<pre><code class=\"language-js\">const result = notes.map(note => {note.content} )\nconsole.log(result)\n</code></pre>\n<p>Tulostuu</p>\n<pre><code class=\"language-js\">[undefined, undefined, undefined]\n</code></pre>\n<p>Missä on vika? Koodihan on ihan sama kun äsken toiminut koodi. Paitsi ei ihan. Metodin <em>map</em> parametrina on nyt seuraava funktio</p>\n<pre><code class=\"language-js\">note => {\n  note.content\n}\n</code></pre>\n<p>Koska funktio koostuu nyt <em>koodilohkosta</em> on funktion paluuarvo määrittelemätön eli <em>undefined</em>. Nuolifunktiot siis palauttavat ainoan komentonsa arvon, ainoastaan jos nuolifunktio on määritelty kompaktissa muodossaan, ilman koodilohkoa:</p>\n<pre><code class=\"language-js\">note => note.content\n</code></pre>\n<p>huomaa, että 'oneliner'-nuolifunktioissa kaikkea ei tarvitse eikä aina kannatakaan kirjoittaa samalle riville.</p>\n<p>Parempi muotoilu ohjelmamme muistiinpanorivit tuottavalle apufunktiolle saattaakin olla seuraava useille riveille jaoteltu versio:</p>\n<pre><code class=\"language-js\">const rows = () => notes.map(note =>\n  &#x3C;li key={note.id}>\n    {note.content}\n  &#x3C;/li>\n)\n</code></pre>\n<p>Kyse on kuitenkin edelleen yhden komennon sisältävästä nuolifunktiosta, komento vain sattuu olemaan hieman monimutkaisempi.</p>\n<h3>Antipattern: taulukon indeksit avaimina</h3>\n<p>Olisimme saaneet konsolissa olevan varoituksen katoamaan myös käyttämällä avaimina taulukon indeksejä. Indeksit selviävät käyttämällä map-metodissa myös toista parametria:</p>\n<pre><code class=\"language-js\">notes.map((note, i) => ...)\n</code></pre>\n<p>näin kutsuttaessa <em>i</em> saa arvokseen sen paikan indeksin taulukossa, missä <em>note</em> sijaitsee.</p>\n<p>Eli eräs virhettä aiheuttamaton tapa määritellä rivien generointi on</p>\n<pre><code class=\"language-js\">const rows = () => notes.map((note, i) => \n  &#x3C;li key={i}>\n    {note.content}\n  &#x3C;/li>\n)\n</code></pre>\n<p>Tämä <strong>ei kuitenkaan ole suositeltavaa</strong> ja voi näennäisestä toimimisestaan aiheuttaa joissakin tilanteissa pahoja ongelmia. Lue lisää esim. <a href=\"https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">täältä</a>.</p>\n<h3>Refaktorointia - moduulit</h3>\n<p>Siistitään koodia hiukan. Koska olemme kiinnostuneita ainoastaan propsien kentästä <em>notes</em>, otetaan se vastaan suoraan <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">destrukturointia</a> hyödyntäen:</p>\n<pre><code class=\"language-js\">const App = ({ notes }) => { // highlight-line\n  // ...\n\n  return (\n    &#x3C;div>\n      &#x3C;h1>Muistiinpanot&#x3C;/h1>\n      &#x3C;ul>\n        {rows()}\n      &#x3C;/ul>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Erotetaan yksittäisen muistiinpanon esittäminen oman komponenttinsa <em>Note</em> vastuulle:</p>\n<pre><code class=\"language-js\">// highlight-start\nconst Note = ({ note }) => {\n  return (\n    &#x3C;li>{note.content}&#x3C;/li>\n  )\n}\n// highlight-end\n\nconst App = ({ notes }) => {\n  const rows = () => notes.map(note =>\n  // highlight-start\n    &#x3C;Note \n      key={note.id}\n      note={note}\n    />\n    // highlight-end\n  )\n\n  return (\n    &#x3C;div>\n      &#x3C;h1>Muistiinpanot&#x3C;/h1>\n      &#x3C;ul>\n        {rows()}\n      &#x3C;/ul>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Huomaa, että <em>key</em>-attribuutti täytyy nyt määritellä <em>Note</em>-komponenteille, eikä <em>li</em>-tageille kuten ennen muutosta.</p>\n<p>Koko React-sovellus on mahdollista määritellä samassa tiedostossa, mutta se ei luonnollisesti ole järkevää. Usein käytäntönä on määritellä yksittäiset komponentit omassa tiedostossaan <em>ES6-moduuleina</em>.</p>\n<p>Koodissamme on käytetty koko ajan moduuleja. Tiedoston ensimmäiset rivit</p>\n<pre><code class=\"language-js\">import Reactfrom 'react'\nimport ReactDOM from 'react-dom'\n</code></pre>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">importtaavat</a> eli ottavat käyttöönsä kaksi moduulia. Moduuli <em>react</em> sijoitetaan muuttujaan <em>React</em> ja <em>react-dom</em> muuttujaan <em>ReactDOM</em>. </p>\n<p>Siirretään nyt komponentti <em>Note</em> omaan moduuliinsa.</p>\n<p>Pienissä sovelluksissa komponentit sijoitetaan yleensä <em>src</em>-hakemiston alle sijoitettavaan hakemistoon <em>components</em>. Konventiona on nimetä tiedosto komponentin mukaan. Tehdään nyt sovellukseen hakemisto <em>components</em> ja sinne tiedosto <em>Note.js</em> jonka sisältö on seuraava:</p>\n<pre><code class=\"language-js\">import React from 'react'\n\nconst Note = ({ note }) => {\n  return (\n    &#x3C;li>{note.content}&#x3C;/li>\n  )\n}\n\nexport default Note\n</code></pre>\n<p>Koska kyseessä on React-komponentti, tulee React importata komponentissa.</p>\n<p>Moduulin viimeisenä rivinä <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">eksportataan</a> määritelty komponentti, eli muuttuja <em>Note</em>.</p>\n<p>Nyt komponenttia käyttävä tiedosto <em>index.js</em> voi <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">importata</a> moduulin:</p>\n<pre><code class=\"language-js\">import React from 'react'\nimport ReactDOM from 'react-dom'\nimport Note from './components/Note' // highlight-line\n\nconst App = ({notes}) => {\n  // ...\n}\n</code></pre>\n<p>Moduulin eksporttaama komponentti on nyt käytettävissä muuttujassa <em>Note</em> täysin samalla tavalla kuin aiemmin.</p>\n<p>Huomaa, että itse määriteltyä komponenttia importatessa komponentin sijainti tulee ilmaista <em>suhteessa importtaavaan tiedostoon</em>:</p>\n<pre><code class=\"language-js\">'./components/Note'\n</code></pre>\n<p>Piste alussa viittaa nykyiseen hakemistoon, eli kyseessä on nykyisen hakemiston alihakemisto <em>components</em> ja sen sisällä tiedosto <em>Note.js</em>. Tiedoston päätteen voi jättää pois.</p>\n<p>Koska myös <code>App</code> on komponentti, eristetään sekin omaan moduuliinsa. Koska kyseessä on sovelluksen juurikomponentti, sijoitetaan se suoraan hakemistoon <em>src</em>. Tiedoston sisältö on seuraava:</p>\n<pre><code class=\"language-js\">import React from 'react'\nimport Note from './components/Note'\n\nconst App = ({ notes }) => {\n  const rows = () => notes.map(note =>\n    &#x3C;Note\n      key={note.id}\n      note={note}\n    />\n  )\n\n  return (\n    &#x3C;div>\n      &#x3C;h1>Muistiinpanot&#x3C;/h1>\n      &#x3C;ul>\n        {rows()}\n      &#x3C;/ul>\n    &#x3C;/div>\n  )\n}\n\nexport default App // highlight-line\n</code></pre>\n<p>Tiedoston <em>index.js</em> sisällöksi jää:</p>\n<pre><code class=\"language-js\">import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'  // highlight-line\n\nconst notes = [\n  // ...\n]\n\nReactDOM.render(\n  &#x3C;App notes={notes} />,\n  document.getElementById('root')\n)\n</code></pre>\n<p>Moduuleilla on paljon muutakin käyttöä kuin mahdollistaa komponenttien määritteleminen omissa tiedostoissaan, palaamme moduuleihin tarkemmin myöhemmin kurssilla.</p>\n<p>Sovelluksen tämänhetkinen koodi on kokonaisuudessaan <a href=\"https://github.com/fullstack-hy2019/part2-notes/tree/part2-1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">githubissa</a></p>\n<p>Huomaa, että repositorion master-haarassa on myöhemmän vaiheen koodi, tämän hetken koodi on branchissa <a href=\"https://github.com/fullstack-hy2019/part2-notes/tree/part2-1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">part2-1</a>:</p>\n<p><img src=\"../images/2/2b.png\"></p>\n<p>Jos kloonaat projektin itsellesi, suorita komento <em>npm install</em> ennen käynnistämistä eli komentoa <em>npm start</em>.</p>\n<h3>Kun sovellus hajoaa...</h3>\n<p>Kun aloitat ohjelmoijan uraasi (ja allekirjoittaneella yhä edelleen 30 vuoden ohjelmointikokemuksella) melko usein käy niin ett ohjelma hajoaa aivan totaalisesti. Erityisen usien näin käy dynaamisesti tyypitetyillä kielillä kuten Javascript, missä kääntäjä ei tarkasta minkä tyyppisiä arvoja esim. funktioden parametreina ja paluuarvoina liikkuu.</p>\n<p>Reactissa räjähdys näyttää esim. seuraavalta</p>\n<p><img src=\"../images/2/3b.png\"></p>\n<p>Tilanteista pelastaa yleensä parhaiten <code>console.log</code>. Pala räjähdyksen aiheuttavaa koodia seuraavassa</p>\n<pre><code class=\"language-js\">const Course = ({ course }) => (\n  &#x3C;div>\n   &#x3C;Header course={course} />\n  &#x3C;/div>\n)\n\nconst App = () => {\n  const course = {\n    // ...\n  }\n\n  return (\n    &#x3C;div>\n      &#x3C;Course course={course} />\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Syy toimimattomuuteen alkaa selvitä lisäilemällä <code>console.log</code>-komentoja. Koska ensimmäinen renderöitävä asia on komponentti <code>App</code> voi jos sinne laittaa ensimmäisen tulostuksen. </p>\n<pre><code class=\"language-js\">const App = () => {\n  const course = {\n    // ...\n  }\n\n  console.log('App toimii...') // highlight-line\n\n  return (\n    // ..\n  )\n}\n</code></pre>\n<p>Konsoliin tulevan tulostuksen nähdäkseen on skrollattava pitkän punaisen virhematon yläpuolelle</p>\n<p><img src=\"../images/2/4b.png\"></p>\n<p>Kun joku asia havaitaan toimivaksi, on aika logata syvemmältä. Jos komponentti on määritelty yksilausekkeista, eli returnitonta funktiota, on konsoliin tulostus haastavampaa:</p>\n<pre><code class=\"language-js\">const Course = ({ course }) => (\n  &#x3C;div>\n   &#x3C;Header course={course} />\n  &#x3C;/div>\n)\n</code></pre>\n<p>komponentti on syytä muuttaa pidemmän kaavan mukaan määritellyksi:</p>\n<pre><code class=\"language-js\">const Course = ({ course }) => { \n  console.log(course)\n  return (\n    &#x3C;div>\n    &#x3C;Header course={course} />\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Erittäin usein ongelma on siitä että propsien odotetaan olevan eri muodossa kuin ne todellisuudessa ovat ja destrukturointi epäonnistuu. Ongelma alkaa useimmiten ratketa kun poistetaan destrukturointi ja katsotaan mitä <code>props</code> oikeasti pitää sisällään:</p>\n<pre><code class=\"language-js\">const Course = (props) => { // highlight-line\n  console.log(props)  // highlight-line\n  const { course } = props\n  return (\n    &#x3C;div>\n    &#x3C;Header course={course} />\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Ja jos ongelma ei vieläkään selviä, ei auta kuin jatkaa vianjäljitystä, eli kirjoittaa lisää console.logeja.</p>\n<p>Lisäsin tämän luvun materiaaliin kun seuraavan tehtävän mallivastauksen koodi räjähti ihan totaalisesti (syynä väärässä muodossa ollut propsi) ja jouduin jälleen kerran debuggaamaan console.logaamalla.</p>\n</div>\n<div class=\"tasks\">\n<h3>Tehtäviä</h3>\n<h4>2.1: kurssien sisältö</h4>\n<p>Viimeistellään nyt tehtävien 1.1-1.5 kurssin sisältöjä renderöivän ohjelman koodi. Voit ottaa tarvittaessa pohjaksi mallivastauksen koodin.</p>\n<p><strong>Huomaa, että jos kopioit projektin paikasta toiseen, saattaa olla tarpeen ensin tuhota hakemisto <em>node_modules</em> ja antaa sen jälkeen asentaa riippuvuudet uudelleen, eli komento <em>npm install</em> ennen kuin saat kopioidun projektin käynnistettyä.</strong> Lähtökohtaisesti toki kannattaa olla kokonaan kopioimatta tai laittamatta versionhallintaan hakemistoa <em>node_modules</em>.</p>\n<p>Muutetaan komponenttia <code>App</code> seuraavasti:</p>\n<pre><code class=\"language-js\">const App = () => {\n  const course = {\n    name: 'Half Stack -sovelluskehitys',\n    parts: [\n      {\n        name: 'Reactin perusteet',\n        exercises: 10,\n        id: 1\n      },\n      {\n        name: 'Tiedonvälitys propseilla',\n        exercises: 7,\n        id: 2\n      },\n      {\n        name: 'Komponenttien tila',\n        exercises: 14,\n        id: 3\n      }\n    ]\n  }\n\n  return (\n    &#x3C;div>\n      &#x3C;Course course={course} />\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Määrittele sovellukseen yksittäisen kurssin muotoilusta huolehtiva komponentti <em>Course</em>.</p>\n<p>Sovelluksen komponenttirakenne voi olla esim. seuraava:</p>\n<pre>\nApp\n  Course\n    Header\n    Content\n      Part\n      Part\n      ...\n</pre>\n<p>Eli komponentti <em>Course</em> sisältää edellisessä osassa määritellyt komponentit, joiden vastuulle tulee kurssin nimen ja osien renderöinti.</p>\n<p>Renderöityvä sivu voi näyttää esim. seuraavalta:</p>\n<p><img src=\"../images/teht/8.png\"></p>\n<p>Tässä vaiheessa siis tehtävien yhteenlaskettua lukumäärää ei vielä tarvita.</p>\n<p>Sovelluksen täytyy luonnollisesti toimia <em>riippumatta kurssissa olevien osien määrästä</em>, eli varmista että sovellus toimii jos lisäät tai poistat kurssin osia.</p>\n<p>Varmista, että konsolissa ei näy mitään virheilmoituksia!</p>\n<h4>2.2: tehtävien määrä</h4>\n<p>Ilmoita myös kurssin yhteenlaskettu tehtävien lukumäärä:</p>\n<p><img src=\"../images/teht/9.png\"></p>\n<h4>2.3*: reduce</h4>\n<p>Jos et jo niin tehnyt, laske koodissasi tehtävien määrä taulukon metodilla <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">reduce</a>.</p>\n<p><strong>Pro tip:</strong> Kun koodisi joka näyttää esimerkisi seuraavalta </p>\n<pre><code class=\"language-js\">const total = parts.reduce( (s, p) => someMagicHere )\n</code></pre>\n<p>ei toimi, kannattaa taas kerran turvautua komentoon <em>console.log</em>, joka jälleen vaatii sen, että nuolifunktio muutetaan pidempään muotoonsa</p>\n<pre><code class=\"language-js\">const total = parts.reduce( (s, p) => {\n  console.log('what is happening', s, p)\n  return someMagicHere \n})\n</code></pre>\n<p><strong>Pro tip2:</strong> VS codeen on asennettavissa laajennus, ilmeisesti <a href=\"https://marketplace.visualstudio.com/items?itemName=cmstead.jsrefactor\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">tämä</a>, jonka avulla nuolifunktion lyhyen muodon voi muuttaa automaattisesti pidemmäksi muodoksi ja päinvastoin:</p>\n<p><img src=\"../images/2/5b.png\"></p>\n<h4>2.4: monta kurssia</h4>\n<p>Laajennetaan sovellusta siten, että kursseja voi olla <em>mielivaltainen määrä</em>:</p>\n<pre><code class=\"language-js\">const App = () => {\n  const courses = [\n    {\n      name: 'Half Stack -sovelluskehitys',\n      id: 1,\n      parts: [\n        {\n          name: 'Reactin perusteet',\n          exercises: 10,\n          id: 1\n        },\n        {\n          name: 'Tiedonvälitys propseilla',\n          exercises: 7,\n          id: 2\n        },\n        {\n          name: 'Komponenttien tila',\n          exercises: 14,\n          id: 3\n        }\n      ]\n    },\n    {\n      name: 'Node.js',\n      id: 2,\n      parts: [\n        {\n          name: 'Routing',\n          exercises: 2,\n          id: 1\n        },\n        {\n          name: 'Middlewaret',\n          exercises: 7,\n          id: 2\n        }\n      ]\n    }\n  ]\n\n  return (\n    &#x3C;div>\n      // ...\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Sovelluksen ulkoasu voi olla esim seuraava:</p>\n<p><img src=\"../images/teht/10.png\"></p>\n<h4>2.5: erillinen moduuli</h4>\n<p>Määrittele komponentti <em>Course</em> omana moduulinaan, jonka komponentti <code>App</code> importtaa. Voit sisällyttää kaikki kurssin alikomponentit samaan moduuliin.</p>\n</div>","frontmatter":{"mainImage":{"publicURL":"/static/part-2-2c709798e38da8a809241016507d8154.svg"},"part":2,"letter":"a"}}},"pageContext":{"part":2,"letter":"a"}}