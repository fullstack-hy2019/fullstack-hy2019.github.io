{"data":{"markdownRemark":{"html":"<div class=\"content\">\n<p>Kurssin aikana on websovelluskehityksen rinnalla tavoite ja tarve oppia riittävässä määrin Javascriptiä.</p>\n<p>Javascript on kehittynyt viime vuosina nopeaan tahtiin, ja käytämme kurssilla kielen uusimpien versioiden piirteitä. Javascript-standardin virallinen nimi on <a href=\"https://en.wikipedia.org/wiki/ECMAScript\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ECMAScript</a>. Tämän hetken tuorein versio on kesäkuussa 2017 julkaistu <a href=\"https://www.ecma-international.org/ecma-262/9.0/index.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ES9</a>, toiselta nimeltään ECMAScript 2018.</p>\n<p>Selaimet eivät vielä osaa kaikkia Javascriptin uusimpien versioiden ominaisuuksia. Tämän takia selaimessa suoritetaan useimmiten koodia joka on käännetty (englanniksi <i>transpiled</i>) uudemmasta Javascriptin versiosta johonkin vanhempaan, laajemmin tuettuun versioon.</p>\n<p>Tällä hetkellä johtava tapa tehdä transpilointi on <a href=\"https://babeljs.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Babel</a>. Create-react-app:in avulla luoduissa React-sovelluksissa on valmiiksi konfiguroitu automaattinen transpilaus. Katsomme kurssin <a href=\"/osa7\">osassa 7</a> tarkemmin miten transpiloinnin konfigurointi tapahtuu.</p>\n<p><a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Node.js</a> on melkein missä vaan, mm. palvelimilla toimiva, Googlen <a href=\"https://developers.google.com/v8/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">chrome V8</a>-javascriptmoottoriin perustuva Javascript-suoritusympäristö. Harjoitellaan hieman Javascriptiä Nodella. Tässä oletetaan, että koneellasi on Node.js:stä vähintään versio <i>v8.10.0</i>. Noden tuoreet versiot osaavat suoraan Javascriptin uusia versioita, joten koodin transpilaus ei ole tarpeen.</p>\n<p>Koodi kirjoitetaan <i>.js</i>-päätteiseen tiedostoon, ja suoritetaan komennolla <em>node tiedosto.js</em></p>\n<p>Koodia on mahdollisuus kirjoittaa myös Node.js-konsoliin, joka aukeaa kun kirjoitat komentorivillä <em>node</em> tai myös selaimen developer toolin konsoliin. Chromen uusimmat versiot osaavat suoraan transpiloimatta <a href=\"http://kangax.github.io/compat-table/es2016plus/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">melko hyvin</a> Javascriptin uusiakin piirteitä.</p>\n<p>Javascript muistuttaa nimensä ja syntaksinsa puolesta läheisesti Javaa. Perusmekanismeiltaan kielet kuitenkin poikkeavat radikaalisti. Java-taustalta tultaessa Javascriptin käyttäytyminen saattaa aiheuttaa hämmennystä, varsinkin jos kielen piirteistä ei viitsitä ottaa selvää.</p>\n<p>Tietyissä piireissä on myös ollut suosittua yrittää \"simuloida\" Javascriptilla eräitä Javan piirteitä ja ohjelmointitapoja. En suosittele.</p>\n<h3>Muuttujat</h3>\n<p>Javascriptissä on muutama tapa määritellä muuttujia:</p>\n<pre><code class=\"language-js\">const x = 1\nlet y = 5\n\nconsole.log(x, y)   // tulostuu 1, 5\ny += 10\nconsole.log(x, y)   // tulostuu 1, 15\ny = 'teksti'\nconsole.log(x, y)   // tulostuu 1, teksti\nx = 4               // aiheuttaa virheen\n</code></pre>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">const</a> ei oikeastaan määrittele muuttujaa vaan <i>vakion</i>, jonka arvoa ei voi enää muuttaa. <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">let</a> taas määrittelee normaalin muuttujan.</p>\n<p>Esimerkistä näemme myös, että muuttujan tallettaman tiedon tyyppi voi vaihtaa tyyppiä suorituksen aikana, <em>y</em> tallettaa aluksi luvun ja lopulta merkkijonon.</p>\n<p>Javascriptissa on myös mahdollista määritellä muuttujia avainsanan <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">var</a> avulla. Var oli pitkään ainoa tapa muuttujien määrittelyyn, const ja let tulivat kieleen mukaan vasta versiossa ES6. Var toimii tietyissä tilanteissa <a href=\"https://medium.com/craft-academy/javascript-variables-should-you-use-let-var-or-const-394f7645c88f\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">eri</a> <a href=\"http://www.jstips.co/en/javascript/keyword-var-vs-let/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">tavalla</a> kuin useimpien muiden kielien muuttujien määrittely. Tällä kurssilla varin käyttö ei ole suositeltavaa eli käytä aina const:ia tai let:iä!</p>\n<p>Lisää aiheesta esim. youtubessa <a href=\"https://youtu.be/sjyJBL5fkp8\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">var, let and const - ES6 JavaScript Features</a></p>\n<h3>Taulukot</h3>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Taulukko</a> ja muutama esimerkki sen käytöstä</p>\n<pre><code class=\"language-js\">const t = [1, -1, 3]\n\nt.push(5)\n\nconsole.log(t.length) // tulostuu 4\nconsole.log(t[1])     // tulostuu -1\n\nt.forEach(value => {\n  console.log(value)  // tulostuu 1, -1, 3, 5 omille riveilleen\n})                    \n</code></pre>\n<p>Huomattavaa esimerkissä on se, että taulukon sisältöä voi muuttaa vaikka sen on määritelty <em>const</em>:ksi. Koska taulukko on olio, viittaa muuttuja koko ajan samaan olioon. Olion sisältö muuttuu sitä mukaa kuin taulukkoon lisätään uusia alkioita.</p>\n<p>Eräs tapa käydä taulukon alkiot läpi on esimerkissä käytetty <em>forEach</em>, joka saa parametrikseen nuolisyntaksilla määritellyn <i>funktion</i></p>\n<pre><code class=\"language-js\">value => {\n  console.log(value)\n}\n</code></pre>\n<p>forEach kutsuu funktiota <i>jokaiselle taulukon alkiolle</i> antaen taulukon yksittäisen alkion aina parametrina. forEachin parametrina oleva funktio voi saada myös <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">muita parametreja</a>.</p>\n<p>Edellisessä esimerkissä taulukkoon lisättiin uusi alkio metodilla <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">push</a>. Reactin yhteydessä sovelletaan usein funktionaalisen ohjelmoinnin tekniikoita, jonka eräs piirre on käyttää <i>muuttumattomia</i> (engl. <a href=\"https://en.wikipedia.org/wiki/Immutable_object\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">immutable</a>) tietorakenteita. React-koodissa kannattaakin mielummin käyttää metodia <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">concat</a>, joka ei lisää alkiota taulukkoon vaan luo uuden taulukon, jossa on lisättävä alkio sekä vanhan taulukon sisältö:</p>\n<pre><code class=\"language-js\">const t = [1, -1, 3]\n\nconst t2 = t.concat(5)\n\nconsole.log(t)  // tulostuu [1, -1, 3]\nconsole.log(t2) // tulostuu [1, -1, 3, 5]\n</code></pre>\n<p>Metodikutsu <em>t.concat(5)</em> ei siis lisää uutta alkiota vanhaan taulukkoon, vaan palauttaa uuden taulukon, joka sisältää vanhan taulukon alkioiden lisäksi uuden alkion.</p>\n<p>Taulukoille on määritelty runsaasti hyödyllisiä operaatioita. Katsotaan pieni esimerkki metodin <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">map</a> käytöstä.</p>\n<pre><code class=\"language-js\">const t = [1, 2, 3]\n\nconst m1 = t.map(value => value * 2)\nconsole.log(m1)   // tulostuu [2, 4, 6]\n</code></pre>\n<p>Map muodostaa taulukon perusteella <i>uuden taulukon</i>, jonka jokainen alkio luodaan map:in parametrina olevan funktion avulla, esimerkin tapauksessa kertomalla alkuperäinen luku kahdella.</p>\n<p>Map voi muuttaa taulukon myös täysin erilaiseen muotoon:</p>\n<pre><code class=\"language-js\">const m2 = t.map(value => '&#x3C;li>' + value + '&#x3C;/li>')\nconsole.log(m2)  \n// tulostuu [ '&#x3C;li>1&#x3C;/li>', '&#x3C;li>2&#x3C;/li>', '&#x3C;li>3&#x3C;/li>' ]\n</code></pre>\n<p>Eli lukuja sisältävästä taulukosta tehdään map-metodin avulla HTML-koodia sisältävä taulukko. Tulemmekin kurssin <a href=\"/osa2\">osassa2</a> näkemään että mapia käytetään Reactissa todella usein.</p>\n<p>Taulukon yksittäisiä alkioita on helppo sijoittaa muuttujiin <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">destrukturoivan</a> sijoituslauseen avulla:</p>\n<pre><code class=\"language-js\">const t = [1, 2, 3, 4, 5]\n\nconst [first, second, ...rest] = t\n\nconsole.log(first, second)  // tulostuu 1, 2\nconsole.log(rest)           // tulostuu [3, 4 ,5]\n</code></pre>\n<p>Eli muuttujiin <em>first</em> ja <em>second</em> tulee sijoituksen ansiosta taulukon kaksi ensimmäistä lukua. Muuttujaan <em>rest</em> \"kerätään\" sijoituksesta jäljellejääneet luvut omaksi taulukoksi.</p>\n<h3>Oliot</h3>\n<p>Javasriptissa on muutama tapa määritellä olioita. Erittäin yleisesti käytetään <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Object_literals\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">olioliteraaleja</a>, eli määritellään olio luettelemalla sen kentät (englanniksi property) aaltosulkeiden sisällä:</p>\n<pre><code class=\"language-js\">const object1 = {\n  name: 'Arto Hellas',\n  age: 35,\n  education: 'Filosofian tohtori',\n}\n\nconst object12 = {\n  name: 'Full Stack -websovelluskehitys',\n  level: 'aineopinto',\n  size: 5,\n}\n\nconst object3 = {\n  name: {\n    first: 'Juha',\n    last: 'Tauriainen',\n  },\n  grades: [2, 3, 5, 3],\n  department: 'TKTL',\n}\n</code></pre>\n<p>Kenttien arvot voivat olla tyypiltään mitä vaan, lukuja, merkkijonoja, taulukoita, olioita...</p>\n<p>Olioiden kenttiin viitataan pistenotaatioll, tai hakasulkeilla:</p>\n<pre><code class=\"language-js\">console.log(object1.name)         // tulostuu Arto Hellas\nconst fieldName = 'age' \nconsole.log(object1[fieldName])   // tulostuu 35\n</code></pre>\n<p>Olioille voidaan lisätä kenttiä myös lennossa joko pistenotaation tai hakasulkeiden avulla:</p>\n<pre><code class=\"language-js\">object1.address = 'Tapiola'\nobject1['secred number'] = 12341\n</code></pre>\n<p>Jälkimmäinen lisäyksistä on pakko tehdä hakasulkeiden avulla, sillä pistenotaatiota käytettäessä <i>secred number</i> ei kelpaa kentän nimeksi.</p>\n<p>Javascriptissä olioilla voi luonnollisesti olla myös metodeja. Emme kuitenkaan tarvitse tällä kurssilla ollenkaan itse määriteltyjä metodillisia olioita, joten asiaa ei tällä kurssilla käsitellä kuin lyhyesti.</p>\n<p>Olioita on myös mahdollista määritellä ns. konstruktorifunktioiden avulla, jolloin saadaan aikaan hieman monien ohjelmointikielten, esim. Javan luokkia (class) muistuttava mekanismi. Javascriptissä ei kuitenkaan ole luokkia samassa mielessä kuin olio-ohjelmointikielissä. Kieleen on kuitenkin lisätty versiosta ES6 alkaen <i>luokkasyntaksi</i>, joka helpottaa tietyissä tilanteissa olio-ohjelmointikielimäisten luokkien esittämistä.</p>\n<h3>Funktiot</h3>\n<p>Olemme jo tutustuneet ns. nuolifunktioiden määrittelyyn. Täydellinen eli \"pitkän kaavan\" mukaan menevä tapa nuolifunktion määrittelyyn on seuraava</p>\n<pre><code class=\"language-js\">const sum = (p1, p2) => {\n  console.log(p1)\n  console.log(p2)\n  return p1 + p2\n}\n</code></pre>\n<p>ja funktiota kutsutaan kuten olettaa saattaa</p>\n<pre><code class=\"language-js\">const result = sum(1, 5)\nconsole.log(result)\n</code></pre>\n<p>Jos parameteja on vain yksi, voidaan sulut jättää määrittelystä pois:</p>\n<pre><code class=\"language-js\">const square = p => {\n  console.log(p)\n  return p * p\n}\n</code></pre>\n<p>Jos funktio sisältää ainoastaan yhden lausekkeen, ei aaltosulkeita tarvita. Tällöin funktio palauttaa ainoan lausekkeensa arvon. Eli jos poistetaan konsoliin tulostus, voidaan edellinen sunktio ilmaista lyhyemmin seuraavasti:</p>\n<pre><code class=\"language-js\">const square = p => p * p\n</code></pre>\n<p>Tämä muoto on erityisen kätevä käsiteltäessä taulukkoja esim. map-metodin avulla:</p>\n<pre><code class=\"language-js\">const t = [1, 2, 3]\nconst tSquared = t.map(p => p * p)\n// tSquared on nyt [1, 4, 9]\n</code></pre>\n<p>Nuolifunktio on tullut Javascriptiin vasta muutama vuosi sitten version <a href=\"http://es6-features.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ES6</a> myötä. Tätä ennen ainoa tapa funktioiden määrittelyyn oli avainsanan <em>function</em> käyttö.</p>\n<p>Määrittelytapoja on kaksi, funktiolle voidaan antaa <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">function declaration</a> -tyyppisessä määrittelyssä <i>nimi</i>, jonka avulla funktioon voidaan viitata:</p>\n<pre><code class=\"language-js\">function product(a, b) {\n  return a * b\n}\n\nconst vastaus = product(2, 6)\n</code></pre>\n<p>Toinen tapa on tehdä määrittely <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">funktiolausekkeena</a>. Tällöin funktiolle ei tarvitse antaa nimeä ja määrittely voi sijaita muun koodin seassa:</p>\n<pre><code class=\"language-js\">const average = function(a, b) {\n  return (a + b) / 2\n}\n\nconst vastaus = average(2, 5)\n</code></pre>\n<p>Määrittelemme tällä kurssilla kaikki funktiot nuolisyntaksin avulla.</p>\n</div>\n<div class=\"tasks\">\n  <h3>Tehtäviä</h3>\n<p><i>Jatkamme edellisissä tehtävissä aloitetun ohjelman rakentamista, voit siis tehdä koodin samaan projektiin, palautuksessa ollaan kiinnostuneita ainoastaan ohjelman lopullisesta versiosta.</i></p>\n<p><strong>Protip:</strong> voit kohdata ohjelmoidessasi ongelmiasen suhteen missä muodossa komponentin saamat <i>propsit</i> ovat. Hyvä keino varmistua asiasta on tulostaa propsit konsoliin, esim. seuraavasti:</p>\n<pre><code class=\"language-js\">const Header = (props) => {\n  console.log(props) // highlight-line\n  return &#x3C;h1>{props.course}&#x3C;/h1>\n}\n</code></pre>\n  <h4>1.3: tieto olioissa</h4>\n<p>Siirrytään käyttämään sovelluksessamme oliota. Muuta komponentin <i>App</i> muuttujamäärittelyt seuraavaan muotoon ja muuta sovelluksen kaikkia osia niin, että se taas toimii:</p>\n<pre><code class=\"language-js\">const App = () => {\n  const course = 'Half Stack -sovelluskehitys'\n  const part1 = {\n    name: 'Reactin perusteet',\n    exercises: 10\n  }\n  const part2 = {\n    name: 'Tiedonvälitys propseilla',\n    exercises: 7\n  }\n  const part3 = {\n    name: 'Komponenttien tila',\n    exercises: 14\n  }\n\n  return (\n    &#x3C;div>\n      ...\n    &#x3C;/div>\n  )\n}\n</code></pre>\n  <h4>1.4: oliot taulukkoon</h4>\n<p>Ja laitetaan oliot taulukkoon, eli muuta  <i>App</i> :in muuttujamäärittelyt seuraavaan muotoon ja muuta sovelluksen kaikki osat vastaavasti:</p>\n<pre><code class=\"language-js\">const App = () => {\n  const course = {\n    name: 'Half Stack -sovelluskehitys',\n    parts: [\n      {\n        name: 'Reactin perusteet',\n        exercises: 10\n      },\n      {\n        name: 'Tiedonvälitys propseilla',\n        exercises: 7\n      },\n      {\n        name: 'Komponenttien tila',\n        exercises: 14\n      }\n    ]\n  }\n\n  return (\n    &#x3C;div>\n      ...\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p><strong>HUOM:</strong> tässä vaiheessa <i>voit olettaa, että taulukossa on aina kolme alkiota</i>, eli taulukkoa ei ole pakko käydä läpi looppaamalla. Palataan taulukossa olevien olioiden perusteella tapahtuvaan komponenttien renderöintiin asiaan tarkemmin kurssin <a href=\"../osa2\">seuraavassa osassa</a>.</p>\n<p>Älä kuitenkaan välitä eri olioita komponentista <i>App</i> sen sisältämiin komponentteihin <i>Content</i> ja <i>Total</i> erillisinä propseina, vaan suoraan taulukkona:</p>\n<pre><code class=\"language-js\">const App = () => {\n  // const-määrittelyt\n\n  return (\n    &#x3C;div>\n      &#x3C;Header course={...} />\n      &#x3C;Content parts={parts} />\n      &#x3C;Total parts={parts} />\n    &#x3C;/div>\n  )\n}\n</code></pre>\n  <h4>1.5: jako komponenteiksi</h4>\n<p>Viedään muutos vielä yhtä askelta pidemmälle, eli tehdään kurssista ja sen osista yksi Javascript-olio. Korjaa kaikki mikä menee rikki.</p>\n<pre><code class=\"language-js\">const App = () => {\n  const course = {\n    name: 'Half Stack -sovelluskehitys',\n    parts: [\n      {\n        name: 'Reactin perusteet',\n        exercises: 10\n      },\n      {\n        name: 'Tiedonvälitys propseilla',\n        exercises: 7\n      },\n      {\n        name: 'Komponenttien tila',\n        exercises: 14\n      }\n    ]\n  }\n\n  return (\n    &#x3C;div>\n      ...\n    &#x3C;/div>\n  )\n}\n</code></pre>\n</div>\n<div class=\"content\">\n<h3>Olioiden metodit ja this</h3>\n<p>Koska käytämme tällä kurssilla Reactin hookit sisältävää versiota, meidän ei kurssin aikana tarvitse määritellä ollenkaan olioita, joilla on metodeja. <strong>Tämän luvun asiat siis eivät ole kurssin kannalta relevantteja</strong>, mutta varmasti monella tapaa hyödyllisiä tietää. Käytettäessä \"vanhempaa Reactia\", tämän luvun asiat on hallittava.</p>\n<p>Nuolifunktiot ja avainsanan <em>function</em> avulla määritellyt funktiot poikkeavat radikaalisti siitä miten ne käyttäytyvät olioon itseensä viittaavan avainsanan <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">this</a> suhteen.</p>\n<p>Voimme liittää oliolle metodeja määrittelemällä niille kenttiä, jotka ovat funktioita:</p>\n<pre><code class=\"language-js\">const arto = {\n  name: 'Arto Hellas',\n  age: 35,\n  education: 'Filosofian tohtori',\n  greet: function() {\n    console.log('hello, my name is', this.name)\n  },\n}\n\narto.greet()  // tulostuu hello, my name is Arto Hellas\n</code></pre>\n<p>metodeja voidaan liittää olioille myös niiden luomisen jälkeen:</p>\n<pre><code class=\"language-js\">const arto = {\n  name: 'Arto Hellas',\n  age: 35,\n  education: 'Filosofian tohtori',\n  greet: function() {\n    console.log('hello, my name is', this.name)\n  },\n}\n\n// highlight-start\narto.growOlder = function() {\n  this.age += 1\n}\n// highlight-end\n\nconsole.log(arto.age)   // tulostuu 35\narto.growOlder()\nconsole.log(arto.age)   // tulostuu 36\n</code></pre>\n<p>Muutetaan olioa hiukan</p>\n<pre><code class=\"language-js\">const arto = {\n  name: 'Arto Hellas',\n  age: 35,\n  education: 'Filosofian tohtori',\n  greet: function() {\n    console.log('hello, my name is', this.name)\n  },\n  // highlight-start\n  doAddition: function(a, b) {\n    console.log(a + b)\n  },\n  // highlight-end\n}\n\narto.doAddition(1, 4) // tulostuu 5\n\nconst referenceToAdditon = arto.doAddition\nreferenceToAdditon(10, 15) // tulostuu 25\n</code></pre>\n<p>Oliolla on nyt metodi <em>doAddition</em>, joka osaa laskea parametrina annettujen lukujen summan. Metodia voidaan kutsua normaaliin tapaan olion kautta <em>arto.doAddition(1, 4)</em> tai tallettamalla <i>metodiviite</i> muuttujaan ja kutsumalla metodia muuttujan kautta <em>referenceToAdditon(10, 15)</em>.</p>\n<p>Jos yritämme samaa metodille <em>greet</em>, aiheutuu ongelmia:</p>\n<pre><code class=\"language-js\">arto.greet()       // tulostuu hello, my name is Arto Hellas\n\nconst referenceToGreet = arto.referenceToGreet\nreferenceToGreet() // tulostuu hello, my name is undefined\n</code></pre>\n<p>Kutsuttaessa metodia viitteen kautta, on metodi kadottanut tiedon siitä mikä oli alkuperäinen <em>this</em>. Toisin kuin melkein kaikissa muissa kielissä, Javascriptissa <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">this</a>:n arvo määrittyy sen mukaan <i>miten metodia on kutsuttu</i>. Kutsuttaessa metodia viitteen kautta, <em>this</em>:in arvoksi tulee ns. <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Global_object\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">globaali objekti</a> ja lopputulos ei ole yleensä ollenkaan se, mitä sovelluskehittäjä olettaa.</p>\n<p>This:in kadottaminen aiheuttaa Javascriptillä ohjelmoidessa monia potentiaalisia ongelmia. Eteen tulee erittäin usein tilanteita, missä Reactin/Noden (oikeammin ilmaistuna selaimen Javascript-moottorin) tulee kutsua joitain ohjelmoijan määrittelemien olioiden metodeja. Tällä kurssilla kuitenkin säästymme näiltä ongelmilta, sillä käytämme ainoastaan \"thissitöntä\" Javascriptia.</p>\n<p>Eräs this:in katoamiseen johtava tilanne tulee esim. jos pyydetään Artoa tervehtimään sekunnin kuluttua metodia <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">setTimeout</a> hyväksikäyttäen.</p>\n<pre><code class=\"language-js\">const arto = {\n  name: 'Arto Hellas',\n  greet: function() {\n    console.log('hello, my name is', this.name)\n  },\n}\n\nsetTimeout(arto.greet, 1000)  // highlight-line\n</code></pre>\n<p>Javascriptissa this:in arvo siis määräytyy siitä miten metodia on kutsuttu. setTimeoutia käytettäessä metodia kutsuu Javascript-moottori ja this viittaa Timeout-olioon.</p>\n<p>On useita mekanismeja, joiden avulla alkuperäinen <em>this</em> voidaan säilyttää, eräs näistä on metodin <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">bind</a> käyttö:</p>\n<pre><code class=\"language-js\">setTimeout(arto.greet.bind(arto), 1000)\n</code></pre>\n<p>Komento <em>arto.greet.bind(arto)</em> luo uuden funktion, missä se on sitonut <em>this</em>:in tarkoittamaan Artoa riippumatta siitä missä ja miten metodia kutsutaan.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Nuolifunktioiden</a> avulla on mahdollista ratkaista eräitä this:iin liittyviä ongelmia. Olioiden metodeina niitä ei kuitenkaan kannata käyttää, sillä silloin <em>this</em> ei toimi ollenkaan. Palaamme nuolifunktioiden this:in käyttäytymiseen myöhemmin.</p>\n<p>Jos haluat ymmärtää paremmin javascriptin <em>this</em>:in toimintaa, löytyy internetistä runsaasti materiaalia aiheesta. Esim. <a href=\"https://egghead.io\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">egghead.io</a>:n 20 minuutin screencastsarja <a href=\"https://egghead.io/courses/understand-javascript-s-this-keyword-in-depth\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Understand JavaScript's this Keyword in Depth</a> on erittäin suositeltava!</p>\n<h3>Luokat</h3>\n<p>Kuten aiemmin mainittiin, Javascriptissä ei ole olemassa olio-ohjelmointikielten luokkamekanismia. Javascriptissa on kuitenkin ominaisuuksia, jotka mahdollistavat olio-ohjelmoinnin <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">luokkien</a> \"simuloinnin\". Emme mene nyt sen tarkemmin Javascriptin olioiden taustalla olevaan <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">prototyyppiperintämekanismiin</a>.</p>\n<p>Tutusttutaan nyt pikaisesti ES6:n myötä Javascriptiin tulleeseen <i>luokkasyntaksiin</i>, joka helpottaa oleellisesti luokkien (tai luokan kaltaisten asioiden) määrittelyä Javascriptissa.</p>\n<p>Seuraavassa on määritelty \"luokka\" Person ja sille kaksi Person-oliota:</p>\n<pre><code class=\"language-js\">class Person {\n  constructor(name, age) {\n    this.name = name\n    this.age = age\n  }\n  greet() {\n    console.log('hello, my name is', this.name)\n  }\n}\n\nconst arto = new Person('Arto Hellas', 35)\narto.greet()\n\nconst juhq = new Person('Juha Tauriainen', 48)\njuhq.greet()\n</code></pre>\n<p>Syntaksin osalta luokat ja niistä luodut oliot muistuttavat erittäin paljon esim. Javan luokkia ja olioita. Käyttäytymiseltäänkin ne ovat aika lähellä Javan olioita. Perimmiltään kyseessä on kuitenkin edelleen Javascriptin <a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">prototyyppiperintään</a> perustuvista olioista. Molempien olioiden todellinen tyyppi on <em>Object</em> sillä Javascriptissä ei perimmiltään ole muita tyyppejä kuin <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Boolean, Null, Undefined, Number, String, Symbol ja Object</a></p>\n<p>Luokkasyntaksin tuominen Javascriptiin on osin kiistelty lisäys, ks. esim. <a href=\"https://github.com/joshburgess/not-awesome-es6-classes\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Not Awesome: ES6 Classes</a> tai <a href=\"https://medium.com/@rajaraodv/is-class-in-es6-the-new-bad-part-6c4e6fe1ee65\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Is “Class” In ES6 The New “Bad” Part?</a></p>\n<p>ES6:n luokkasyntaksia käytetään paljon \"vanhassa\" Reactissa ja Node.js:ssä ja siksi sen tunteminen on tälläkin kurssilla paikallaan. Koska käytämme kurssilla Reactin uutta <a href=\"https://reactjs.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">hook</a>-ominaisuutta, meidän ei ole tarvetta käyttää kurssilla ollenkaan Javascriptin luokkasyntaksia.</p>\n<h3>Javascript-materiaalia</h3>\n<p>Javascriptistä löytyy verkosta suuret määrät sekä hyvää että huonoa materiaalia. Tällä sivulla lähes kaikki Javascriptin ominaisuuksia käsittelevät linkit ovat <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Mozillan Javascript -materiaaliin</a>.</p>\n<p>Mozillan sivuilta kannattaa lukea oikeastaan välittömästi <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">A re-introduction to JavaScript (JS tutorial)</a>.</p>\n<p>Jos haluat tutustua todella syvällisesti Javascriptiin, löytyy internetistä ilmaiseksi mainio kirjasarja <a href=\"https://github.com/getify/You-Dont-Know-JS\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">You-Dont-Know-JS</a>.</p>\n<p><a href=\"https://egghead.io\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">egghead.io</a>:lla on tarjolla runsaasti laadukkaita screencasteja Javascriptista, Reactista ym. kiinnostavasta. Valitettavasti materiaali on osittain maksullista.</p>\n</div>","frontmatter":{"mainImage":{"publicURL":"/static/part-1-4336fcf032b41b5932e500b36479c2b4.svg"},"part":1,"letter":"b"}}},"pageContext":{"part":1,"letter":"b"}}