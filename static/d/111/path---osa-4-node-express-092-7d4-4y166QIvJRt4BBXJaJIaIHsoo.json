{"data":{"markdownRemark":{"html":"<div class=\"content\">\n<h2>Sovelluksen rakenteen parantelu</h2>\n<p>Jatketaan <a href=\"/osa3\">osassa 3</a> tehdyn muistiinpanosovelluksen backendin kehittämistä.</p>\n<p>Muutetaan sovelluksen rakennetta siten, että projektin juuressa oleva <em>index.js</em> ainoastaan konfiguroi sovelluksen tietokannan ja käytettävät middlewaret. Routejen määrittely siirretään omaan tiedostoonsa, eli siitä tehdään <a href=\"/osa3/#tietokantam%C3%A4%C3%A4rittelyjen-eriytt%C3%A4minen-omaksi-moduuliksi\">moduuli</a>.</p>\n<p>Routejen tapahtumankäsittelijöitä kutsutaan usein <em>kontrollereiksi</em>. Luodaankin hakemisto <em>controllers</em> ja sinne tiedosto <em>notes.js</em> johon tulemme siirtämään kaikki muistiinpanoihin liittyvien reittien määrittelyt.</p>\n<p>Tiedoston sisältö on seuraava:</p>\n<pre><code class=\"language-js\">const notesRouter = require('express').Router();\nconst Note = require('../models/note');\n\nconst formatNote = note => {\n  return {\n    id: note._id,\n    content: note.content,\n    date: note.date,\n    important: note.important,\n  };\n};\n\nnotesRouter.get('/', (request, response) => {\n  Note.find({}).then(notes => {\n    response.json(notes.map(formatNote));\n  });\n});\n\nnotesRouter.get('/:id', (request, response) => {\n  Note.findById(request.params.id)\n    .then(note => {\n      if (note) {\n        response.json(formatNote(note));\n      } else {\n        response.status(404).end();\n      }\n    })\n    .catch(error => {\n      response.status(400).send({ error: 'malformatted id' });\n    });\n});\n\nnotesRouter.delete('/:id', (request, response) => {\n  Note.findByIdAndRemove(request.params.id)\n    .then(result => {\n      console.log(result);\n      response.status(204).end();\n    })\n    .catch(error => {\n      response.status(400).send({ error: 'malformatted id' });\n    });\n});\n\nnotesRouter.post('/', (request, response) => {\n  const body = request.body;\n\n  if (body.content === undefined) {\n    response.status(400).json({ error: 'content missing' });\n  }\n\n  const note = new Note({\n    content: body.content,\n    important: body.important === undefined ? false : body.important,\n    date: new Date(),\n  });\n\n  note\n    .save()\n    .then(note => {\n      return formatNote(note);\n    })\n    .then(formattedNote => {\n      response.json(formattedNote);\n    });\n});\n\nnotesRouter.put('/:id', (request, response) => {\n  const body = request.body;\n\n  const note = {\n    content: body.content,\n    important: body.important,\n  };\n\n  Note.findByIdAndUpdate(request.params.id, note, { new: true })\n    .then(updatedNote => {\n      response.json(formatNote(updatedNote));\n    })\n    .catch(error => {\n      console.log(error);\n      response.status(400).send({ error: 'malformatted id' });\n    });\n});\n\nmodule.exports = notesRouter;\n</code></pre>\n<p>Kyseessä on käytännössä melkein suora copypaste tiedostosta <em>index.js</em>.</p>\n<p>Muutoksia on muutama. Tiedoston alussa luodaan <a href=\"http://expressjs.com/en/api.html#router\">router</a>-olio:</p>\n<pre><code class=\"language-js\">const notesRouter = require('express').Router();\n\n//...\n\nmodule.exports = notesRouter;\n</code></pre>\n<p>Tiedosto eksporttaa moduulin käyttäjille määritellyn routerin.</p>\n<p>Kaikki määriteltävät routet liitetään router-olioon, samaan tapaan kuin aiemmassa versiossa routet liitettiin sovellusta edustavaan olioon.</p>\n<p>Huomioinarvoinen seikka routejen määrittelyssä on se, että polut ovat typistyneet, aiemmin määrittelimme esim.</p>\n<pre><code class=\"language-js\">app.delete('/api/notes/:id', (request, response) => {\n</code></pre>\n<p>nyt riittää määritellä</p>\n<pre><code class=\"language-js\">notesRouter.delete('/:id', (request, response) => {\n</code></pre>\n<p>Mistä routereissa oikeastaan on kyse? Expressin manuaalin sanoin</p>\n<blockquote>\n<p>A router object is an isolated instance of middleware and routes. You can think of it as a “mini-application,” capable only of performing middleware and routing functions. Every Express application has a built-in app router.</p>\n</blockquote>\n<p>Router on siis <em>middleware</em>, jonka avulla on mahdollista määritellä joukko \"toisiinsa liittyviä\" routeja yhdessä paikassa, yleensä omassa moduulissaan.</p>\n<p>Ohjelman käynnistystiedosto, eli määrittelyt tekevä <em>index.js</em> ottaa määrittelemämme routerin käyttöön seuraavasti:</p>\n<pre><code class=\"language-js\">const notesRouter = require('./controllers/notes');\napp.use('/api/notes', notesRouter);\n</code></pre>\n<p>Näin määrittelemäämme routeria käytetään <em>jos</em> polun alkuosa on <em>/api/notes</em>. notesRouter-olion sisällä täytyy tämän takia käyttää ainoastaan polun loppuosia, eli tyhjää polkua <em>/</em> tai pelkkää parametria <em>/:id</em>.</p>\n<h3>sovelluksen muut osat</h3>\n<p>Sovelluksen käynnistyspisteenä toimiva <em>index.js</em> näyttää muutosten jälkeen seuraavalta:</p>\n<pre><code class=\"language-js\">const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst cors = require('cors');\nconst mongoose = require('mongoose');\nconst middleware = require('./utils/middleware');\nconst notesRouter = require('./controllers/notes');\n\nif (process.env.NODE_ENV !== 'production') {\n  require('dotenv').config();\n}\n\nmongoose\n  .connect(process.env.MONGODB_URI)\n  .then(() => {\n    console.log('connected to database', process.env.MONGODB_URI);\n  })\n  .catch(err => {\n    console.log(err);\n  });\n\napp.use(cors());\napp.use(bodyParser.json());\napp.use(express.static('build'));\napp.use(middleware.logger);\n\napp.use('/api/notes', notesRouter);\n\napp.use(middleware.error);\n\nconst PORT = process.env.PORT || 3001;\napp.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n</code></pre>\n<p>Tiedostossa siis otetaan käyttöön joukko middlewareja, näistä yksi on polkuun <em>/api/notes</em> kiinnitettävä <em>notesRouter</em> (tai notes-kontrolleri niin kuin jotkut sitä kutsuisivat).</p>\n<p>Tietokannan yhteydenmuodostuksen suorittavaan funktioon on myös lisätty tapahtumankäsittelijä, joka ilmoittaa onko yhteyden muodostus onnistunut vai ei.</p>\n<p>Middlewareista kaksi <em>middleware.logger</em> ja <em>middleware.error</em> on määritelty hakemiston <em>utils</em> tiedostossa <em>middleware.js</em>:</p>\n<pre><code class=\"language-js\">const logger = (request, response, next) => {\n  console.log('Method:', request.method);\n  console.log('Path:  ', request.path);\n  console.log('Body:  ', request.body);\n  console.log('---');\n  next();\n};\n\nconst error = (request, response) => {\n  response.status(404).send({ error: 'unknown endpoint' });\n};\n\nmodule.exports = {\n  logger,\n  error,\n};\n</code></pre>\n<p>Tietokantayhteyden muodostaminen on nyt siirretty konfiguraatiot tekevän <em>index.js</em>:n vastuulle. Hakemistossa <em>models</em> oleva tiedosto <em>note.js</em> sisältää nyt ainoastaan muistiinpanojen skeeman määrittelyn.</p>\n<pre><code class=\"language-js\">const mongoose = require('mongoose');\n\nconst Note = mongoose.model('Note', {\n  content: String,\n  date: Date,\n  important: Boolean,\n});\n\nmodule.exports = Note;\n</code></pre>\n<p>Sovelluksen tämänhetkinen koodi on kokonaisuudessaan <a href=\"https://github.com/FullStack-HY/part3-notes-backend/tree/part4-1\">githubissa</a>, tagissa <em>part4-1</em>:</p>\n<p>Jos kloonaat projektin itsellesi, suorita komento <em>npm install</em> ennen käynnistämistä eli komentoa <em>npm start</em>.</p>\n<p>Express-sovelluksien rakenteelle, eli hakemistojen ja tiedostojen nimennälle ei ole olemassa mitään yleismaailmallista standardia samaan tapaan kuin esim. Ruby on Railsissa. Tässä käyttämämme malli noudattaa eräitä internetissä vastaan tulevia hyviä käytäntöjä.</p>\n<h2>Tehtäviä</h2>\n<p>Tee nyt tehtävät <a href=\"/teht%C3%A4v%C3%A4t#sovelluksen-alustus-ja-rakenne\">4.1 ja 4.2</a></p>\n<h2>node-sovellusten testaaminen</h2>\n<p>Olemme laiminlyöneet ikävästi yhtä oleellista ohjelmistokehityksen osa-aluetta, automatisoitua testaamista.</p>\n<p>Aloitamme yksikkötestauksesta. Sovelluksemme logiikka on sen verran yksinkertaista, että siinä ei ole juurikaan mielekästä yksikkötestattavaa. Luodaan tiedosto <em>utils/for</em>testing.js_ ja määritellään sinne pari yksinkertaista funktiota testattavaksi:</p>\n<pre><code class=\"language-js\">const palindrom = string => {\n  return string\n    .split('')\n    .reverse()\n    .join('');\n};\n\nconst average = array => {\n  const reducer = (sum, item) => {\n    return sum + item;\n  };\n\n  return array.reduce(reducer, 0) / array.length;\n};\n\nmodule.exports = {\n  palindrom,\n  average,\n};\n</code></pre>\n<blockquote>\n<p>Metodi <em>average</em> käyttää taulukoiden metodia <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\">reduce</a>. Jos metodi ei ole vieläkään tuttu, on korkea aika katsoa youtubesta <a href=\"https://www.youtube.com/watch?v=BMUiFMZr7vk&#x26;list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84\">Functional Javascript</a> -sarjasta ainakin kolme ensimmäistä videoa.</p>\n</blockquote>\n<p>Javascriptiin on tarjolla runsaasti erilaisia testikirjastoja eli <em>test runnereita</em>. Käytämme tällä kurssilla Facebookin kehittämää ja sisäisesti käyttämää <a href=\"https://jestjs.io/\">jest</a>:iä, joka on toiminnaltaan ja syntaksiltaankin hyvin samankaltainen kuin tämän hetken eniten käytetty testikirjasto <a href=\"https://mochajs.org/\">Mocha</a>. Muitakin mahdollisuuksia olisi, esim. eräissä piireissä suosiota nopeasti saavuttanut <a href=\"https://github.com/avajs/ava\">ava</a>.</p>\n<p>Jest on tälle kurssille luonteva valinta, sillä se sopii hyvin backendien testaamiseen, mutta suorastaan loistaa Reactilla tehtyjen frontendien testauksessa.</p>\n<blockquote>\n<p><em>Huomio Windows-käyttäjille:</em> jest ei välttämättä toimi, jos projektin hakemistopolulla on hakemisto, jonka nimessä on välilyöntejä.</p>\n</blockquote>\n<p>Koska testejä on tarkoitus suorittaa ainoastaan sovellusta kehitettäessä, asennetaan <em>jest</em> kehitysaikaiseksi riippuvuudeksi komennolla</p>\n<pre><code class=\"language-bash\">npm install --save-dev jest\n</code></pre>\n<p>määritellään <em>npm</em> skripti <em>test</em> suorittamaan testaus jestillä ja raportoimaan testien suorituksesta <em>verbose</em>-tyylillä:</p>\n<pre><code class=\"language-bash\">{\n  //...\n  \"scripts\": {\n    \"start\": \"node index.js\",\n    \"watch\": \"nodemon index.js\",\n    \"lint\": \"eslint .\",\n    \"test\": \"jest --verbose\"\n  },\n  //...\n}\n</code></pre>\n<p>Jestin uudemmissa versioissa näyttäisi olevan tarve kertoa, että suoritusympäristönä on käytössä Node. Tämä tapahtuu esim. lisäämällä <em>package.json</em> tiedoston loppuun:</p>\n<pre><code class=\"language-js\">{\n //...\n \"jest\": {\n   \"testEnvironment\": \"node\"\n }\n}\n</code></pre>\n<p>Tai vaihtoehtoisesti Jest löytää myös oletuksena asetustiedoston nimellä <em>jest.config.js</em>, jonne suoritusympäristön määrittely tapahtuu seuraavasti:</p>\n<pre><code class=\"language-js\">module.exports = {\n  testEnvironment: 'node',\n};\n</code></pre>\n<p>Tehdään testejä varten hakemisto <em>tests</em> ja sinne tiedosto <em>palindrom.test.js</em>, jonka sisältö on seuraava</p>\n<pre><code class=\"language-js\">const palindrom = require('../utils/for_testing').palindrom;\n\ntest('palindrom of a', () => {\n  const result = palindrom('a');\n\n  expect(result).toBe('a');\n});\n\ntest('palindrom of react', () => {\n  const result = palindrom('react');\n\n  expect(result).toBe('tcaer');\n});\n\ntest('palindrom of saippuakauppias', () => {\n  const result = palindrom('saippuakauppias');\n\n  expect(result).toBe('saippuakauppias');\n});\n</code></pre>\n<p>Edellisessä osassa käyttöön ottamamme ESlint valittaa testien käyttämistä komennoista <em>test</em> ja <em>expect</em> sillä käyttämämme konfiguraatio kieltää <em>globaalina</em> määriteltyjen asioiden käytön. Poistetaan valitus lisäämällä <em>.eslintrc.js</em>-tiedoston kenttään <em>env</em> arvo <code>\"jest\": true</code>. Näin kerromme eslintille, että käytämme projektissamme Jestiä ja sen globaaleja muuttujia.</p>\n<pre><code class=\"language-js\">module.exports = {\n  env: {\n    es6: true,\n    node: true,\n    jest: true,\n  },\n  extends: 'eslint:recommended',\n  rules: {\n    //...\n  },\n};\n</code></pre>\n<p>Toinen tapa olisi lisätä kenttä <em>globals</em> ja määrittää käytetyt globaalit muuttujat seuraavasti:</p>\n<pre><code class=\"language-js\">module.exports = {\n  env: {\n    es6: true,\n    node: true,\n  },\n  extends: 'eslint:recommended',\n  rules: {\n    //...\n  },\n  globals: {\n    test: true,\n    expect: true,\n    describe: true,\n  },\n};\n</code></pre>\n<p>Testi ottaa ensimmäisellä rivillä käyttöön testattavan funktion sijoittaen sen muuttujaan <em>palindrom</em>:</p>\n<pre><code class=\"language-js\">const palindrom = require('../utils/for_testing').palindrom;\n</code></pre>\n<p>Yksittäiset testitapaukset määritellään funktion <em>test</em> avulla. Ensimmäisenä parametrina on merkkijonomuotoinen testin kuvaus. Toisena parametrina on <em>funktio</em>, joka määrittelee testitapauksen toiminnallisuuden. Esim. toisen testitapauksen toiminnallisuus näyttää seuraavalta:</p>\n<pre><code class=\"language-js\">() => {\n  const result = palindrom('react');\n\n  expect(result).toBe('tcaer');\n};\n</code></pre>\n<p>Ensin suoritetaan testattava koodi, eli generoidaan merkkijonon <em>react</em> palindromi. Seuraavaksi varmistetaan tulos metodin <a href=\"https://facebook.github.io/jest/docs/en/expect.html#content\">expect</a> avulla. Expect käärii tuloksena olevan arvon olioon, joka tarjoaa joukon <em>matcher</em>-funktioita, joiden avulla tuloksen oikeellisuutta voidaan tarkastella. Koska kyse on kahden merkkijonon samuuden vertailusta, sopii tilanteeseen matcheri <a href=\"https://facebook.github.io/jest/docs/en/expect.html#tobevalue\">toBe</a>.</p>\n<p>Kuten odotettua, testit menevät läpi:</p>\n<picture><img src=\"/static/f369ff970b39bd82fba9aadb27718692/14be6/1.png\" srcset=\"/static/f369ff970b39bd82fba9aadb27718692/4cce7/1.png 200w,\n/static/f369ff970b39bd82fba9aadb27718692/bae5f/1.png 400w,\n/static/f369ff970b39bd82fba9aadb27718692/14be6/1.png 800w,\n/static/f369ff970b39bd82fba9aadb27718692/1b35a/1.png 1200w,\n/static/f369ff970b39bd82fba9aadb27718692/574f9/1.png 1300w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Jest olettaa oletusarvoisesti, että testitiedoston nimessä on merkkijono <em>.test</em>. Käytetään kurssilla konventiota, millä testitiedostojen nimen loppu on <em>.test.js</em></p>\n<p>Jestin antamat virheilmoitukset ovat hyviä, rikotaan testi</p>\n<pre><code class=\"language-js\">test('palindrom of react', () => {\n  const result = palindrom('react');\n\n  expect(result).toBe('tkaer');\n});\n</code></pre>\n<p>seurauksena on seuraava virheilmotus</p>\n<picture><img src=\"/static/9ccc68b73e589545be67065f428812a5/14be6/2.png\" srcset=\"/static/9ccc68b73e589545be67065f428812a5/4cce7/2.png 200w,\n/static/9ccc68b73e589545be67065f428812a5/bae5f/2.png 400w,\n/static/9ccc68b73e589545be67065f428812a5/14be6/2.png 800w,\n/static/9ccc68b73e589545be67065f428812a5/1b35a/2.png 1200w,\n/static/9ccc68b73e589545be67065f428812a5/2908d/2.png 1524w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Lisätään muutama testi metodille <em>average</em>, tiedostoon <em>tests/average.test.js</em>.</p>\n<pre><code class=\"language-js\">const average = require('../utils/for_testing').average;\n\ndescribe('average', () => {\n  test('of one value is the value itself', () => {\n    expect(average([1])).toBe(1);\n  });\n\n  test('of many is calculated right', () => {\n    expect(average([1, 2, 3, 4, 5, 6])).toBe(3.5);\n  });\n\n  test('of empty array is zero', () => {\n    expect(average([])).toBe(0);\n  });\n});\n</code></pre>\n<p>Testi paljastaa, että metodi toimii väärin tyhjällä taulukolla (sillä nollallajaon tulos on Javascriptissä <em>NaN</em>):</p>\n<picture><img src=\"/static/847102c61ea1f67a0560af5b724c536c/14be6/3.png\" srcset=\"/static/847102c61ea1f67a0560af5b724c536c/4cce7/3.png 200w,\n/static/847102c61ea1f67a0560af5b724c536c/bae5f/3.png 400w,\n/static/847102c61ea1f67a0560af5b724c536c/14be6/3.png 800w,\n/static/847102c61ea1f67a0560af5b724c536c/1b35a/3.png 1200w,\n/static/847102c61ea1f67a0560af5b724c536c/1ee5b/3.png 1344w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Metodi on helppo korjata</p>\n<pre><code class=\"language-js\">const average = array => {\n  const reducer = (sum, item) => {\n    return sum + item;\n  };\n  return array.length === 0 ? 0 : array.reduce(reducer, 0) / array.length;\n};\n</code></pre>\n<p>Eli jos taulukon pituus on 0, palautetaan 0 ja muussa tapauksessa palautetaan metodin <em>reduce</em> avulla laskettu keskiarvo.</p>\n<p>Pari huomiota keskiarvon testeistä. Määrittelimme testien ympärille nimellä <em>average</em> varustetun <em>describe</em>-lohkon.</p>\n<pre><code class=\"language-js\">describe('average', () => {\n  // testit\n});\n</code></pre>\n<p>Describejen avulla yksittäisessä tiedostossa olevat testit voidaan jaotella loogisiin kokonaisuuksiin. Testituloste hyödyntää myös describe-lohkon nimeä:</p>\n<picture><img src=\"/static/935f566d8f465faef0e915b0c019648a/14be6/4.png\" srcset=\"/static/935f566d8f465faef0e915b0c019648a/4cce7/4.png 200w,\n/static/935f566d8f465faef0e915b0c019648a/bae5f/4.png 400w,\n/static/935f566d8f465faef0e915b0c019648a/14be6/4.png 800w,\n/static/935f566d8f465faef0e915b0c019648a/1b35a/4.png 1200w,\n/static/935f566d8f465faef0e915b0c019648a/de095/4.png 1478w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Kuten myöhemmin tulemme näkemään, <em>describe</em>-lohkot ovat tarpeellisia siinä vaiheessa, jos haluamme osalle yksittäisen testitiedoston testitapauksista jotain yhteisiä alustus- tai lopetustoimenpiteitä.</p>\n<p>Toisena huomiona se, että kirjoitimme testit aavistuksen tiiviimmässä muodossa, ottamatta testattavan metodin tulosta erikseen apumuuttujaan:</p>\n<pre><code class=\"language-js\">test('of empty array is zero', () => {\n  expect(average([])).toBe(0);\n});\n</code></pre>\n<h2>Tehtäviä</h2>\n<p>Tee nyt tehtävät <a href=\"/teht%C3%A4v%C3%A4t#yksikk%C3%B6testaus\">4.3-4.7</a></p>\n<h2>API:n testaaminen</h2>\n<p>Joissain tilanteissa voisi olla mielekästä suorittaa ainakin osa backendin testauksesta siten, että oikea tietokanta eristettäisiin testeistä ja korvattaisiin \"valekomponentilla\" eli mockilla. Eräs tähän sopiva ratkaisu olisi <a href=\"https://github.com/williamkapke/mongo-mock\">mongo-mock</a>.</p>\n<p>Koska sovelluksemme backend on koodiltaan kuitenkin suhteellisen yksinkertainen, päätämme testata sitä kokonaisuudessaan, siten että myös testeissä käytetään tietokantaa. Tämän kaltaisia, useita sovelluksen komponentteja yhtäaikaa käyttäviä testejä voi luonnehtia <a href=\"https://en.wikipedia.org/wiki/Integration_testing\">integraatiotesteiksi</a>.</p>\n<h3>test-ympäristö</h3>\n<p>Edellisen osan luvussa <a href=\"/osa3/#sovelluksen-vieminen-tuotantoon\">Sovelluksen vieminen tuotantoon</a> mainitsimme, että kun sovellusta suoritetaan Herokussa, on se <em>production</em>-moodissa.</p>\n<p>Noden konventiona on määritellä projektin suoritusmoodi ympäristömuuttujan <em>NODE</em>ENV_ avulla. Lataammekin sovelluksen nykyisessä versiossa tiedostossa <em>.env</em> määritellyt ympäristömuuttujat ainoastaan jos sovellus <em>ei ole</em> production moodissa:</p>\n<pre><code class=\"language-js\">if (process.env.NODE_ENV !== 'production') {\n  require('dotenv').config();\n}\n</code></pre>\n<p>Yleinen käytäntö on määritellä sovelluksille omat moodinsa myös sovelluskehitykseen ja testaukseen.</p>\n<p>Määritellään nyt tiedostossa <em>package.json</em>, että testejä suorittaessa sovelluksen <em>NODE</em>ENV_ saa arvokseen <em>test</em>:</p>\n<pre><code class=\"language-bash\">{\n  // ...\n  \"scripts\": {\n    \"start\": \"NODE_ENV=production node index.js\",\n    \"watch\": \"NODE_ENV=development nodemon index.js\",\n    \"test\": \"NODE_ENV=test jest --verbose\",\n    \"lint\": \"eslint .\"\n  },\n  // ...\n}\n</code></pre>\n<p>Samalla määriteltiin, että suoritettaessa sovellusta komennolla <em>npm run watch</em> eli nodemonin avulla, on sovelluksen moodi <em>development</em>. Jos sovellusta suoritetaan normaalisti Nodella, on moodiksi määritelty <em>production</em>.</p>\n<p>Määrittelyssämme on kuitenkin pieni ongelma, se ei toimi windowsilla. Tilanne korjautuu asentamalla kirjasto <a href=\"https://www.npmjs.com/package/cross-env\">cross-env</a> komennolla</p>\n<pre><code class=\"language-bash\">npm install --save-dev cross-env\n</code></pre>\n<p>ja muuttamalla <em>package.js</em> kaikilla käyttöjärjestelmillä toimivaan muotoon</p>\n<pre><code class=\"language-bash\">{\n  // ...\n  \"scripts\": {\n    \"start\": \"cross-env NODE_ENV=production node index.js\",\n    \"watch\": \"cross-env NODE_ENV=development nodemon index.js\",\n    \"test\": \"cross-env NODE_ENV=test jest --verbose\",\n    \"lint\": \"eslint .\"\n  },\n  // ...\n}\n</code></pre>\n<p>Nyt sovelluksen toimintaa on mahdollista muokata sen suoritusmoodiin perustuen. Eli voimme määritellä, esim. että testejä suoritettaessa ohjelma käyttää erillistä, testejä varten luotua tietokantaa.</p>\n<p>Sovelluksen testikanta voidaan luoda tuotantokäytön ja sovelluskehityksen tapaan <a href=\"https://mlab.com/\">mlabiin</a>. Ratkaisu ei ole optimaalinen erityisesti, jos sovellusta on tekemässä yhtä aikaa useita henkilöitä. Testien suoritus nimittäin yleensä edellyttää, että samaa tietokantainstanssia ei ole yhtä aikaa käyttämässä useampia testiajoja.</p>\n<p>Testaukseen kannattaakin käyttää verkossa olevaa jaettua tietokantaa mieluummin esim. sovelluskehittäjän paikallisen koneen tietokantaa. Optimiratkaisu olisi tietysti se, että jokaista testiajoa varten olisi käytettävissä oma tietokanta, sekin periaatteessa onnistuu \"suhteellisen helposti\" mm. <a href=\"https://docs.mongodb.com/manual/core/inmemory/\">keskusmuistissa toimivan Mongon</a> ja <a href=\"https://www.docker.com\">docker</a>-kontainereiden avulla. Etenemme kuitenkin nyt lyhyemmän kaavan mukaan ja käytetään testikantana normaalia Mongoa.</p>\n<p>Voisimme kirjoittaa ympäristökohtaiset konfiguraatiot, esim. oikean tietokannan valinnan suoraan tiedostoon <em>index.js</em>, se kuitenkin tekisi tiedoston koodista sekavan. Eristetään sovelluksen ympäristökohtainen konfigurointi omaan tiedostoon <em>utils/config.js</em> sijoitettavaan moduuliin.</p>\n<p>Ideana on, että <em>index.js</em> voi käyttää konfiguraatioita seuraavasti:</p>\n<pre><code class=\"language-js\">const config = require('./utils/config');\n\n// ...\n\nmongoose\n  .connect(config.mongoUrl)\n  .then(() => {\n    console.log('connected to database', config.mongoUrl);\n  })\n  .catch(err => {\n    console.log(err);\n  });\n\n// ...\n\nconst PORT = config.port;\n</code></pre>\n<p>Konfiguraation suorittavan moduulin koodi on seuraavassa:</p>\n<pre><code class=\"language-js\">if (process.env.NODE_ENV !== 'production') {\n  require('dotenv').config();\n}\n\nlet port = process.env.PORT;\nlet mongoUrl = process.env.MONGODB_URI;\n\nif (process.env.NODE_ENV === 'test') {\n  port = process.env.TEST_PORT;\n  mongoUrl = process.env.TEST_MONGODB_URI;\n}\n\nmodule.exports = {\n  mongoUrl,\n  port,\n};\n</code></pre>\n<p>Koodi lataa ympäristömuuttujat tiedostosta <em>.env</em> jos se <em>ei ole</em> tuotantomoodissa. Tuotantomoodissa käytetään Herokuun asetettuja ympäristömuuttujia.</p>\n<p>Tiedostossa <em>.env</em> on nyt määritelty <em>erikseen</em> sekä sovelluskehitysympäristön että testausympäristön tietokannan osoite (esimerkissä molemmat ovat sovelluskehityskoneen lokaaleja mongo-kantoja) ja portti:</p>\n<pre><code class=\"language-bash\">MONGODB_URI=mongodb://fullstack:sekred@ds111078.mlab.com:11078/fullstact-notes-dev\nPORT=3001\n\nTEST_PORT=3002\nTEST_MONGODB_URI=mongodb://fullstack:sekred@ds113098.mlab.com:13098/fullstack-notes-test\n</code></pre>\n<p>Eri porttien käyttö mahdollistaa sen, että sovellus voi olla käynnissä testien suorituksen aikana.</p>\n<p>Omatekemämme eri ympäristöjen konfiguroinnista huolehtiva <em>config</em>-moduuli toimii hieman samassa hengessä kuin <a href=\"https://github.com/lorenwest/node-config\">node-config</a>-kirjasto. Omatekemä konfigurointiympäristö sopii tarkoitukseemme, sillä sovellus on yksinkertainen ja oman konfiguraatio-moduulin tekeminen on myös jossain määrin opettavaista. Isommissa sovelluksissa kannattaa harkita valmiiden kirjastojen, kuten <a href=\"https://github.com/lorenwest/node-config\">node-config</a>:in käyttöä.</p>\n<p>Tiedosto <em>index.js</em> muutetaan nyt muotoon:</p>\n<pre><code class=\"language-js\">const http = require('http');\nconst express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst cors = require('cors');\nconst mongoose = require('mongoose');\nconst middleware = require('./utils/middleware');\nconst notesRouter = require('./controllers/notes');\nconst config = require('./utils/config');\n\nmongoose\n  .connect(config.mongoUrl)\n  .then(() => {\n    console.log('connected to database', config.mongoUrl);\n  })\n  .catch(err => {\n    console.log(err);\n  });\n\napp.use(cors());\napp.use(bodyParser.json());\napp.use(express.static('build'));\napp.use(middleware.logger);\n\napp.use('/api/notes', notesRouter);\n\napp.use(middleware.error);\n\nconst server = http.createServer(app);\n\nserver.listen(config.port, () => {\n  console.log(`Server running on port ${config.port}`);\n});\n\nserver.on('close', () => {\n  mongoose.connection.close();\n});\n\nmodule.exports = {\n  app,\n  server,\n};\n</code></pre>\n<blockquote>\n<p><strong>HUOM</strong>: koska käytämme useimpia kirjastoja koodissa vain kerran, olisi mahdollista tiivistää koodia hiukan kirjoittamalla esim. <code>app.use(cors())</code> sijaan <code>app.use(require('cors')())</code> ja jättää apumuuttuja <em>cors</em> kokonaan määrittelemättä. On kuitenkin epäselvää kannattaako tälläiseen koodirivien säästelyyn lähteä. Ei ainakaan silloin jos koodin ymmärrettävyys kärsisi.</p>\n</blockquote>\n<p>Tiedoston lopussa on muutama tärkeä muutos.</p>\n<p>Sovelluksen käynnistäminen tapahtuu nyt <em>server</em>-muuttujassa olevan olion kautta. Serverille määritellään tapahtumankäsitteljäfunktio tapahtumalle <em>close</em> eli tilanteeseen, missä sovellus sammutetaan. Tapahtumankäsittelijä sulkee tietokantayhteyden.</p>\n<p>Sekä sovellus <em>app</em> että sitä suorittava <em>server</em>-olio määritellään eksportattavaksi tiedostosta. Tämä mahdollistaa sen, että testit voivat käynnistää ja sammuttaa backendin.</p>\n<p>Sovelluksen tämänhetkinen koodi on kokonaisuudessaan <a href=\"https://github.com/FullStack-HY/part3-notes-backend/tree/part4-2\">githubissa</a>, tagissa <em>part4-2</em>.</p>\n<h3>supertest</h3>\n<p>Käytetään API:n testaamiseen Jestin apuna <a href=\"https://github.com/visionmedia/supertest\">supertest</a>-kirjastoa.</p>\n<p>Kirjasto asennetaan kehitysaikaiseksi riippuvuudeksi komennolla</p>\n<pre><code class=\"language-bash\">npm install --save-dev supertest\n</code></pre>\n<p>Luodaan heti ensimmäinen testi tiedostoon <em>tests/note</em>api.test.js:_</p>\n<pre><code class=\"language-js\">const supertest = require('supertest');\nconst { app, server } = require('../index');\nconst api = supertest(app);\n\ntest('notes are returned as json', async () => {\n  await api\n    .get('/api/notes')\n    .expect(200)\n    .expect('Content-Type', /application\\/json/);\n});\n\nafterAll(() => {\n  server.close();\n});\n</code></pre>\n<p>Toisella rivillä testi käynnistää backendin ja käärii sen kolmannella rivillä funktion <em>supertest</em> avulla ns. <a href=\"https://github.com/visionmedia/superagent\">superagent</a>-olioksi. Tämä olio sijoitetaan muuttujaan <em>api</em> ja sen kautta testit voivat tehdä HTTP-pyyntöjä backendiin.</p>\n<p>Testimetodi tekee HTTP GET -pyynnön osoitteeseen <em>api/notes</em> ja varmistaa, että pyyntöön vastataan statuskoodilla 200 ja että data palautetaan oikeassa muodossa, eli että <em>Content-Type</em>:n arvo on <em>application/json</em>.</p>\n<p>Testissä on muutama detalji joihin tutustumme vasta <a href=\"#async-await\">hieman myöhemmin</a> tässä osassa. Testikoodin määrittelevä nuolifunktio alkaa sanalla <em>async</em> ja <em>api</em>-oliolle tehtyä metodikutsua edeltää sama <em>await</em>. Teemme ensin muutamia testejä ja tutustumme sen jälkeen async/await-magiaan. Tällä hetkellä niistä ei tarvitse välittää, kaikki toimii kun kirjoitat testimetodit esimerkin mukaan. Async/await-syntaksin käyttö liittyy siihen, että palvelimelle tehtävät pyynnöt ovat <em>asynkronisia</em> operaatioita. <a href=\"https://facebook.github.io/jest/docs/en/asynchronous.html\">Async/await-kikalla</a> saamme pyynnön näyttämään koodin tasolla synkroonisesti toimivalta.</p>\n<p>Huom! Jos eslint herjaa async -syntaksista, niin saat ongelman korjattua lisäämällä seuraavan <code>.eslintrc.js</code> tiedostoon (<a href=\"https://eslint.org/docs/user-guide/configuring#specifying-parser-options\">lisätietoa parserin asetuksista</a>):</p>\n<pre><code class=\"language-js\">module.exports = {\n  //...\n  parserOptions: {\n    ecmaVersion: 2018,\n  },\n};\n</code></pre>\n<p>Kaikkien testien (joita siis tällä kertaa on vain yksi) päätteeksi on vielä lopputoimenpiteenä pyydettävä backendia suorittava <em>server</em>-olio sammuttamaan itsensä. Tämä onnistuu helposti metodissa <a href=\"https://facebook.github.io/jest/docs/en/api.html#afterallfn-timeout\">afterAll</a>:</p>\n<pre><code class=\"language-js\">afterAll(() => {\n  server.close();\n});\n</code></pre>\n<p>HTTP-pyyntöjen tiedot loggaava middleware <em>logger</em> häiritsee hiukan testien tulostusta. Jos haluat hiljentää sen testien suorituksen ajaksi, muuta funktiota esim. seuraavasti:</p>\n<pre><code class=\"language-js\">const logger = (request, response, next) => {\n  if (process.env.NODE_ENV === 'test') {\n    return next();\n  }\n  console.log('Method:', request.method);\n  console.log('Path:  ', request.path);\n  console.log('Body:  ', request.body);\n  console.log('---');\n  next();\n};\n</code></pre>\n<p>Tehdään pari testiä lisää:</p>\n<pre><code class=\"language-js\">test('there are five notes', async () => {\n  const response = await api.get('/api/notes');\n\n  expect(response.body.length).toBe(5);\n});\n\ntest('the first note is about HTTP methods', async () => {\n  const response = await api.get('/api/notes');\n\n  expect(response.body[0].content).toBe('HTML on helppoa');\n});\n</code></pre>\n<p>Molemmat testit sijoittavat pyynnön vastauksen muuttujaan <em>response</em> ja toisin kuin edellinen testi, joka käytti <em>supertestin</em> mekanismeja statuskoodin ja vastauksen headereiden oikeellisuuden varmistamiseen, tällä kertaa tutkitaan vastauksessa olevan datan, eli <em>response.body</em>:n oikeellisuutta Jestin <a href=\"https://facebook.github.io/jest/docs/en/expect.html#content\">expect</a>:in avulla.</p>\n<p>Async/await-kikan hyödyt tulevat nyt selkeästi esiin. Normaalisti tarvitsisimme asynkronisten pyyntöjen vastauksiin käsille pääsemiseen promiseja ja takaisinkutsuja, mutta nyt kaikki menee mukavasti:</p>\n<pre><code class=\"language-js\">const res = await api.get('/api/notes');\n\n// tänne tullaan vasta kun edellinen komento eli HTTP-pyyntö on suoritettu\n// muuttujassa res on nyt HTTP-pyynnön tulos\nexpect(res.body.length).toBe(5);\n</code></pre>\n<p>Testit menevät läpi. Testit ovat kuitenkin huonoja, niiden läpimeno riippuu tietokannan tilasta (joka sattuu omassa testikannassani olemaan sopiva). Jotta saisimme robustimmat testit, tulee tietokannan tila nollata testien alussa ja sen jälkeen laittaa kantaan hallitusti testien tarvitsema data.</p>\n<h3>Error: listen EADDRINUSE :::3002</h3>\n<p>Jos jotain patologista tapahtuu voi käydä niin, että testien suorittama palvelin jää päälle. Tällöin uusi testiajo aiheuttaa ongelmia, ja seurauksena on virheilmoitus</p>\n<pre>\nError: listen EADDRINUSE :::3002\n</pre>\n<p>Ratkaisu tilanteeseen on tappaa palvelinta suorittava prosessi. Portin 3002 varaava prosessi löytyy OSX:lla ja Linuxilla esim. komennolla <code>lsof -i :3002</code>.</p>\n<pre><code class=\"language-bash\">COMMAND  PID     USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME\nnode    8318 mluukkai   14u  IPv6 0x5428af4833b85e8b      0t0  TCP *:redwood-broker (LISTEN)\n</code></pre>\n<p>Windowsissa portin varaavan prosessin näkee resmon.exe:n Verkko-välilehdeltä.</p>\n<p>Komennon avulla selviää ikävyyksiä aiheuttavan prosessin PID eli prosessi-id. Prosessin saa tapettua komennolla <code>KILL 8318</code> olettaen että PID on 8318 niin kuin kuvassa. Joskus prosessi on sitkeä eikä kuole ennen kuin se tapetaan komennolla <code>KILL -9 8318</code>.</p>\n<p>Windowsissa vastaava komento on <code>taskkill /f /pid 8318</code>.</p>\n<h2>Tietokannan alustaminen ennen testejä</h2>\n<p>Testimme käyttää jo jestin metodia <a href=\"https://facebook.github.io/jest/docs/en/api.html#afterallfn-timeout\">afterAll</a> sulkemaan backendin testien suoritusten jälkeen. Jest tarjoaa joukon muitakin <a href=\"https://facebook.github.io/jest/docs/en/setup-teardown.html#content\">funktioita</a>, joiden avulla voidaan suorittaa operaatioita ennen yhdenkään testin suorittamista tai ennen jokaisen testin suoritusta.</p>\n<p>Päätetään alustaa tietokanta ennen kaikkien testin suoritusta, eli funktiossa <a href=\"https://facebook.github.io/jest/docs/en/api.html#beforeallfn-timeout\">beforeAll</a>:</p>\n<pre><code class=\"language-js\">const supertest = require('supertest');\nconst { app, server } = require('../index');\nconst api = supertest(app);\nconst Note = require('../models/note');\n\nconst initialNotes = [\n  {\n    content: 'HTML on helppoa',\n    important: false,\n  },\n  {\n    content: 'HTTP-protokollan tärkeimmät metodit ovat GET ja POST',\n    important: true,\n  },\n];\n\nbeforeAll(async () => {\n  await Note.remove({});\n\n  let noteObject = new Note(initialNotes[0]);\n  await noteObject.save();\n\n  noteObject = new Note(initialNotes[1]);\n  await noteObject.save();\n});\n</code></pre>\n<p>Tietokanta siis tyhjennetään aluksi ja sen jälkeen kantaan lisätään kaksi taulukkoon <em>initialNotes</em> talletettua muistiinpanoa. Näin testien suoritus aloitetaan aina hallitusti samasta tilasta.</p>\n<p>Muutetaan kahta jälkimmäistä testiä vielä seuraavasti:</p>\n<pre><code class=\"language-js\">test('all notes are returned', async () => {\n  const response = await api.get('/api/notes');\n\n  expect(response.body.length).toBe(initialNotes.length);\n});\n\ntest('a specific note is within the returned notes', async () => {\n  const response = await api.get('/api/notes');\n\n  const contents = response.body.map(r => r.content);\n\n  expect(contents).toContain(\n    'HTTP-protokollan tärkeimmät metodit ovat GET ja POST'\n  );\n});\n</code></pre>\n<p>Huomaa jälkimmäisen testin ekspektaatio. Komennolla <code>response.body.map(r => r.content)</code> muodostetaan taulukko API:n palauttamien muistiinpanojen sisällöistä. Jestin <a href=\"https://facebook.github.io/jest/docs/en/expect.html#tocontainitem\">toContain</a>-ekspektaatiometodilla tarkistetaan että parametrina oleva muistiinpano on kaikkien API:n palauttamien muistiinpanojen joukossa.</p>\n<p>Ennen kuin teemme lisää testejä, tarkastellaan tarkemmin mitä <em>async</em> ja <em>await</em> tarkoittavat.</p>\n<h2>async-await</h2>\n<p>Async- ja await ovat ES7:n mukanaan tuoma uusi syntaksi, joka mahdollistaa <em>promisen palauttavien asynkronisten funktioiden</em> kutsumisen siten, että kirjoitettava koodi näyttää synkroniselta.</p>\n<p>Esim. muistiinpanojen hakeminen tietokannasta hoidetaan promisejen avulla seuraavasti:</p>\n<pre><code class=\"language-js\">Note.find({}).then(notes => {\n  console.log('operaatio palautti seuraavat muistiinpanot', notes);\n});\n</code></pre>\n<p>Metodikutsu <em>Note.find()</em> palauttaa promisen, ja saamme itse operaation tuloksen rekisteröimällä promiselle tapahtumankäsittelijän metodilla <em>then</em>.</p>\n<p>Kaikki operaation suorituksen jälkeinen koodi kirjoitetaan tapahtumankäsittelijään. Jos haluaisimme tehdä peräkkäin useita asynkronisia funktiokutsuja, menisi tilanne ikävämmäksi. Joutuisimme tekemään kutsut tapahtumankäsittelijästä. Näin syntyisi potentiaalisesti monimutkaista koodia, pahimmassa tapauksessa jopa niin sanottu <a href=\"http://callbackhell.com/\">callback-helvetti</a>.</p>\n<p><a href=\"https://javascript.info/promise-chaining\">Ketjuttamalla promiseja</a> tilanne pysyy jollain tavalla hallinnassa, callback-helvetin eli monien sisäkkäisten callbackien sijaan saadaan aikaan siistihkö <em>then</em>-kutsujen ketju. Olemmekin nähneet jo kurssin aikana muutaman sellaisen. Seuraavassa vielä erittäin keinotekoinen esimerkki, joka hakee ensin kaikki muistiinpanot ja sitten tuhoaa niistä ensimmäisen:</p>\n<pre><code class=\"language-js\">Note.find({})\n  .then(notes => {\n    return notes[0].remove();\n  })\n  .then(response => {\n    console.log('the first note is removed');\n    // more code here\n  });\n</code></pre>\n<p>Then-ketju on ok, mutta parempaankin pystytään. Jo ES6:ssa esitellyt <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator\">generaattorifunktiot</a> mahdollistivat <a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch4.md#iterating-generators-asynchronously\">ovelan tavan</a> määritellä asynkronista koodia siten että se \"näyttää synkroniselta\". Syntaksi ei kuitenkaan ole täysin luonteva ja sitä ei käytetä kovin yleisesti.</p>\n<p>ES7:ssa <em>async</em> ja <em>await</em> tuovat generaattoreiden tarjoaman toiminnallisuuden ymmärrettävästi ja syntaksin puolesta selkeällä tavalla koko Javascript-kansan ulottuville.</p>\n<p>Voisimme hakea tietokannasta kaikki muistiinpanot <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await\">await</a>-operaattoria hyödyntäen seuraavasti:</p>\n<pre><code class=\"language-js\">const notes = await Note.find({});\n\nconsole.log('operaatio palautti seuraavat muistiinpanot ', notes);\n</code></pre>\n<p>Koodi siis näyttää täsmälleen synkroniselta koodilta. Suoritettavan koodinpätkän suhteen tilanne on se, että suoritus pysähtyy komentoon <code>const notes = await Note.find({})</code> ja jatkuu kyselyä vastaavan promisen <em>fulfillmentin</em> eli onnistuneen suorituksen jälkeen seuraavalta riviltä. Kun suoritus jatkuu, promisea vastaavan operaation tulos on muuttujassa <em>notes</em>.</p>\n<p>Ylempänä oleva monimutkaisempi esimerkki suoritettaisiin awaitin avulla seuraavasti:</p>\n<pre><code class=\"language-js\">const notes = await Note.find({});\nconst response = await notes[0].remove();\n\nconsole.log('the first note is removed');\n</code></pre>\n<p>Koodi siis yksinkertaistuu huomattavasti verrattuna promiseja käyttävään then-ketjuun.</p>\n<p>Awaitin käyttöön liittyy parikin tärkeää seikkaa. Jotta asynkronisia operaatioita voi kutsua awaitin avulla, niiden täytyy olla promiseja. Tämä ei sinänsä ole ongelma, sillä myös \"normaaleja\" callbackeja käyttävä asynkroninen koodi on helppo kääriä promiseksi.</p>\n<p>Mistä tahansa kohtaa Javascript-koodia ei awaitia kuitenkaan pysty käyttämään. Awaitin käyttö onnistuu ainoastaan jos ollaan <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\">async</a>-funktiossa.</p>\n<p>Eli jotta edelliset esimerkit toimisivat, on ne suoritettava async-funktioiden sisällä, huomaa funktion määrittelevä rivi:</p>\n<pre><code class=\"language-js\">const main = async () => {\n  const notes = await Note.find({});\n  console.log('operaatio palautti seuraavat muistiinpanot', notes);\n\n  const notes = await Note.find({});\n  const response = await notes[0].remove();\n\n  console.log('the first note is removed');\n};\n\nmain();\n</code></pre>\n<p>Koodi määrittelee ensin asynkronisen funktion, joka sijoitetaan muuttujaan <em>main</em>. Määrittelyn jälkeen koodi kutsuu metodia komennolla <code>main()</code></p>\n<h3>testin beforeAll-metodin optimointi</h3>\n<p>Palataan takaisin testien pariin, ja tarkastellaan määrittelemäämme testit alustavaa funktiota <em>beforeAll</em>:</p>\n<pre><code class=\"language-js\">const initialNotes = [\n  {\n    content: 'HTML on helppoa',\n    important: false,\n  },\n  {\n    content: 'HTTP-protokollan tärkeimmät metodit ovat GET ja POST',\n    important: true,\n  },\n];\n\nbeforeAll(async () => {\n  await Note.remove({});\n\n  let noteObject = new Note(initialNotes[0]);\n  await noteObject.save();\n\n  noteObject = new Note(initialNotes[1]);\n  await noteObject.save();\n});\n</code></pre>\n<p>Funktio tallettaa tietokantaan taulukon <em>initialNotes</em> nollannen ja ensimmäisen alkion, kummankin erikseen taulukon alkioita indeksöiden. Ratkaisu on ok, mutta jos haluaisimme tallettaa alustuksen yhteydessä kantaan useampia alkioita, olisi toisto parempi ratkaisu:</p>\n<pre><code class=\"language-js\">beforeAll(async () => {\n  await Note.remove({})\n  console.log('cleared')\n\n  initialNotes.forEach(async (note) => {\n    let noteObject = new Note(note)\n    await noteObject.save()\n    console.log('saved')\n  })\n  console.log('done')\n})\n\ntest('notes are returned as json', async () => {\n  console.log('entered test')\n  // ...\n}\n</code></pre>\n<p>Talletamme siis taulukossa <em>initialNotes</em> määritellyt muistiinpanot tietokantaan <em>forEach</em>-loopissa. Testeissä kuitenkin ilmenee jotain häikkää, ja sitä varten koodin sisään on lisätty aputulosteita.</p>\n<p>Konsoliin tulostuu</p>\n<pre>\ncleared\ndone\nentered test\nsaved\nsaved\n</pre>\n<p>Yllättäen ratkaisu ei async/awaitista huolimatta toimi niin kuin oletamme, testin suoritus aloitetaan ennen kuin tietokannan tila on saatu alustettua!</p>\n<p>Ongelma on siinä, että jokainen forEach-loopin läpikäynti generoi oman asynkronisen operaation ja <em>beforeAll</em> ei odota näiden suoritusta. Eli forEach:in sisällä olevat <em>await</em>-komennot eivät ole funktiossa <em>beforeAll</em> vaan erillisissä funktioissa joiden päättymistä <em>beforeAll</em> ei odota.</p>\n<p>Koska testien suoritus alkaa heti <em>beforeAll</em> metodin suorituksen jälkeen, testien suoritus ehditään jo aloittaa ennen kuin tietokanta on alustettu toivottuun alkutilaan.</p>\n<p>Toimiva ratkaisu tilanteessa on odottaa asynkronisten talletusoperaatioiden valmistumista <em>beforeAll</em>-funktiossa, esim. metodin <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\">Promise.all</a> avulla:</p>\n<pre><code class=\"language-js\">beforeAll(async () => {\n  await Note.remove({});\n\n  const noteObjects = initialNotes.map(note => new Note(note));\n  const promiseArray = noteObjects.map(note => note.save());\n  await Promise.all(promiseArray);\n});\n</code></pre>\n<p>Ratkaisu on varmasti aloittelijalle tiiviydestään huolimatta hieman haastava. Taulukkoon <em>noteObjects</em> talletetaan taulukkoon <em>initialNotes</em> talletettuja Javascript-oliota vastaavat <em>Note</em>-konstruktorifunktiolla generoidut Mongoose-oliot. Seuraavalla rivillä luodaan uusi taulukko, joka <em>muodostuu promiseista</em>, jotka saadaan kun jokaiselle <em>noteObjects</em> taulukon alkiolle kutsutaan metodia <em>save</em>, eli ne talletetaan kantaan.</p>\n<p>Metodin <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\">Promise.all</a> avulla saadaan koostettua taulukollinen promiseja yhdeksi promiseksi, joka valmistuu, eli menee tilaan <em>fulfilled</em> kun kaikki sen parametrina olevan taulukon promiset ovat valmistuneet.\nSiispä viimeinen rivi, <code>await Promise.all(promiseArray)</code> odottaa, että kaikki tietokantaan talletetusta vastaavat promiset ovat valmiina, eli alkiot on talletettu tietokantaan.</p>\n<blockquote>\n<p>Promise.all-metodia käyttäessä päästään tarvittaessa käsiksi sen parametrina olevien yksittäisten promisejen arvoihin, eli promiseja vastaavien operaatioiden tuloksiin. Jos odotetaan promisejen valmistumista <em>await</em>-syntaksilla <code>const results = await Promise.all(promiseArray)</code> palauttaa operaatio taulukon, jonka alkioina on <em>promiseArray</em>:n promiseja vastaavat arvot samassa järjestyksessä kuin promiset ovat taulukossa.</p>\n</blockquote>\n<p>Promise.all suorittaa kaikkia syötteenä saamiaan promiseja rinnakkain. Jos operaatioiden suoritusjärjestyksellä on merkitystä, voi tämä aiheuttaa ongelmia. Tällöin asynkroniset operaatiot on mahdollista määrittää <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of\">for...of</a> lohkon sisällä, jonka suoritusjärjestys on taattu.</p>\n<pre><code class=\"language-js\">beforeAll(async () => {\n  await Note.remove({});\n\n  for (let note of initialNotes) {\n    let noteObject = new Note(note);\n    await noteObject.save();\n  }\n});\n</code></pre>\n<p>Javascriptin asynkroninen suoritusmalli aiheuttaakin siis helposti yllätyksiä ja myös async/await-syntaksin kanssa pitää olla koko ajan tarkkana. Vaikka async/await peittää monia promisejen käsittelyyn liittyviä seikkoja, promisejen toiminta on syytä tuntea mahdollisimman hyvin!</p>\n<p>Sovelluksen tämänhetkinen koodi on kokonaisuudessaan <a href=\"https://github.com/FullStack-HY/part3-notes-backend/tree/part4-3\">githubissa</a>, tagissa <em>part4-3</em>.</p>\n<h3>async/await backendissä</h3>\n<p>Muutetaan nyt backend käyttämään asyncia ja awaitia. Koska kaikki asynkroniset operaatiot tehdään joka tapauksessa funktioiden sisällä, awaitin käyttämiseen riittää, että muutamme routejen käsittelijät async-funktioiksi.</p>\n<p>Kaikkien muistiinpanojen hakemisesta vastaava route muuttuu seuraavasti:</p>\n<pre><code class=\"language-js\">notesRouter.get('/', async (request, response) => {\n  const notes = await Note.find({});\n  response.json(notes.map(formatNote));\n});\n</code></pre>\n<p>Voimme varmistaa refaktoroinnin onnistumisen selaimella, sekä suorittamalla juuri määrittelemämme testit.</p>\n<h3>ESlint ja async/await nuolifunktioissa</h3>\n<p>Ennen testejä tehdään pieni täsmennys ESlint-konfiguraatioon. Tällä hetkellä ESlint saattaa valittaa <em>async</em>-määreellä varustetuista nuolifunktioista:</p>\n<picture><img src=\"/static/5a43462fa63800483b4231a20119a453/14be6/4b.png\" srcset=\"/static/5a43462fa63800483b4231a20119a453/4cce7/4b.png 200w,\n/static/5a43462fa63800483b4231a20119a453/bae5f/4b.png 400w,\n/static/5a43462fa63800483b4231a20119a453/14be6/4b.png 800w,\n/static/5a43462fa63800483b4231a20119a453/4d16a/4b.png 864w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Kyse on siitä, että ESlint ei vielä osaa tulkita uutta syntaksia kunnolla. Voi hyvin olla, että <a href=\"osa4/#supertest\">aiemmassa luvussa</a> tehty <em>parserOptions</em> määrittely on jo korjannut ongelman. Muuten pääsemme valituksesta eroon asentamalla <em>babel-eslint</em>-pluginin:</p>\n<pre><code class=\"language-bash\">npm install babel-eslint --save-dev\n</code></pre>\n<p>Pluginin käyttöönotto tulee määritellä tiedostossa <em>.eslintrc.js</em> :</p>\n<pre><code class=\"language-bash\">module.exports = {\n  \"env\": {\n    \"node\": true,\n    \"es6\": true\n  },\n  \"parser\": \"babel-eslint\",\n  // ...\n}\n</code></pre>\n<p>Aiheeton valitus poistuu.</p>\n</div>","frontmatter":{"title":"osa 4","subTitle":"Node.js / Express","path":"/osa4/node-express","mainImage":{"publicURL":"/static/osa5-8edc6044aad809a3143dc36c5e7f3b4c.png"},"partColor":"yellow","part":4,"letter":"a"}}},"pageContext":{}}