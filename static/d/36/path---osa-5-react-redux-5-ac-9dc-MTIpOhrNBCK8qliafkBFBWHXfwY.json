{"data":{"markdownRemark":{"html":"<div class=\"content\">\n<h2>Kirjautuminen React-sovelluksesta</h2>\n<p>Kaksi edellistä osaa keskittyivät lähinnä backendin toiminnallisuuteen. Edellisessä osassa backendiin toteutettua käyttäjänhallintaa ei ole tällä hetkellä tuettuna frontendissa millään tavalla.</p>\n<p>Frontend näyttää tällä hetkellä olemassaolevat muistiinpanot ja antaa muuttaa niiden tilaa. Uusia muistiinpanoja ei kuitenkaan voi lisätä, sillä osan 4 muutosten myötä backend edellyttää, että lisäyksen mukana on käyttäjän identiteetin varmistava token.</p>\n<p>Toteutetaan nyt osa käyttäjienhallinnan edellyttämästä toiminnallisuudesta frontendiin. Aloitetaan käyttäjän kirjautumisesta. Oletetaan vielä tässä osassa, että käyttäjät luodaan suoraan backendiin.</p>\n<p>Sovelluksen yläosaan on nyt lisätty kirjautumislomake, myös uuden muistiinpanon lisäämisestä huolehtiva lomake on siirretty sivun yläosaan:</p>\n<picture><img src=\"/static/bc4ef11529a49aaf08f532b14906da98/14be6/1.png\" srcset=\"/static/bc4ef11529a49aaf08f532b14906da98/4cce7/1.png 200w,\n/static/bc4ef11529a49aaf08f532b14906da98/bae5f/1.png 400w,\n/static/bc4ef11529a49aaf08f532b14906da98/14be6/1.png 800w,\n/static/bc4ef11529a49aaf08f532b14906da98/1b35a/1.png 1200w,\n/static/bc4ef11529a49aaf08f532b14906da98/9ee03/1.png 1600w,\n/static/bc4ef11529a49aaf08f532b14906da98/f064b/1.png 1942w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Komponentin <em>App</em> koodi näyttää seuraavalta:</p>\n<pre><code class=\"language-react\">import React from 'react'\nimport noteService from './services/notes'\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      notes: [],\n      newNote: '',\n      showAll: true,\n      error: null,\n      username: '',\n      password: '',\n      user: null\n    }\n  }\n\n  componentDidMount() {\n    noteService.getAll().then(notes =>\n      this.setState({ notes })\n    )\n  }\n\n  addNote = (event) => {\n    event.preventDefault()\n    const noteObject = {\n      content: this.state.newNote,\n      date: new Date(),\n      important: Math.random() > 0.5\n    }\n\n    noteService\n      .create(noteObject)\n      .then(newNote => {\n        this.setState({\n          notes: this.state.notes.concat(newNote),\n          newNote: ''\n        })\n      })\n  }\n\n  toggleImportanceOf = (id) => {\n    // ...\n  }\n\n  login = (event) => {\n    event.preventDefault()\n    console.log('logging in with', this.state.username, this.state.password)\n  }\n\n  handleNoteChange = (event) => {\n    this.setState({ newNote: event.target.value })\n  }\n\n  handlePasswordChange = (event) => {\n    this.setState({ password: event.target.value })\n  }\n\n  handleUsernameChange = (event) => {\n    this.setState({ username: event.target.value })\n  }\n\n  toggleVisible = () => {\n    this.setState({ showAll: !this.state.showAll })\n  }\n\n  render() {\n    // ...\n\n    return (\n      &#x3C;div>\n        &#x3C;h1>Muistiinpanot&#x3C;/h1>\n\n        &#x3C;Notification message={this.state.error} />\n\n        &#x3C;h2>Kirjaudu&#x3C;/h2>\n\n        &#x3C;form onSubmit={this.login}>\n          &#x3C;div>\n            käyttäjätunnus\n            &#x3C;input\n              type=\"text\"\n              value={this.state.username}\n              onChange={this.handleUsernameChange}\n            />\n          &#x3C;/div>\n          &#x3C;div>\n            salasana\n            &#x3C;input\n              type=\"password\"\n              value={this.state.password}\n              onChange={this.handlePasswordChange}\n            />\n          &#x3C;/div>\n          &#x3C;button type=\"submit\">kirjaudu&#x3C;/button>\n        &#x3C;/form>\n\n        &#x3C;h2>Luo uusi muistiinpano&#x3C;/h2>\n\n        &#x3C;form onSubmit={this.addNote}>\n          &#x3C;input\n            value={this.state.newNote}\n            onChange={this.handleNoteChange}\n          />\n          &#x3C;button type=\"submit\">tallenna&#x3C;/button>\n        &#x3C;/form>\n\n        &#x3C;h2>Muistiinpanot&#x3C;/h2>\n\n        // ...\n\n      &#x3C;/div >\n    )\n  }\n}\n\nexport default App\n</code></pre>\n<p>Sovelluksen tämänhetkinen koodi on kokonaisuudessaan <a href=\"https://github.com/FullStack-HY/part2-notes/tree/part5-1\">githubissa</a>, tagissa <em>part5-1</em>.</p>\n<p>Kirjautumislomakkeen käsittely noudattaa samaa periaatetta kuin <a href=\"/osa2#lomakkeet\">osassa 2</a>. Lomakkeen kenttiä varten on lisätty komponentin tilaan kentät <em>username</em> ja <em>password</em>. Molemmille kentille on rekisteröity muutoksenkäsittelijä (<em>handleUsernameChange</em> ja <em>handlePasswordChange</em>), joka synkronoi kenttään tehdyt muutokset komponentin <em>App</em> tilaan. Kirjautumislomakkeen lähettämisestä vastaava metodi <em>login</em> ei tee vielä mitään.</p>\n<p>Jos lomakkeella on paljon kenttiä, voi olla työlästä toteuttaa jokaiselle kentälle oma muutoksenkäsittelijä. React tarjoaakin tapoja, miten yhden muutoksenkäsittelijän avulla on mahdollista huolehtia useista syötekentistä. Jaetun käsittelijän on saatava jollain tavalla tieto minkä syötekentän muutos aiheutti tapahtuman. Eräs tapa tähän on lomakkeen syötekenttien nimeäminen.</p>\n<p>Lisätään <em>input</em> elementteihin nimet <em>name</em>-attribuutteina ja vaihdetaan molemmat käyttämään samaa muutoksenkäsittelijää:</p>\n<pre><code class=\"language-html\">&#x3C;form onSubmit=\"{this.login}\">\n  &#x3C;div>\n    käyttäjätunnus\n    &#x3C;input\n      type=\"text\"\n      name=\"username\"\n      value=\"{this.state.username}\"\n      onChange=\"{this.handleLoginFieldChange}\"\n    />\n  &#x3C;/div>\n  &#x3C;div>\n    salasana\n    &#x3C;input\n      type=\"password\"\n      name=\"password\"\n      value=\"{this.state.password}\"\n      onChange=\"{this.handleLoginFieldChange}\"\n    />\n  &#x3C;/div>\n  &#x3C;button type=\"submit\">kirjaudu&#x3C;/button>\n&#x3C;/form>\n</code></pre>\n<p>Yhteinen muutoksista huolehtiva tapahtumankäsittelijä on seuraava:</p>\n<pre><code class=\"language-js\">handleLoginFieldChange = event => {\n  if (event.target.name === 'password') {\n    this.setState({ password: event.target.value });\n  } else if (event.target.name === 'username') {\n    this.setState({ username: event.target.value });\n  }\n};\n</code></pre>\n<p>Tapahtumankäsittelijän parametrina olevan tapahtumaolion <em>event</em> kentän <em>target.name</em> arvona on tapahtuman aiheuttaneen komponentin <em>name</em>-attribuutti, eli joko <em>username</em> tai <em>password</em>. Koodi haarautuu nimen perusteella ja asettaa tilaan oikean kentän arvon.</p>\n<p>Javascriptissa on ES6:n myötä uusi syntaksi <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer\">computed property name</a>, jonka avulla olion kentän voi määritellä muuttujan avulla. Esim. seuraava koodi</p>\n<pre><code class=\"language-js\">const field = 'name';\n\nconst object = { [field]: 'Arto Hellas' };\n</code></pre>\n<p>määrittelee olion <code>{ name: 'Arto Hellas'}</code></p>\n<p>Näin saamme eliminoitua if-lauseen tapahtumankäsittelijästä ja se pelkistyy yhden rivin mittaiseksi:</p>\n<pre><code class=\"language-js\">handleLoginFieldChange = event => {\n  this.setState({ [event.target.name]: event.target.value });\n};\n</code></pre>\n<p>Kirjautuminen tapahtuu tekemällä HTTP POST -pyyntö palvelimen osoitteeseen <em>api/login</em>. Eristetään pyynnön tekevä koodi omaan moduuliin, tiedostoon <em>services/login.js</em>.</p>\n<p>Käytetään nyt promisejen sijaan <em>async/await</em>-syntaksia HTTP-pyynnön tekemiseen:</p>\n<pre><code class=\"language-js\">import axios from 'axios';\nconst baseUrl = '/api/login';\n\nconst login = async credentials => {\n  const response = await axios.post(baseUrl, credentials);\n  return response.data;\n};\n\nexport default { login };\n</code></pre>\n<p>Kirjautumisen käsittelystä huolehtiva metodi voidaan toteuttaa seuraavasti:</p>\n<pre><code class=\"language-js\">login = async event => {\n  event.preventDefault();\n  try {\n    const user = await loginService.login({\n      username: this.state.username,\n      password: this.state.password,\n    });\n\n    this.setState({ username: '', password: '', user });\n  } catch (exception) {\n    this.setState({\n      error: 'käyttäjätunnus tai salasana virheellinen',\n    });\n    setTimeout(() => {\n      this.setState({ error: null });\n    }, 5000);\n  }\n};\n</code></pre>\n<p>Kirjautumisen onnistuessa nollataan kirjautumislomakkeen kentät <em>ja</em> talletetaan palvelimen vastaus (joka sisältää <em>tokenin</em> sekä kirjautuneen käyttäjän tiedot) sovelluksen tilan kenttään <em>user</em>.</p>\n<p>Jos kirjautuminen epäonnistuu, eli metodin <em>loginService.login</em> suoritus aiheuttaa poikkeuksen, ilmoitetaan siitä käyttäjälle.</p>\n<p>Onnistunut kirjautuminen ei nyt näy sovelluksen käyttäjälle mitenkään. Muokataan sovellusta vielä siten, että kirjautumislomake näkyy vain <em>jos käyttäjä ei ole kirjautuneena</em> eli <em>this.state.user === null</em> ja uuden muistiinpanon luomislomake vain <em>jos käyttäjä on kirjautuneena</em>, eli (eli <em>this.state.user</em> sisältää kirjautuneen käyttäjän tiedot.</p>\n<p>Määritellään ensin komponentin <em>App</em> metodiin render apufunktiot lomakkeiden generointia varten:</p>\n<pre><code class=\"language-html\">const loginForm = () => (\n&#x3C;div>\n  &#x3C;h2>Kirjaudu&#x3C;/h2>\n\n  &#x3C;form onSubmit=\"{this.login}\">\n    &#x3C;div>\n      käyttäjätunnus\n      &#x3C;input\n        type=\"text\"\n        name=\"username\"\n        value=\"{this.state.username}\"\n        onChange=\"{this.handleLoginFieldChange}\"\n      />\n    &#x3C;/div>\n    &#x3C;div>\n      salasana\n      &#x3C;input\n        type=\"password\"\n        name=\"password\"\n        value=\"{this.state.password}\"\n        onChange=\"{this.handleLoginFieldChange}\"\n      />\n    &#x3C;/div>\n    &#x3C;button type=\"submit\">kirjaudu&#x3C;/button>\n  &#x3C;/form>\n&#x3C;/div>\n) const noteForm = () => (\n&#x3C;div>\n  &#x3C;h2>Luo uusi muistiinpano&#x3C;/h2>\n\n  &#x3C;form onSubmit=\"{this.addNote}\">\n    &#x3C;input value=\"{this.state.newNote}\" onChange=\"{this.handleNoteChange}\" />\n    &#x3C;button type=\"submit\">tallenna&#x3C;/button>\n  &#x3C;/form>\n&#x3C;/div>\n)\n</code></pre>\n<p>ja renderöidään ne ehdollisesti komponentin <em>App</em> render-metodissa:</p>\n<pre><code class=\"language-bash\">class App extends React.Component {\n  // ..\n  return (\n    &#x3C;div>\n      &#x3C;h1>Muistiinpanot&#x3C;/h1>\n\n      &#x3C;Notification message={this.state.error}/>\n\n      {this.state.user === null &#x26;&#x26; loginForm()}\n\n      {this.state.user !== null &#x26;&#x26; noteForm()}\n\n\n      &#x3C;h2>Muistiinpanot&#x3C;/h2>\n\n      // ...\n\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Lomakkeiden ehdolliseen renderöintiin käytetään hyväksi aluksi hieman erikoiselta näyttävää, mutta Reactin yhteydessä <a href=\"https://reactjs.org/docs/conditional-rendering.html#inline-if-with-logical--operator\">yleisesti käytettyä kikkaa</a>:</p>\n<pre><code class=\"language-js\">{\n  this.state.user === null &#x26;&#x26; loginForm();\n}\n</code></pre>\n<p>Jos ensimmäinen osa evaluoituu epätodeksi eli on <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Falsy\">falsy</a>, ei toista osaa eli lomakkeen generoivaa koodia suoriteta ollenkaan.</p>\n<p>Voimme suoraviivaistaa edellistä vielä hieman käyttämällä <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator\">kysymysmerkkioperaattoria</a>:</p>\n<pre><code class=\"language-html\">return (\n  &#x3C;div>\n    &#x3C;h1>Muistiinpanot&#x3C;/h1>\n\n    &#x3C;Notification message={this.state.error}/>\n\n    {this.state.user === null ?\n      loginForm() :\n      noteForm()\n    }\n\n    &#x3C;h2>Muistiinpanot&#x3C;/h2>\n\n    // ...\n\n  &#x3C;/div>\n)\n</code></pre>\n<p>Eli jos <em>this.state.user === null</em> on <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Truthy\">truthy</a>, suoritetaan <em>loginForm</em> ja muussa tapauksessa <em>noteForm</em>.</p>\n<p>Tehdään vielä sellainen muutos, että jos käyttäjä on kirjautunut, renderöidään kirjautuneet käyttäjän nimi:</p>\n<pre><code class=\"language-html\">return (\n  &#x3C;div>\n    &#x3C;h1>Muistiinpanot&#x3C;/h1>\n\n    &#x3C;Notification message={this.state.error}/>\n\n    {this.state.user === null ?\n      loginForm() :\n      &#x3C;div>\n        &#x3C;p>{this.state.user.name} logged in&#x3C;/p>\n        {noteForm()}\n      &#x3C;/div>\n    }\n\n    &#x3C;h2>Muistiinpanot&#x3C;/h2>\n\n    // ...\n\n  &#x3C;/div>\n)\n</code></pre>\n<p>Ratkaisu näyttää hieman rumalta, mutta jätämme sen koodiin toistaiseksi.</p>\n<p>Sovelluksen tämänhetkinen koodi on kokonaisuudessaan <a href=\"https://github.com/FullStack-HY/part2-notes/tree/part5-2\">githubissa</a>, tagissa <em>part5-2</em>. <strong>HUOM</strong> koodissa on parissa kohtaa käytetty vahingossa komponentin kentästä nimeä <em>new</em>note<em>, oikea (seuraaviin tageihin korjattu) muoto on _newNote</em>,</p>\n<p>Sovelluksemme pääkomponentti <em>App</em> on tällä hetkellä jo aivan liian laaja ja nyt tekemämme muutokset ovat ilmeinen signaali siitä, että lomakkeet olisi syytä refaktoroida omiksi komponenteikseen. Jätämme sen kuitenkin harjoitustehtäväksi.</p>\n<h2>Muistiinpanojen luominen</h2>\n<p>Frontend on siis tallettanut onnistuneen kirjautumisen yhteydessä backendilta saamansa tokenin sovelluksen tilaan <em>this.state.user.token</em>:</p>\n<picture><img src=\"/static/5d67dbfb8b1b9f57d2bc4e6587ab141d/14be6/1b.png\" srcset=\"/static/5d67dbfb8b1b9f57d2bc4e6587ab141d/4cce7/1b.png 200w,\n/static/5d67dbfb8b1b9f57d2bc4e6587ab141d/bae5f/1b.png 400w,\n/static/5d67dbfb8b1b9f57d2bc4e6587ab141d/14be6/1b.png 800w,\n/static/5d67dbfb8b1b9f57d2bc4e6587ab141d/1b35a/1b.png 1200w,\n/static/5d67dbfb8b1b9f57d2bc4e6587ab141d/9ee03/1b.png 1600w,\n/static/5d67dbfb8b1b9f57d2bc4e6587ab141d/dfb2e/1b.png 1658w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Korjataan uusien muistiinpanojen luominen siihen muotoon, mitä backend edellyttää, eli lisätään kirjautuneen käyttäjän token HTTP-pyynnön Authorization-headeriin.</p>\n<p><em>noteService</em>-moduuli muuttuu seuraavasti:</p>\n<pre><code class=\"language-js\">import axios from 'axios';\nconst baseUrl = '/api/notes';\n\nlet token = null;\n\nconst getAll = () => {\n  const request = axios.get(baseUrl);\n  return request.then(response => response.data);\n};\n\nconst setToken = newToken => {\n  token = `bearer ${newToken}`;\n};\n\nconst create = async newObject => {\n  const config = {\n    headers: { Authorization: token },\n  };\n\n  const response = await axios.post(baseUrl, newObject, config);\n  return response.data;\n};\n\nconst update = (id, newObject) => {\n  const request = axios.put(`${baseUrl}/${id}`, newObject);\n  return request.then(response => response.data);\n};\n\nexport default { getAll, create, update, setToken };\n</code></pre>\n<p>Moduulille on määritelty vain moduulin sisällä näkyvä muuttuja <em>token</em>, jolle voidaan asettaa arvo moduulin exporttaamalla funktiolla <em>setToken</em>. Async/await-syntaksiin muutettu <em>create</em> asettaa moduulin tallessa pitämän tokenin <em>Authorization</em>-headeriin, jonka se antaa axiosille metodin <em>post</em> kolmantena parametrina.</p>\n<p>Kirjautumisesta huolehtivaa tapahtumankäsittelijää pitää vielä viilata sen verran, että se kutsuu metodia <code>noteService.setToken(user.token)</code> onnistuneen kirjautumisen yhteydessä:</p>\n<pre><code class=\"language-js\">login = async event => {\n  event.preventDefault();\n  try {\n    const user = await loginService.login({\n      username: this.state.username,\n      password: this.state.password,\n    });\n\n    noteService.setToken(user.token);\n    this.setState({ username: '', password: '', user });\n  } catch (exception) {\n    // ...\n  }\n};\n</code></pre>\n<p>Uusien muistiinpanojen luominen onnistuu taas!</p>\n<h2>Tokenin tallettaminen selaimen local storageen</h2>\n<p>Sovelluksessamme on ikävä piirre: kun sivu uudelleenladataan, tieto käyttäjän kirjautumisesta katoaa. Tämä hidastaa melkoisesti myös sovelluskehitystä, esim. testatessamme uuden muistiinpanon luomista, joudumme joka kerta kirjautumaan järjestelmään.</p>\n<p>Ongelma korjaantuu helposti tallettamalla kirjautumistiedot <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Storage\">local storageen</a> eli selaimessa olevaan avain-arvo- eli <a href=\"https://en.wikipedia.org/wiki/Key-value_database\">key-value</a>-periaatteella toimivaan tietokantaan.</p>\n<p>Local storage on erittäin helppokäyttöinen. Metodilla <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Storage/setItem\">setItem</a> talletetaan tiettyä <em>avainta</em> vastaava <em>arvo</em>, esim:</p>\n<pre><code class=\"language-js\">window.localStorage.setItem('nimi', 'juha tauriainen');\n</code></pre>\n<p>tallettaa avaimen <em>nimi</em> arvoksi toisena parametrina olevan merkkijonon.</p>\n<p>Avaimen arvo selviää metodilla <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Storage/getItem\">getItem</a>:</p>\n<pre><code class=\"language-js\">window.localStorage.getItem('nimi');\n</code></pre>\n<p>ja <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Storage/removeItem\">removeItem</a> poistaa avaimen.</p>\n<p>Storageen talletetut arvot säilyvät vaikka sivu uudelleenladattaisiin. Storage on ns. <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Origin\">origin</a>-kohtainen, eli jokaisella selaimella käytettävällä web-sovelluksella on oma storagensa.</p>\n<p>Laajennetaan sovellusta siten, että se asettaa kirjautuneen käyttäjän tiedot local storageen.</p>\n<p>Koska storageen talletettavat arvot ovat <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/DOMString\">merkkijonoja</a>, emme voi tallettaa storageen suoraan Javascript-oliota, vaan ne on muutettava ensin JSON-muotoon metodilla <em>JSON.stringify</em>. Vastaavasti kun JSON-muotoinen olio luetaan local storagesta, on se parsittava takaisin Javascript-olioksi metodilla <em>JSON.parse</em>.</p>\n<p>Kirjautumisen yhteyteen tehtävä muutos on seuraava:</p>\n<pre><code class=\"language-js\">login = async event => {\n  event.preventDefault();\n\n  try {\n    const user = await loginService.login({\n      username: this.state.username,\n      password: this.state.password,\n    });\n\n    window.localStorage.setItem('loggedNoteappUser', JSON.stringify(user));\n    noteService.setToken(user.token);\n    this.setState({ username: '', password: '', user });\n  } catch (exception) {\n    // ...\n  }\n};\n</code></pre>\n<p>Kirjautuneen käyttäjän tiedot tallentuvat nyt local storageen ja niitä voidaan tarkastella konsolista:</p>\n<picture><img src=\"/static/256e4732704b788d35cfe2b5d3b203f0/14be6/2a.png\" srcset=\"/static/256e4732704b788d35cfe2b5d3b203f0/4cce7/2a.png 200w,\n/static/256e4732704b788d35cfe2b5d3b203f0/bae5f/2a.png 400w,\n/static/256e4732704b788d35cfe2b5d3b203f0/14be6/2a.png 800w,\n/static/256e4732704b788d35cfe2b5d3b203f0/1b35a/2a.png 1200w,\n/static/256e4732704b788d35cfe2b5d3b203f0/9ee03/2a.png 1600w,\n/static/256e4732704b788d35cfe2b5d3b203f0/e857d/2a.png 1666w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Sovellusta on vielä laajennettava siten, että kun sivulle tullaan uudelleen, esim. selaimen uudelleenlataamisen yhteydessä, tulee sovelluksen tarkistaa löytyykö local storagesta tiedot kirjautuneesta käyttäjästä. Jos löytyy, asetetaan ne sovelluksen tilaan ja <em>noteServicelle</em>.</p>\n<p>Sopiva paikka tähän on <em>App</em>-komponentin metodi <a href=\"https://reactjs.org/docs/react-component.html#componentdidmount\">componentDidMount</a> johon tutustuimme jo <a href=\"/osa2#komponenttien-lifecycle-metodit\">osassa 2</a>.</p>\n<p>Kyseessä on siis ns. lifecycle-metodi, jota React-kutsuu heti komponentin ensimmäisen renderöinnin jälkeen. Metodissa on tällä hetkellä jo muistiinpanot palvelimelta lataava koodi. Laajennetaan koodia seuraavasti</p>\n<pre><code class=\"language-js\">componentDidMount() {\n  noteService.getAll().then(notes =>\n    this.setState({ notes })\n  )\n\n  const loggedUserJSON = window.localStorage.getItem('loggedNoteappUser')\n  if (loggedUserJSON) {\n    const user = JSON.parse(loggedUserJSON)\n    this.setState({user})\n    noteService.setToken(user.token)\n  }\n}\n</code></pre>\n<p>Nyt käyttäjä pysyy kirjautuneena sovellukseen ikuisesti. Sovellukseen olisikin kenties syytä lisätä <em>logout</em>-toiminnallisuus, joka poistaisi kirjautumistiedot local storagesta. Jätämme kuitenkin uloskirjautumisen harjoitustehtäväksi.</p>\n<p>Meille riittää se, että sovelluksesta on mahdollista kirjautua ulos kirjoittamalla konsoliin</p>\n<pre><code class=\"language-js\">window.localStorage.removeItem('loggedNoteappUser');\n</code></pre>\n<p>tai local storagen tilan kokonaan nollaavan komennon</p>\n<pre><code class=\"language-js\">window.localStorage.clear();\n</code></pre>\n<p>Sovelluksen tämänhetkinen koodi on kokonaisuudessaan <a href=\"https://github.com/FullStack-HY/part2-notes/tree/part5-3\">githubissa</a>, tagissa <em>part5-3</em>.</p>\n<h2>Tehtäviä</h2>\n<p>Tee nyt tehtävät <a href=\"/teht%C3%A4v%C3%A4t#osa-5\">5.1-5.4</a></p>\n<h2>Kirjautumislomakkeen näyttäminen vain tarvittaessa</h2>\n<p>Muutetaan sovellusta siten, että kirjautumislomaketta ei oletusarvoisesti näytetä:</p>\n<picture><img src=\"/static/d80281d9b4145460638bd90d693d1a8a/14be6/3.png\" srcset=\"/static/d80281d9b4145460638bd90d693d1a8a/4cce7/3.png 200w,\n/static/d80281d9b4145460638bd90d693d1a8a/bae5f/3.png 400w,\n/static/d80281d9b4145460638bd90d693d1a8a/14be6/3.png 800w,\n/static/d80281d9b4145460638bd90d693d1a8a/1b35a/3.png 1200w,\n/static/d80281d9b4145460638bd90d693d1a8a/9ee03/3.png 1600w,\n/static/d80281d9b4145460638bd90d693d1a8a/00da9/3.png 1672w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Lomake aukeaa, jos käyttäjä painaa nappia <em>login</em>:</p>\n<picture><img src=\"/static/965f241a142c0bc26a29df36c0b7ecc7/14be6/4.png\" srcset=\"/static/965f241a142c0bc26a29df36c0b7ecc7/4cce7/4.png 200w,\n/static/965f241a142c0bc26a29df36c0b7ecc7/bae5f/4.png 400w,\n/static/965f241a142c0bc26a29df36c0b7ecc7/14be6/4.png 800w,\n/static/965f241a142c0bc26a29df36c0b7ecc7/1b35a/4.png 1200w,\n/static/965f241a142c0bc26a29df36c0b7ecc7/c6ea5/4.png 1506w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Napilla <em>cancel</em> käyttäjä saa tarvittaessa suljettua lomakkeen.</p>\n<p>Aloitetaan eristämällä kirjautumislomake omaksi komponentikseen:</p>\n<pre><code class=\"language-html\">const LoginForm = ({ handleSubmit, handleChange, username, password }) => {\nreturn (\n&#x3C;div>\n  &#x3C;h2>Kirjaudu&#x3C;/h2>\n\n  &#x3C;form onSubmit=\"{handleSubmit}\">\n    &#x3C;div>\n      käyttäjätunnus\n      &#x3C;input value=\"{username}\" onChange=\"{handleChange}\" name=\"username\" />\n    &#x3C;/div>\n    &#x3C;div>\n      salasana\n      &#x3C;input\n        type=\"password\"\n        name=\"password\"\n        value=\"{password}\"\n        onChange=\"{handleChange}\"\n      />\n    &#x3C;/div>\n    &#x3C;button type=\"submit\">kirjaudu&#x3C;/button>\n  &#x3C;/form>\n&#x3C;/div>\n) }\n</code></pre>\n<p>Reactin <a href=\"https://reactjs.org/docs/lifting-state-up.html\">suosittelemaan tyyliin</a> tila ja tilaa käsittelevät funktiot on kaikki määritelty komponentin ulkopuolella ja välitetään komponentille propseina.</p>\n<p>Huomaa, että propsit otetaan vastaan <em>destrukturoimalla</em>, eli sen sijaan että määriteltäisiin</p>\n<pre><code class=\"language-html\">const LoginForm = (props) => {\n  return (\n      &#x3C;form onSubmit={props.handleSubmit}>\n        &#x3C;div>\n          käyttäjätunnus\n          &#x3C;input\n            value={props.username}\n            onChange={props.handleChange}\n            name=\"username\"\n          />\n        &#x3C;/div>\n        // ...\n        &#x3C;button type=\"submit\">kirjaudu&#x3C;/button>\n      &#x3C;/form>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>jolloin muuttujan <em>props</em> kenttiin on viitattava muuttujan kautta esim. <em>props.handleSubmit</em>, otetaan kentät suoraan vastaan omiin muuttujiinsa.</p>\n<p>Nopea tapa toiminnallisuuden toteuttamiseen on muuttaa komponentin <em>App</em> käyttämä funktio <em>loginForm</em> seuraavaan muotoon:</p>\n<pre><code class=\"language-react\">const loginForm = () => {\n  const hideWhenVisible = { display: this.state.loginVisible ? 'none' : '' }\n  const showWhenVisible = { display: this.state.loginVisible ? '' : 'none' }\n\n  return (\n    &#x3C;div>\n      &#x3C;div style={hideWhenVisible}>\n        &#x3C;button onClick={e => this.setState({ loginVisible: true })}>log in&#x3C;/button>\n      &#x3C;/div>\n      &#x3C;div style={showWhenVisible}>\n        &#x3C;LoginForm\n          username={this.state.username}\n          password={this.state.password}\n          handleChange={this.handleLoginFieldChange}\n          handleSubmit={this.login}\n        />\n        &#x3C;button onClick={e => this.setState({ loginVisible: false })}>cancel&#x3C;/button>\n      &#x3C;/div>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Komponentin <em>App</em> tilaan on nyt lisätty kenttä <em>loginVisible</em> joka määrittelee sen näytetäänkö kirjautumislomake.</p>\n<p>Näkyvyyttä säätelevää tilaa vaihdellaan kahden napin avulla, molempiin on kirjoitettu tapahtumankäsittelijän koodi suoraan:</p>\n<pre><code class=\"language-react\">&#x3C;button onClick={e => this.setState({ loginVisible: true })}>log in&#x3C;/button>\n\n&#x3C;button onClick={e => this.setState({ loginVisible: false })}>cancel&#x3C;/button>\n</code></pre>\n<p>Komponenttien näkyvyys on määritelty asettamalla komponentille CSS-määrittely, jossa <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/display\">display</a>-propertyn arvoksi asetetaan <em>none</em> jos komponentin ei haluta näkyvän:</p>\n<pre><code class=\"language-html\">const hideWhenVisible = { display: this.state.loginVisible ? 'none' : '' } const\nshowWhenVisible = { display: this.state.loginVisible ? '' : 'none' } // ...\n\n&#x3C;div style=\"{hideWhenVisible}\">// nappi&#x3C;/div>\n\n&#x3C;div style=\"{showWhenVisible}\">// lomake&#x3C;/div>\n</code></pre>\n<p>Käytössä on taas kysymysmerkkioperaattori, eli jos <em>this.state.loginVisible</em> on <em>true</em>, tulee napin CSS-määrittelyksi</p>\n<pre><code class=\"language-css\">display: 'none';\n</code></pre>\n<p>jos <em>this.state.loginVisible</em> on <em>false</em>, ei <em>display</em> saa mitään (napin näkyvyyteen liittyvää) arvoa.</p>\n<p>Hyödynsimme mahdollisuutta määritellä React-komponenteille koodin avulla <a href=\"https://react-cn.github.io/react/tips/inline-styles.html\">inline</a>-tyylejä. Palaamme asiaan tarkemmin seuraavassa osassa.</p>\n<h2>Komponentin lapset, eli this.props.children</h2>\n<p>Kirjautumislomakkeen näkyvyyttä ympäröivän koodin voi ajatella olevan oma looginen kokonaisuutensa ja se onkin hyvä eristää pois komponentista <em>App</em> omaksi komponentikseen.</p>\n<p>Tavoitteena on luoda komponentti <em>Togglable</em>, jota käytetään seuraavalla tavalla:</p>\n<pre><code class=\"language-html\">&#x3C;Togglable buttonLabel=\"login\">\n  &#x3C;LoginForm\n    username={this.state.username}\n    password={this.state.password}\n    handleChange={this.handleLoginFieldChange}\n    handleSubmit={this.login}\n  />\n&#x3C;/Togglable>\n</code></pre>\n<p>Komponentin käyttö poikkeaa aiemmin näkemistämme siinä, että käytössä on nyt avaava ja sulkeva tagi, joiden sisällä määritellään toinen komponentti eli <em>LoginForm</em>. Reactin terminologiassa <em>LoginForm</em> on nyt komponentin <em>Togglable</em> lapsi.</p>\n<p><em>Togglablen</em> avaavan ja sulkevan tagin sisälle voi sijoittaa lapsiksi mitä tahansa React-elementtejä, esim.:</p>\n<pre><code class=\"language-html\">&#x3C;Togglable buttonLabel=\"paljasta\">\n  &#x3C;p>tämä on aluksi piilossa&#x3C;/p>\n  &#x3C;p>toinen salainen rivi&#x3C;/p>\n&#x3C;/Togglable>\n</code></pre>\n<p>Komponentin koodi on seuraavassa:</p>\n<pre><code class=\"language-react\">class Togglable extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      visible: false\n    }\n  }\n\n  toggleVisibility = () => {\n    this.setState({visible: !this.state.visible})\n  }\n\n  render() {\n    const hideWhenVisible = { display: this.state.visible ? 'none' : '' }\n    const showWhenVisible = { display: this.state.visible ? '' : 'none' }\n\n    return (\n      &#x3C;div>\n        &#x3C;div style={hideWhenVisible}>\n          &#x3C;button onClick={this.toggleVisibility}>{this.props.buttonLabel}&#x3C;/button>\n        &#x3C;/div>\n        &#x3C;div style={showWhenVisible}>\n          {this.props.children}\n          &#x3C;button onClick={this.toggleVisibility}>cancel&#x3C;/button>\n        &#x3C;/div>\n      &#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<p>Mielenkiintoista ja meille uutta on <a href=\"https://reactjs.org/docs/glossary.html#propschildren\">this.props.children</a>, jonka avulla koodi viittaa komponentin lapsiin, eli avaavan ja sulkevan tagin sisällä määriteltyihin React-elementteihin.</p>\n<p>Tällä kertaa lapset ainoastaan renderöidään komponentin oman renderöivän koodin seassa:</p>\n<pre><code class=\"language-html\">&#x3C;div style=\"{showWhenVisible}\">\n  {this.props.children}\n  &#x3C;button onClick=\"{this.toggleVisibility}\">cancel&#x3C;/button>\n&#x3C;/div>\n</code></pre>\n<p>Toisin kuin \"normaalit\" propsit, <em>children</em> on Reactin automaattisesti määrittelemä, aina olemassa oleva propsi. Jos komponentti määritellään automaattisesti suljettavalla eli <em>/></em> loppuvalla tagilla, esim.</p>\n<pre><code class=\"language-html\">&#x3C;Note\n  key={note.id}\n  note={note}\n  toggleImportance={this.toggleImportanceOf(note.id)}\n/>\n</code></pre>\n<p>on <em>this.props.children</em> tyhjä taulukko.</p>\n<p>Komponentti <em>Togglable</em> on uusiokäytettävä ja voimme käyttää sitä tekemään myös uuden muistiinpanon luomisesta huolehtivan formin vastaavalla tavalla tarpeen mukaan näytettäväksi.</p>\n<p>Eristetään ensin muistiinpanojen luominen omaksi komponentiksi</p>\n<pre><code class=\"language-react\">const NoteForm = ({ onSubmit, handleChange, value}) => {\n  return (\n    &#x3C;div>\n      &#x3C;h2>Luo uusi muistiinpano&#x3C;/h2>\n\n      &#x3C;form onSubmit={onSubmit}>\n        &#x3C;input\n          value={value}\n          onChange={handleChange}\n        />\n        &#x3C;button type=\"submit\">tallenna&#x3C;/button>\n      &#x3C;/form>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>ja määritellään lomakkeen näyttävä koodi komponentin <em>Togglable</em> sisällä</p>\n<pre><code class=\"language-html\">&#x3C;Togglable buttonLabel=\"new note\">\n  &#x3C;NoteForm\n    onSubmit={this.addNote}\n    value={this.state.newNote}\n    handleChange={this.handleNoteChange}\n  />\n&#x3C;/Togglable>\n</code></pre>\n<h2>ref eli viite komponenttiin</h2>\n<p>Ratkaisu on melko hyvä, haluaisimme kuitenkin parantaa sitä erään seikan osalta.</p>\n<p>Kun uusi muistiinpano luodaan, olisi loogista jos luomislomake menisi piiloon. Nyt lomake pysyy näkyvillä. Lomakkeen piilottamiseen sisältyy kuitenkin pieni ongelma, sillä näkyvyyttä kontrolloidaan <em>Togglable</em>-komponentin tilassa olevalla muuttujalla ja komponentissa määritellyllä metodilla <em>toggleVisibility</em>. Miten pääsemme niihin käsiksi komponentin ulkopuolelta?</p>\n<p>Koska React-komponentit ovat Javascript-olioita, on niiden metodeja mahdollista kutsua jos komponenttia vastaavaan olioon onnistutaan saamaan viite.</p>\n<p>Eräs keino viitteen saamiseen on React-komponenttien attribuutti <a href=\"https://reactjs.org/docs/refs-and-the-dom.html#adding-a-ref-to-a-class-component\">ref</a>.</p>\n<p>Muutetaan lomakkeen renderöivää koodia seuraavasti:</p>\n<pre><code class=\"language-bash\">&#x3C;div>\n  &#x3C;Togglable buttonLabel=\"new note\" ref={component => this.noteForm = component}>\n    &#x3C;NoteForm\n      ...\n    />\n  &#x3C;/Togglable>\n&#x3C;/div>\n</code></pre>\n<p>Kun komponentti <em>Togglable</em> renderöidään, suorittaa React ref-attribuutin sisällä määritellyn funktion:</p>\n<pre><code class=\"language-js\">component => (this.noteForm = component);\n</code></pre>\n<p>parametrin <em>component</em> arvona on viite komponenttiin. Funktio tallettaa viitteen muuttujaan <em>this.noteForm</em> eli <em>App</em>-komponentin kenttään <em>noteForm</em>.</p>\n<p>Nyt mistä tahansa komponentin <em>App</em> sisältä on mahdollista päästä käsiksi uusien muistiinpanojen luomisen sisältävään <em>Togglable</em>-komponenttiin.</p>\n<p>Voimme nyt piilottaa lomakkeen kutsumalla <em>this.noteForm.toggleVisibility()</em> samalla kun uuden muistiinpanon luominen tapahtuu:</p>\n<pre><code class=\"language-js\">addNote = e => {\n  e.preventDefault();\n  this.noteForm.toggleVisibility();\n\n  // ..\n};\n</code></pre>\n<p>Refeille on myös <a href=\"https://reactjs.org/docs/refs-and-the-dom.html\">muita käyttötarkoituksia</a> kuin React-komponentteihin käsiksi pääseminen.</p>\n<p>Sovelluksen tämänhetkinen koodi on kokonaisuudessaan <a href=\"https://github.com/FullStack-HY/part2-notes/tree/part5-4\">githubissa</a>, tagissa <em>part5-4</em>.</p>\n<h3>Huomio komponenteista</h3>\n<p>Kun Reactissa määritellään komponentti</p>\n<pre><code class=\"language-js\">class Togglable extends React.Component {\n  // ...\n}\n</code></pre>\n<p>ja otetaan se käyttöön seuraavasti</p>\n<pre><code class=\"language-react\">&#x3C;div>\n  &#x3C;Togglable buttonLabel=\"1\" ref={component => this.t1 = component}>\n    ensimmäinen\n  &#x3C;/Togglable>\n\n  &#x3C;Togglable buttonLabel=\"2\" ref={component => this.t2 = component}>\n    toinen\n  &#x3C;/Togglable>\n\n  &#x3C;Togglable buttonLabel=\"3\" ref={component => this.t3 = component}>\n    kolmas\n  &#x3C;/Togglable>\n&#x3C;/div>\n</code></pre>\n<p>syntyy <em>kolme erillistä komponenttiolioa</em>, joilla on kaikilla oma tilansa:</p>\n<picture><img src=\"/static/374425db96cf74f0606366ba4f6fcab3/14be6/5.png\" srcset=\"/static/374425db96cf74f0606366ba4f6fcab3/4cce7/5.png 200w,\n/static/374425db96cf74f0606366ba4f6fcab3/bae5f/5.png 400w,\n/static/374425db96cf74f0606366ba4f6fcab3/14be6/5.png 800w,\n/static/374425db96cf74f0606366ba4f6fcab3/1b35a/5.png 1200w,\n/static/374425db96cf74f0606366ba4f6fcab3/9ee03/5.png 1600w,\n/static/374425db96cf74f0606366ba4f6fcab3/8cea1/5.png 1878w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p><em>ref</em>-attribuutin avulla on talletettu viite jokaiseen komponenttiin muuttujiin <em>this.t1</em>, <em>this.t2</em> ja <em>this.t3</em>.</p>\n<h2>Tehtäviä</h2>\n<p>Tee nyt tehtävät <a href=\"/teht%C3%A4v%C3%A4t#komponenttien-n%C3%A4ytt%C3%A4minen-vain-tarvittaessa\">5.5-5.10</a></p>\n<h2>PropTypes</h2>\n<p>Komponentti <em>Togglable</em> olettaa, että sille määritellään propsina <em>buttonLabel</em> napin teksti. Jos määrittely unohtuu</p>\n<pre><code class=\"language-html\">&#x3C;Togglable> buttonLabel unohtui... &#x3C;/Togglable>\n</code></pre>\n<p>Sovellus kyllä toimii, mutta selaimeen renderöityy hämäävästi nappi, jolla ei ole mitään tekstiä.</p>\n<p>Haluaisimmekin varmistaa että jos <em>Togglable</em>-komponenttia käytetään, on propsille \"pakko\" antaa arvo.</p>\n<p>Kirjaston olettamat ja edellyttämät propsit ja niiden tyypit voidaan määritellä kirjaston <a href=\"https://github.com/facebook/prop-types\">prop-types</a> avulla. Asennetaan kirjasto</p>\n<pre><code class=\"language-bash\">npm install --save prop-types\n</code></pre>\n<p><em>buttonLabel</em> voidaan määritellä <em>pakolliseksi</em> string-tyyppiseksi propsiksi seuraavasti</p>\n<pre><code class=\"language-react\">import PropTypes from 'prop-types'\n\nclass Togglable extends React.Component {\n  // ...\n}\n\nTogglable.propTypes = {\n  buttonLabel: PropTypes.string.isRequired\n}\n</code></pre>\n<p>Jos propsia ei määritellä, seurauksena on konsoliin tulostuva virheilmoitus</p>\n<picture><img src=\"/static/41bb47a3ccd900b75691f688da28ae70/14be6/6.png\" srcset=\"/static/41bb47a3ccd900b75691f688da28ae70/4cce7/6.png 200w,\n/static/41bb47a3ccd900b75691f688da28ae70/bae5f/6.png 400w,\n/static/41bb47a3ccd900b75691f688da28ae70/14be6/6.png 800w,\n/static/41bb47a3ccd900b75691f688da28ae70/1b35a/6.png 1200w,\n/static/41bb47a3ccd900b75691f688da28ae70/9ee03/6.png 1600w,\n/static/41bb47a3ccd900b75691f688da28ae70/fa017/6.png 1692w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Koodi kuitenkin toimii edelleen, eli mikään ei pakota määrittelemään propseja PropTypes-määrittelyistä huolimatta. On kuitenkin erittäin epäprofessionaalia jättää konsoliin <em>mitään</em> punaisia tulosteita.</p>\n<p>Määritellään Proptypet myös <em>LoginForm</em>-komponentille:</p>\n<pre><code class=\"language-react\">import PropTypes from 'prop-types'\n\nconst LoginForm = ({ handleSubmit, handleChange, username, password }) => {\n  return (\n    // ...\n  )\n}\n\nLoginForm.propTypes = {\n  handleSubmit: PropTypes.func.isRequired,\n  handleChange: PropTypes.func.isRequired,\n  username: PropTypes.string.isRequired,\n  password: PropTypes.string.isRequired\n}\n</code></pre>\n<p>Funktionaalisen komponentin proptypejen määrittely tapahtuu samalla tavalla kuin luokkaperustaisten.</p>\n<p>Jos propsin tyyppi on väärä, esim. yritetään määritellä propsiksi <em>handleChange</em> merkkijono, seurauksena on varoitus:</p>\n<picture><img src=\"/static/cd199a5b2270dd60ddc9fb452ef9761d/14be6/7.png\" srcset=\"/static/cd199a5b2270dd60ddc9fb452ef9761d/4cce7/7.png 200w,\n/static/cd199a5b2270dd60ddc9fb452ef9761d/bae5f/7.png 400w,\n/static/cd199a5b2270dd60ddc9fb452ef9761d/14be6/7.png 800w,\n/static/cd199a5b2270dd60ddc9fb452ef9761d/1b35a/7.png 1200w,\n/static/cd199a5b2270dd60ddc9fb452ef9761d/9ee03/7.png 1600w,\n/static/cd199a5b2270dd60ddc9fb452ef9761d/536b3/7.png 1728w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Luokkaperustaisille komponenteille PropTypet on mahdollista määritellä myös <em>luokkamuuttujina</em>, seuraavalla syntaksilla:</p>\n<pre><code class=\"language-react\">import PropTypes from 'prop-types'\n\nclass Togglable extends React.Component {\n  static propTypes = {\n    buttonLabel: PropTypes.string.isRequired\n  }\n\n  // ...\n}\n</code></pre>\n<p>Muuttujamäärittelyn edessä oleva <em>static</em> määrittelee nyt, että <em>propTypes</em>-kenttä on nimenomaan komponentin määrittelevällä luokalla <em>Togglable</em> eikä luokan instansseilla. Oleellisesti ottaen kyseessä on ainoastaan Javascriptin vielä standardoimattoman <a href=\"https://github.com/tc39/proposal-class-fields\">ominaisuuden</a> mahdollistava syntaktinen oikotie määritellä seuraava:</p>\n<pre><code class=\"language-js\">Togglable.propTypes = {\n  buttonLabel: PropTypes.string.isRequired,\n};\n</code></pre>\n<p>Surffatessasi internetissä saatat vielä nähdä ennen Reactin versiota 0.16 tehtyjä esimerkkejä, joissa PropTypejen käyttö ei edellytä erillistä kirjastoa. Versiosta 0.16 alkaen PropTypejä ei enää määritelty React-kirjastossa itsessään ja kirjaston <em>prop-types</em> käyttö on pakollista.</p>\n<h2>Tehtäviä</h2>\n<p>Tee nyt tehtävä <a href=\"/teht%C3%A4v%C3%A4t#proptypet\">5.11</a></p>\n</div>","frontmatter":{"title":"osa 5","subTitle":"React+Redux","path":"/osa5/react-redux","mainImage":{"publicURL":"/static/osa5-8edc6044aad809a3143dc36c5e7f3b4c.png"},"partColor":"pink","part":5,"letter":"d"}}},"pageContext":{}}